{"meta":{"title":"又尔enter的blog","subtitle":null,"description":"Android开发小小鸟","author":"又尔enter","url":"http://yoursite.com"},"pages":[{"title":"enter | 404","date":"2018-04-15T06:49:30.198Z","updated":"2018-04-15T06:49:30.198Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404页面"},{"title":"","date":"2018-04-15T02:50:41.435Z","updated":"2018-04-15T02:50:41.435Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"延时","date":"2018-04-15T02:50:34.014Z","updated":"2018-04-15T02:50:34.014Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android线程间通信基础——Handler,Looper,MessageQueue","slug":"handler","date":"2018-04-15T12:13:58.000Z","updated":"2018-04-15T12:28:50.173Z","comments":true,"path":"2018/04/15/handler/","link":"","permalink":"http://yoursite.com/2018/04/15/handler/","excerpt":"","text":"Android单线程模型&emsp;&emsp;我们知道进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。早期的操作系统里进程既是资源分配也是调度的最小单位，后来随着cpu速度越来越快，为了更合理的使用cpu，减少进程切换的开销，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。&emsp;&emsp;当我们第一次打开一个App时，系统就会给这个App分配一个进程，并且启动一个main thread线程，主线程主要负责处理与UI相关的事件，如：用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以主线程通常又被叫做UI线程。&emsp;&emsp;在开发Android 应用时必须遵守单线程模型的原则： Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。 疑问&emsp;&emsp;既然UI操作只能在UI线程里更新，那么可不可以把所有操作都放在UI线程里面呢？答案是不可能的，可能会导致ANR。所以一些常用的耗时操作只能在非UI线程里执行，比如网络，数据库，IO操作等。那在非UI线程执行完后我们想把处理结果通知给UI线程怎么办，这就涉及到线程间通信的问题。&emsp;&emsp;传统的Java线程间通信包括volatile，synchronized，CountDownLatch等不适合于Android，因为AndroidUI线程是消息驱动模式，主线程在启动时会初始化一个Looper，并调用loop()方法开启死循环，在循环里执行处理消息的操作。 大致流程图如下： handler.png 流程讲解&emsp;&emsp;接下来我们以handler的创建为起始点，结合源码开始讲解。 hander创建（UI线程中）1handler = new Handler(); 查看构造函数：123public Handler() &#123; this(null, false);&#125; 这里可以传入两个参数，一个为callback，他是Handler的内部接口，里面只有一个方法：1234567public interface Callback &#123; /** * @param msg A &#123;@link android.os.Message Message&#125; object * @return True if no further handling is desired */ public boolean handleMessage(Message msg);&#125; 也就是我们初始化Handler的时候可以传入一个Callback，之后Looper会回调这个Callback。另一个参数表示是否是异步消息123456789101112131415161718192021Handler.javapublic Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; &emsp;&emsp;可以看见这里面会获取Looper，如果Looper为空，则会报错；由于Handler实在主线程里面创建的，默认用的是主线程的Looper，而主线程的Looper实在ActivityThread的main方法中创建的。所以如果在其他线程创建Handler必须显示的创建Looper。 &emsp;&emsp;我们进入Looper.myLooper()方法里面看看12345678910Handler.javastatic final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; &emsp;&emsp;ThreadLocal是一个类似于HashMap的数据结构，它主要是用于保存线程的局部变量，ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。&emsp;&emsp;也就是myLooper()会获取当前线程的Looper，那么主线程的Looper实在哪创建的呢？答案是在ActivityThread中1234567891011121314151617181920212223242526ActivityThread.java public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ... Looper.loop(); &#125;Looper.java/** * Initialize the current thread as a looper, marking it as an * application&apos;s main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */ public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125; &#125; 调用prepare方法1234567891011private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 所以就是在这创建完Looper的，并且创建想赢的MessageQueue，然后把Looper保存到ThreadLocal中结论：一个线程对应一个Looper对应一个MessageQueue 发送消息&emsp;&emsp; Handler创建完毕后，我们就可以发送消息了，发送消息有几种方式，如post(),sendMessage();最终都会调用handler的sendMessageAtTime()方法(post 的Runnnale也会包装成Message) 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; mQueue就是在创建Handler时赋值的，它会调用MessageQueue的enqueueMessage方法1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 这里要注意的是把msg.target指向了自己，这是为了Looper处理完消息后回调自己的相关方法。接下来进入MessageQueue里面 12345678910111213141516171819202122232425262728293031323334353637383940414243boolean enqueueMessage(Message msg, long when) &#123; ... //防止多个子线程同时发送消息，导致不可预知的错误 synchronized (this) &#123; ... msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; .... &#125; ....&#125; &emsp;&emsp;mMessages是当前Looper正在处理的消息，即消息队列的队头，赋值的地方是在next()方法里面；即如果当前队头的消息为空或者待入队的消息延时为0或者待入队的消息的延时小于队头的延时，则把待入队的消息插入到队的头部；&emsp;&emsp;这可以看出MessageQueue是一个按when顺序排列的优先级队列，队头的when是最小；&emsp;&emsp;同时加入之前是延迟消息，会阻塞当前队列，所以还需要唤醒 &emsp;&emsp;else里面会开启for循环，这个循环的目的是插入消息到链表的中间：如果插入消息到链表头部的条件不具备，则依次循环消息链表比较触发时间的长短，然后将消息插入到消息链表的合适位置。接着如果需要唤醒线程处理则调用C++中的nativeWake()函数。 这样handler插入消息的流程就完毕了 Looper消息循环&emsp;&emsp;当消息队列中有消息的时候，Looper就会去取出消息并执行，具体在Looper的loop()方法中。 123456789101112131415161718192021222324252627282930313233public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; ... for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ... msg.recycleUnchecked(); &#125; &#125; &emsp;&emsp;这里面主要就是从MessageQueue中取出Message执行，即调用queue.next()，然后handler的dispatchMessage()方法，前面提到过msg.target执行的就是我们的handler。然后回收message，可以复用；这也是为什么建议用Message.obtain()来生成message的原因。&emsp;&emsp;接下来看MessageQueue的next方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Message next() &#123; ... for (;;) &#123; ... nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; &#125; ...&#125; &emsp;&emsp;nativePollOnce(ptr, nextPollTimeoutMillis);是一个native方法，它的作用是在native层阻塞，对用nativeWake()唤醒，接下通过do while循环在MessageQueue中找message，如果Handler传入了async参数为true，这里的msg.isAsynchronous()为true，循环退出，即找出第一个不为空的同步message或者异步message；&emsp;&emsp;找到后会计算该message的执行时间是不是现在这个时间点，如果还没到它该执行的时间点，则计算剩余的时间 nextPollTimeoutMillis，否则的话该message就是我们要找的message，然后取出该message，并改变链表的指针。&emsp;&emsp;值得一提的是MessageQueue有个有趣的接口IdleHandler，看名字就知道它是个空的handler，当MessageQueue中没有消息的时候，如果有IdleHandler，则会调用queueIdle()方法，关于它的用法之后我们会讲到。 Message走了一圈又回到了HandlerMessage从子线程走到了主线程，走了一圈又回到了Handler 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; &emsp;&emsp;如果Message设置了回调方法的话，则回调该方法，这个是当我们调用handler.post(Runnable able)时设置的，即这个callback就是runnable，他会调用用runnable的run方法；&emsp;&emsp;如果Message没设置回调，并且handler设置了callback，这个callback是在构造方法里面设置的，之前讲到过，然后回调callback的handleMessage()；&emsp;&emsp;如果前两步都没设置回调，则会调用自身的handleMessage(msg)方法，这个就是我们熟悉的，经常复写的方法。 总结&emsp;&emsp;终上所述，一个message从子线程走到了主线程，这其中都是Handler的功劳，handler负责发送消息入队，然后处理消息，这样完成了一个操作从子线程到主线程的切换，其本质就是把一个操作从子线程传递给主线程。关于子线程更新UI的相关有趣操作我们会在另外的文章里讲。&emsp;&emsp;Tips1: handler在哪个线程创建，持有的就是哪个线程的Looper，MessageQueue。当然你也可以在构造函数中显示的指定哪个线程的Looper。比如主线程创建的默认是主线程的mainLooper。&emsp;&emsp;Tips2: 子线程创建Handler，由于子线程没有自己的Looper，所以必须显示调用Looper.prepare()创建Looper，并且显示的调用Looper.loop()方法开启消息循环。&emsp;&emsp;Tips3: handler的底层用的是Linux的管道通信，至于原因，我们之后再讲； Message流向图 message.png","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"http://yoursite.com/tags/Handler/"},{"name":"MessageQueue","slug":"MessageQueue","permalink":"http://yoursite.com/tags/MessageQueue/"},{"name":"Message","slug":"Message","permalink":"http://yoursite.com/tags/Message/"}]},{"title":"Android音频开发（五）——使用ffmpeg播放音频","slug":"audio5","date":"2018-04-15T06:28:44.000Z","updated":"2018-04-15T06:32:01.223Z","comments":true,"path":"2018/04/15/audio5/","link":"","permalink":"http://yoursite.com/2018/04/15/audio5/","excerpt":"","text":"上一节，我们做了很多准备工作，把ffmpeg源码编译成so供我们使用，这下我们终于可以来真正的使用它了。请大家使用最新版本你的AS，使用cmake，抛弃以前的mk。 首先，创建一个新的project，记得勾上Include C++ support，然后一路next就ok了。我们发现main下面多了一个cpp文件夹，这就是你放c/c++源代码的地方，为了用到我们的ffmpeg so文件，我们在main下面创建jniLibs,把编好的lib里面的so放进去。PS：之前我们编译的平台是armeabi，如果你想要x86可修改脚本文件中相关配置 111.jpg 其中main，sdl不是ffmpeg编译的so，大家不必在意。然后把include放进cpp文件夹，这些是需要的头文件， 然后在cpp目录下创建play_audio.cpp a3.png 12345678910111213141516171819202122232425262728#include &lt;jni.h&gt;#include &quot;log.h&quot;extern &quot;C&quot; &#123;#include &quot;AudioDevice.h&quot;&#125;//注意加extern &quot;C&quot;，否则将按照C++的编译方法吧方法名改了，则java层找不到相应的方法extern &quot;C&quot;JNIEXPORT jint JNICALLJava_com_dy_ffmpeg_PlayMusicActivity_play(JNIEnv *env, jobject instance, jstring url_) &#123; const char *url = env-&gt;GetStringUTFChars(url_, 0); LOGD(&quot;play&quot;); int code = play(url); return code;&#125;extern &quot;C&quot;JNIEXPORT jint JNICALLJava_com_dy_ffmpeg_PlayMusicActivity_stop(JNIEnv *env, jobject instance) &#123; // TODO LOGD(&quot;stop&quot;); int code = shutdown(); return code;&#125; 下面贴出关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 初始化操作，创建解码器 * @param file_name 文件名 * @param rate 采样率 * @param channel 通道数 * @return */int init(const char *file_name, int *rate, int *channel) &#123; //初始化 av_register_all(); aFormatCtx = avformat_alloc_context(); //读取输入的音频文件地址 if (avformat_open_input(&amp;aFormatCtx, file_name, NULL, NULL) != 0) &#123; LOGE(&quot;文件%s不存在！\\n&quot;, file_name); return -1; // Couldn&apos;t open file &#125; //查找文件的流信息 if (avformat_find_stream_info(aFormatCtx, NULL) &lt; 0) &#123; LOGE(&quot;文件流信息错误\\n&quot;); return -1; &#125; //找到第一个音频帧 int i; audioStream = -1; for (i = 0; i &lt; aFormatCtx-&gt;nb_streams; i++) &#123; if (aFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123; audioStream = i; break; &#125; &#125; if (audioStream == -1) &#123; LOGE(&quot;音频流未找到!&quot;); return -1; &#125; aCodecCtx = aFormatCtx-&gt;streams[audioStream]-&gt;codec; //获取相应音频流的解码器 AVCodec *aCodec = avcodec_find_decoder(aCodecCtx-&gt;codec_id); if (!aCodec) &#123; fprintf(stderr, &quot;不支持的音频格式!\\n&quot;); return -1; &#125; if (avcodec_open2(aCodecCtx, aCodec, NULL) &lt; 0) &#123; LOGE(&quot;无法打开解码器！\\n&quot;); return -1; // Could not open codec &#125; //分配一个帧指针，指向解码后的原始帧 aFrame = av_frame_alloc(); // 设置格式转换 swr = swr_alloc(); //输入通道数 av_opt_set_int(swr, &quot;in_channel_layout&quot;, aCodecCtx-&gt;channel_layout, 0); //输出通道数 av_opt_set_int(swr, &quot;out_channel_layout&quot;, aCodecCtx-&gt;channel_layout, 0); //输入采样率 av_opt_set_int(swr, &quot;in_sample_rate&quot;, aCodecCtx-&gt;sample_rate, 0); //输出采样率 av_opt_set_int(swr, &quot;out_sample_rate&quot;, aCodecCtx-&gt;sample_rate, 0); //输入采样位宽 av_opt_set_sample_fmt(swr, &quot;in_sample_fmt&quot;, aCodecCtx-&gt;sample_fmt, 0); //输出采样位宽，16bit av_opt_set_sample_fmt(swr, &quot;out_sample_fmt&quot;, AV_SAMPLE_FMT_S16, 0); swr_init(swr); // 分配PCM数据缓冲区大小 outputBufferSize = 8196; outputBuffer = (uint8_t *) malloc(sizeof(uint8_t) * outputBufferSize); // 返回采样率和通道数 *rate = aCodecCtx-&gt;sample_rate; *channel = aCodecCtx-&gt;channels; return 0;&#125;// 获取PCM数据, 自动回调获取int getPCM(void **pcm, size_t *pcmSize) &#123; LOGD(&quot;getPcm&quot;); while (av_read_frame(aFormatCtx, &amp;packet) &gt;= 0) &#123; int frameFinished = 0; // Is this a packet from the audio stream? if (packet.stream_index == audioStream) &#123; avcodec_decode_audio4(aCodecCtx, aFrame, &amp;frameFinished, &amp;packet); if (frameFinished) &#123; // data_size为音频数据所占的字节数 int data_size = av_samples_get_buffer_size( aFrame-&gt;linesize, aCodecCtx-&gt;channels, aFrame-&gt;nb_samples, aCodecCtx-&gt;sample_fmt, 1); // 这里内存再分配可能存在问题 if (data_size &gt; outputBufferSize) &#123; outputBufferSize = data_size; outputBuffer = (uint8_t *) realloc(outputBuffer, sizeof(uint8_t) * outputBufferSize); &#125; // 音频格式转换 swr_convert(swr, &amp;outputBuffer, aFrame-&gt;nb_samples, (uint8_t const **) (aFrame-&gt;extended_data), aFrame-&gt;nb_samples); // 返回pcm数据 *pcm = outputBuffer; *pcmSize = data_size; return 0; &#125; &#125; &#125; return -1;&#125; 然后是activity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.dy.ffmpeg;import android.os.Bundle;import android.os.Environment;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;public class PlayMusicActivity extends AppCompatActivity implements View.OnClickListener &#123; static &#123; System.loadLibrary(&quot;play_audio&quot;); &#125; private Button play; private Button stop; private String url; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_play_music); initView(); &#125; private void initView() &#123; play = (Button) findViewById(R.id.play); stop = (Button) findViewById(R.id.stop); play.setOnClickListener(this); stop.setOnClickListener(this); //获取文件地址,注意把音频文件放在该目录下，或者修改成你自己需要的路径 String folderurl = Environment.getExternalStorageDirectory().getPath(); url = folderurl + &quot;/Valentine.mp3&quot;; &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.play: new Thread(new Runnable() &#123; @Override public void run() &#123; int code = play(url); System.out.println(&quot;开始播放&quot;); &#125; &#125;).start(); break; case R.id.stop: new Thread(new Runnable() &#123; @Override public void run() &#123; int code = stop(); if (code == 0) &#123; System.out.println(&quot;停止成功&quot;); &#125; &#125; &#125;).start(); break; &#125; &#125; private native int play(String url); private native int stop();&#125; 接下来就是最重要的编写cmake接下来就是最重要的编写cmake 接下来就是最重要的编写cmake 上面我们做了这么多工作，gradle编译的时候怎么知道去哪找这些东西呢，就是重要的app目录下得CMakeLists.txt文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778cmake_minimum_required(VERSION 3.4.1)#设置so目录set(lib_src_DIR $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;)#添加头文件查找路径，包括引入库的和自己写的include_directories( $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/include)#添加动态库或静态库，其中本地的动态库名称,位置可以由set_target_properties设置add_library(avcodec-57_lib SHARED IMPORTED)set_target_properties(avcodec-57_lib PROPERTIES IMPORTED_LOCATION $&#123;lib_src_DIR&#125;/libavcodec-57.so)add_library(avformat-57_lib SHARED IMPORTED)set_target_properties(avformat-57_lib PROPERTIES IMPORTED_LOCATION $&#123;lib_src_DIR&#125;/libavformat-57.so)add_library(avutil-55_lib SHARED IMPORTED)set_target_properties(avutil-55_lib PROPERTIES IMPORTED_LOCATION $&#123;lib_src_DIR&#125;/libavutil-55.so)add_library(swresample-2_lib SHARED IMPORTED)set_target_properties(swresample-2_lib PROPERTIES IMPORTED_LOCATION $&#123;lib_src_DIR&#125;/libswresample-2.so)add_library(swscale-4_lib SHARED IMPORTED)set_target_properties(swscale-4_lib PROPERTIES IMPORTED_LOCATION $&#123;lib_src_DIR&#125;/libswscale-4.so)# build application&apos;s shared lib#这里是你自己编写的c/c++，因为用到ffmpeg的so，所以下面要链接它的库add_library(play_video SHARED $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/play_video.cpp)add_library(decode_video SHARED $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/decode_video.cpp)add_library(play_audio SHARED $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/play_audio.cpp $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/AudioDevice.c $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/FFmpegAudioPlay.c)#通过名称查找并引入库，可以引入 NDK 中的库，比如日志模块find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )#添加参加编译的库名称，也可以是绝对路径，注意被依赖的模块写在后面#特别注意，你想生成几个so，就要写几个link，写在一个link里面是错误的target_link_libraries(play_videologandroidavcodec-57_libavformat-57_libavutil-55_libswresample-2_libswscale-4_lib)target_link_libraries(decode_videologandroidavcodec-57_libavformat-57_libavutil-55_libswresample-2_libswscale-4_lib)#我们需要opensl es来辅助播放，注意加入opensl estarget_link_libraries(play_audiologOpenSLESandroidavcodec-57_libavformat-57_libavutil-55_libswresample-2_libswscale-4_lib) 然后编译执行，done，完整demo请移步我的github参考http://blog.csdn.net/leixiaohua1020/article/details/47008825","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"},{"name":"ffmpeg","slug":"Android/NDK/ffmpeg","permalink":"http://yoursite.com/categories/Android/NDK/ffmpeg/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/音视频/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://yoursite.com/tags/ffmpeg/"}]},{"title":"Android音频开发（四）——ffmpeg的编译","slug":"audio4","date":"2018-04-15T06:25:28.000Z","updated":"2018-04-15T06:29:16.861Z","comments":true,"path":"2018/04/15/audio4/","link":"","permalink":"http://yoursite.com/2018/04/15/audio4/","excerpt":"","text":"&emsp;&emsp;前几节我们讲的都是调用android原生API来进行音频的播放，编解码等操作，是在java层面，而且由于MediaCodec兼容性的限制，导致无法在API16以下使用，所以我们不得不放弃java层，转而寻求更为成熟的c/c++处理方案，再用jni去调用。所以，大名鼎鼎的ffmpeg闪亮登场了。 a1.jpg &emsp;&emsp;那么问题来了，怎么使用这个玩意儿了？接下来跟着我走 a2.jpg 首先&emsp;&emsp;去官网下载源码http://ffmpeg.org/download.html，最新版本是3.3.3，下载完成后我们在linux下把源码编译成android能用的so文件，当然你也可以直接打开cmd命令去使用它，熟悉它的一些命令。 &emsp;&emsp;我这里用的是VirtualBox+Ubuntu的方式去编译，为了方便，我这里专门设置了共享文件夹方便windows和ubuntu传输文件。共享文件夹的设置大家请百度吧。 a3.jpg 开始编译首先要安装NDK，下载好NDK后解压在用户根目录，并配置好环境变量 a3.png 输入gedit ~/.bashrc,加入以下代码export NDK_HOME=/home/dy/android-ndk-r14b注意换成你自己的路径，保存然后输入source ~/.bashrc编译一下即可 你可以测试一下有没有安装成功：$ cd $NDK_ROOT$ ./ndk-build NDK_PROJECT_PATH=$NDK_ROOT/samples/two-libs 在根目录下新建一个工程media，用于存放ffmpeg，和编译脚本，把你下载的ffmpeg源码放进来。 a4.png 然后找到ffmpeg文件夹下得configure文件，替换其中的几行123456789SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;将其修改成：SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos; &emsp;&emsp;为什么要这么做呢，这是因为如果直接按照未修改的配置进行编译，结果编译出来的so文件类似libavcodec.so.55.39.101，版本号位于so之后，Android无法加载 接下来在ffmpeg目录下新建脚本文件buildff.sh，文件内容如下123456789101112131415161718192021222324252627282930#清除上次编译的东西make clean#配置NDK路径,注意换成你自己的路径export NDK=/home/dy/android-ndk-r14b#配置工具链，注意查看是否有该路径，各个ndk版本不同，路径会有不同export PREBUILT=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt#配置平台，同上注意路径export PLATFORM=$NDK/platforms/android-9/arch-arm#配置编译好了之后的文件输出目录，$(pwd)当前目录下export PREFIX=$(pwd)/android/build_one()&#123; ./configure --target-os=linux --prefix=$PREFIX \\--enable-cross-compile \\--enable-runtime-cpudetect \\--disable-asm \\--arch=arm \\--cc=$PREBUILT/linux-x86_64/bin/arm-linux-androideabi-gcc \\--cross-prefix=$PREBUILT/linux-x86_64/bin/arm-linux-androideabi- \\--disable-stripping \\--nm=$PREBUILT/linux-x86_64/bin/arm-linux-androideabi-nm \\--sysroot=$PLATFORM \\--enable-gpl --enable-shared --disable-static --enable-nonfree --enable-version3 --enable-small \\--enable-zlib --disable-ffprobe --disable-ffplay --disable-ffmpeg --disable-ffserver --disable-debug \\--extra-cflags=&quot;-fPIC -DANDROID -D__thumb__ -mthumb -Wfatal-errors -Wno-deprecated -mfloat-abi=softfp -marm -march=armv7-a&quot; &#125;build_one#4线程编译make -j4make install 然后输入以下命令12chmod 777 ./buildff.sh ./build_android.sh 就开始编译了 编译完成后会在ffmpeg下生成android文件夹，里面就是include源文件和编译好的so文件，然后通过共享文件夹把android文件夹传给windows，供我们使用即可。 a5.png 最后上个妹子图缓解一下视力，接下来就是在AS里面运用了 6VD[D]L1MLP{EEZX8S498DG.png 下一篇","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"},{"name":"ffmpeg","slug":"Android/NDK/ffmpeg","permalink":"http://yoursite.com/categories/Android/NDK/ffmpeg/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/音视频/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://yoursite.com/tags/ffmpeg/"}]},{"title":"Android音频开发（三）——音频编解码","slug":"audio3","date":"2018-04-15T06:21:30.000Z","updated":"2018-04-15T06:25:17.222Z","comments":true,"path":"2018/04/15/audio3/","link":"","permalink":"http://yoursite.com/2018/04/15/audio3/","excerpt":"","text":"&emsp;&emsp;上一节中我们讲了怎么采集音频并播放，由于AudioRecord采集的是PCM数据，没有经过处理，所有播放的时候会有杂音，啸叫等现象出现。因此处理掉这些不需要的数据就是本节的内容，编码与解码。 原理知识&emsp;&emsp;Android官方提供给我们的用于编解码的类是MediaCodec,它是android 4.1（API 16）才引入的，所以只能工作于andorid4.1以上的手机，如果想兼容4.1以下版本的手机，只能使用第三方库，如大名鼎鼎的ffmpeg,B站的ijkplayer等。 MediaCodec介绍（1）提供了一套访问 Android 底层多媒体模块的接口，主要是音视频的编解码接口 （2）在Android上，预设的多媒体框架是基于第三方PacketVideo公司的OpenCORE来实现，OpenCORE的优点是兼顾了跨平台的移植性，而且已经过多方验证，所以相对来说较为稳定；缺点是国语庞大复杂，需要耗费相当多的时间去维护。因此从Android 2.0开始，Google引进了较为简洁的StageFright。Android 底层多媒体模块采用的是 StageFright 框架，它是基于OpenMax标准实现的，任何 Android 底层编解码模块的实现，都必须遵循 OpenMax 标准。值得一提的是，OpenMAX是Khronos制定的API，Khronos也是OpenGL的制定者。Google 官方默认提供了一系列的软件编解码器：包括：OMX.google.h264.encoder，OMX.google.h264.encoder， OMX.google.aac.encoder， OMX.google.aac.decoder 等等，而硬件编解码功能，则需要由芯片厂商依照 OpenMax 框架标准来完成，所以，一般采用不同芯片型号的手机，硬件编解码的实现和性能是不同的 （3）Android 应用层统一由 MediaCodec API 来提供各种音视频编解码功能，由参数配置来决定采用何种编解码算法、是否采用硬件编解码加速等等 MediaCodec原理 根据android官方文档的描述，MediaCodec的核心就是使用缓冲区队列来操作数据，使用流程如下：1234567891011- createEncoderByType/createDecoderByType- configure- start- while(1) &#123; - dequeueInputBuffer - queueInputBuffer - dequeueOutputBuffer - releaseOutputBuffer&#125;- stop- release &emsp;&emsp;MediaCodec 架构上采用了2个缓冲区队列，异步处理数据，下面描述的 Client 和 MediaCodec 模块是并行工作的（注：这里的 Client 就是指 “开发者，API 的使用者”）： （1）Client 从 input 缓冲区队列申请 empty buffer [dequeueInputBuffer] （2）Client 把需要编解码的数据拷贝到 empty buffer，然后放入 input 缓冲区队列 [queueInputBuffer] （3）MediaCodec 模块从 input 缓冲区队列取一帧数据进行编解码处理 （4）编解码处理结束后，MediaCodec 将原始数据 buffer 置为 empty 后放回 input 缓冲区队列，将编解码后的数据放入到 output 缓冲区队列 （5）Client 从 output 缓冲区队列申请编解码后的 buffer [dequeueOutputBuffer] （6）Client 对编解码后的 buffer 进行渲染/播放 （7）渲染/播放完成后，Client 再将该 buffer 放回 output 缓冲区队列 [releaseOutputBuffer] 实际操作&emsp;&emsp;那么杂实际操作中，我们该怎么使用呢，MediaCodec给我们提供了同步和异步两种使用方式,而在Android 5.0之后又引入了心得Buffer API，所以使用的时候必须兼容考虑这点 同步使用12345678910111213141516171819202122232425262728293031//name既是媒体文件的类型，如audio/3gpp，详情参考MediaFormat的MIMETYPE常量MediaCodec codec = MediaCodec.createByCodecName(name);codec.configure(format, …);MediaFormat outputFormat = codec.getOutputFormat(); // option Bcodec.start();for (;;) &#123; ////获取可用的inputBuffer -1代表一直等待，0表示不等待 建议-1,避免丢帧 int inputBufferId = codec.dequeueInputBuffer(-1); if (inputBufferId &gt;= 0) &#123; ByteBuffer inputBuffer = codec.getInputBuffer(…); // fill inputBuffer with valid data … codec.queueInputBuffer(inputBufferId, …); &#125; //执行上面的操作后就把待编解码的数据存入了输入缓冲区，然后下一步就是操作然后把编解码的数据存入输出缓冲区 int outputBufferId = codec.dequeueOutputBuffer(…); if (outputBufferId &gt;= 0) &#123; ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId); MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A // bufferFormat is identical to outputFormat // outputBuffer is ready to be processed or rendered. … codec.releaseOutputBuffer(outputBufferId, …); &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; // Subsequent data will conform to new format. // Can ignore if using getOutputFormat(outputBufferId) outputFormat = codec.getOutputFormat(); // option B &#125;&#125;codec.stop();codec.release(); 异步使用123456789101112131415161718192021222324252627282930313233343536373839MediaCodec codec = MediaCodec.createByCodecName(name);MediaFormat mOutputFormat; // member variablecodec.setCallback(new MediaCodec.Callback() &#123; @Override void onInputBufferAvailable(MediaCodec mc, int inputBufferId) &#123; ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId); // fill inputBuffer with valid data … codec.queueInputBuffer(inputBufferId, …); &#125; @Override void onOutputBufferAvailable(MediaCodec mc, int outputBufferId, …) &#123; ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId); MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A // bufferFormat is equivalent to mOutputFormat // outputBuffer is ready to be processed or rendered. … codec.releaseOutputBuffer(outputBufferId, …); &#125; @Override void onOutputFormatChanged(MediaCodec mc, MediaFormat format) &#123; // Subsequent data will conform to new format. // Can ignore if using getOutputFormat(outputBufferId) mOutputFormat = format; // option B &#125; @Override void onError(…) &#123; … &#125;&#125;);codec.configure(format, …);mOutputFormat = codec.getOutputFormat(); // option Bcodec.start();// wait for processing to completecodec.stop();codec.release(); android 5.0以下使用123456789101112131415161718192021222324252627 MediaCodec codec = MediaCodec.createByCodecName(name); codec.configure(format, …); codec.start();//API的区别在这里 ByteBuffer[] inputBuffers = codec.getInputBuffers(); ByteBuffer[] outputBuffers = codec.getOutputBuffers(); for (;;) &#123; int inputBufferId = codec.dequeueInputBuffer(…); if (inputBufferId &gt;= 0) &#123; // fill inputBuffers[inputBufferId] with valid data … codec.queueInputBuffer(inputBufferId, …); &#125; int outputBufferId = codec.dequeueOutputBuffer(…); if (outputBufferId &gt;= 0) &#123; // outputBuffers[outputBufferId] is ready to be processed or rendered. … codec.releaseOutputBuffer(outputBufferId, …); &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123; outputBuffers = codec.getOutputBuffers(); &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; // Subsequent data will conform to new format. MediaFormat format = codec.getOutputFormat(); &#125; &#125; codec.stop(); codec.release(); 最后&emsp;&emsp;在实际开发中，由于API版本的限制，我们很少使用android原生api进行编解码的操作，一般使用第三方库或者自己写c++写native代码打包成so库然后使用。但是我们必须了解其API原理，更进一步了解Java层的API是调用的C++的api来操作的，对于我们学习ndk开发及了解底层原理很有帮助，实例代码已上传至我的github，代码内容包括录音，播放，编码，解码等。下一篇参考：android mediacodec音频数据的编解码","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/音视频/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"}]},{"title":"Android音频开发（二）——音频采集与播放","slug":"audio2","date":"2018-04-15T05:46:24.000Z","updated":"2018-04-15T05:49:59.370Z","comments":true,"path":"2018/04/15/audio2/","link":"","permalink":"http://yoursite.com/2018/04/15/audio2/","excerpt":"","text":"&emsp;&emsp;上一节中我们介绍了音频的一些基本知识，这一节我们来讲述如何采集音频数据，然后将采集到的音频播放出来。 &emsp;&emsp;Android SDK 提供了两套音频采集的API，分别是：MediaRecorder 和 AudioRecord。根据官方文档的说法，该AudioRecord类管理Java应用程序的音频资源记录来自平台的音频输入硬件音频。这是通过“拉”（读）从AudioRecord对象中的数据来实现的。&emsp;&emsp;该应用程序负责轮询使用以下三种方法之一AudioRecord对象在时间：&emsp;&emsp;read(byte[], int, int)，read(byte[], int, int)，read(short[], int, int)，read(short[], int, int)或read(ByteBuffer, int)，read(java.nio.ByteBuffer, int)。要使用的方法的选择将基于这是最方便的AudioRecord的用户的声音数据的存储格式。 &emsp;&emsp;可以看见，它是更接近底层的方法，我们可以拿到byte原始的pcm数据。而MediaRecorder是更上层的API，它不仅可以记录音频，还可以录制视频，它的工作流如下图： mediarecorder_state_diagram.gif 同理MediaPlayer和AudioTrack。 本节我们将用AudioRecord来采集音频并用AudioTrack播放出来 使用AudioRecord之前的准备工作首先，我们了解一下 AudioRecord 的工作流程：（1） 配置参数，初始化内部的音频缓冲区（2） 开始采集（3） 新建一个线程，不断地从 AudioRecord 的缓冲区将音频数据“读”出来，注意，这个过程一定要及时，否则就会出现“overrun”的错误，该错误在音频开发中比较常见，意味着应用层没有及时地“取走”音频数据，导致内部的音频缓冲区溢出。（4） 停止采集，释放资源注意：缓冲区即类似生产者-消费者模型，AudioRecord把采集到的音频数据放在缓冲区，我们从缓冲区取出数据。我们不要自己设置缓冲区的大小，因为采集音频实际上是调用底层的c函数，这跟具体的设备相关，我们需要通过下面的方法可以获得最小缓冲区的大小：AudioRecord.getMinBufferSize(sampleRateInHz, channelInConfig, audioFormat);它实际上是调用的native_get_min_buff_size(int sampleRateInHz, int channelCount, int audioFormat); 然后，肯定要申请权限1&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt; 接下来，设置相关的参数，如采样率，通道数，位宽等。12345678910private int recBufSize, playBufSize;//采集缓冲区的大小，播放缓冲区的大小private static final int sampleRateInHz = 44100;//采样率private static final int channelInConfig = AudioFormat.CHANNEL_IN_MONO;//采集通道数private static final int channelOutConfig = AudioFormat.CHANNEL_OUT_MONO;//播放通道数private static final int audioFormat = AudioFormat.ENCODING_PCM_16BIT;//位数private AudioRecord mAudioRecord;private AudioTrack mAudioTrack;private boolean isRecording;//采集状态 12345678recBufSize = AudioRecord.getMinBufferSize(sampleRateInHz, channelInConfig, audioFormat);playBufSize = AudioTrack.getMinBufferSize(sampleRateInHz, channelOutConfig, audioFormat);mAudioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, sampleRateInHz, channelInConfig, audioFormat, recBufSize);mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRateInHz, channelOutConfig, audioFormat, playBufSize, AudioTrack.MODE_STREAM); 然后就是用线程去取数据12345678910111213141516171819202122232425262728class RecordThread extends Thread &#123; @Override public void run() &#123; //采集的音频缓冲区 byte[] buffer = new byte[recBufSize]; //开始采集 mAudioRecord.startRecording(); //采集的同时播放 mAudioTrack.play(); while (isRecording) &#123; //从音频缓冲区取出声音数据 int bufferReadResult = mAudioRecord.read(buffer, 0, recBufSize); //播放音频缓冲区 byte[] tempBuffer = new byte[bufferReadResult]; //把音频数据拷贝到播放缓冲区 System.arraycopy(buffer, 0, tempBuffer, 0, bufferReadResult); //播放声音 mAudioTrack.write(tempBuffer, 0, tempBuffer.length); &#125; //结束播放和采集 mAudioTrack.stop(); mAudioRecord.stop(); &#125; &#125; 可以设置按钮停止采集与播放，只需要设置isRecording为false即可。 测试一下当你拿到手机上使用时，会发现声音会有很大回音，但是带上耳机后就没了。 这是由于采集的原始pcm数据没有降噪处理，这种现象叫啸叫。所以这也是为什么我们要编码去除冗余的信息的原因，下一节我们将讲怎么编码音频数据。 下一篇","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/音视频/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"}]},{"title":"Android音频开发（一）——基础知识","slug":"audio1","date":"2018-04-15T05:30:33.000Z","updated":"2018-04-15T05:36:47.692Z","comments":true,"path":"2018/04/15/audio1/","link":"","permalink":"http://yoursite.com/2018/04/15/audio1/","excerpt":"","text":"前言&emsp;&emsp;前几天看到一个新闻说陌陌靠直播盈利了，在以前的印象中，陌陌只是一个那啥的软件，现在居然靠直播营收，说明现在直播的火热，因此我们有必要了解下Android音视频方面的知识。我们先了解一下音频。 音频的基本概念采样率（sampleRateInHz）&emsp;&emsp;我们知道，自然界中的声音是连续的模拟信号，而计算机只能识别二进制，因此需要把模拟信号转化为数字信号，这个过程就叫做采样。顾名思义，就是选取一些间断的点来转化。 d53f8794a4c27d1e5f214be71bd5ad6eddc43889.jpg &emsp;&emsp;如上图，当采样周期越短，即采样率越高，选取的点越多，则存储到计算机中的声音播放出来的效果更接近原声，根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音，所以采样率越高越好吗？当然不是，通常人耳能听到频率范围大约在20Hz～20kHz之间的声音，为了保证声音不失真，采样频率应在40kHz以上。常用的音频采样频率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz等。 采样精度（位宽audioFormat）&emsp;&emsp;上图中，每一个红色的采样点，都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit等等，位数越多，表示得就越精细，声音质量自然就越好，当然，数据量也会成倍增大。为了保持android各个版本的兼容性，一般选择16bit。 声道数（channelConfig）&emsp;&emsp;声道数是指支持能不同发声的音响的个数，常见的有单通道，双通道，立体声四通道等 音频帧（bufferSizeInBytes）&emsp;&emsp;大家都知道视频帧就是一幅图像，音频的帧的概念没有视频帧那么清晰，几乎所有视频编码格式都可以简单的认为一帧就是编码后的一副图像。但音频帧跟编码格式相关，它是各个编码标准自己实现的。在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的，我们可以计算一下一帧音频帧的大小：假设某音频信号是采样率为44.1kHz、双通道、位宽为16bit，40ms一帧，则一帧音频数据的大小为： int size =44100 x 2 x 16bit x 0.04s = 56488 bit = 7056 byte 编码&emsp;&emsp;android中采集音频后得到的是原始的PCM数据，这些数据代表着无损的原始数字音频信号，添加一些文件头信息，就可以存储为WAV文件了，它是一种由微软和IBM联合开发的用于音频数字存储的标准，可以很容易地被解析和播放。而其他格式如mp3等要经过编码后才能播放，编码的目的就是去除冗余信息。所以，一般你会发现你把mp3格式的音频转为wav后体积会变很大。 &emsp;&emsp;再简单介绍一下音频数据压缩的最基本的原理：因为有冗余信息，所以可以压缩。 &emsp;&emsp;（1） 频谱掩蔽效应： 人耳所能察觉的声音信号的频率范围为20Hz～20KHz，在这个频率范围以外的音频信号属于冗余信号。&emsp;&emsp;（2） 时域掩蔽效应： 当强音信号和弱音信号同时出现时，弱信号会听不到，因此，弱音信号也属于冗余信号。 Android应用层提供的API&emsp;&emsp;android提供了很多丰富的类供我们处理音频，而这些类实际上是通过jni调用了c/c++的函数。 &emsp;&emsp;音频采集： MediaRecoder，AudioRecord &emsp;&emsp;音频播放： SoundPool，MediaPlayer，AudioTrack &emsp;&emsp;音频编解码： MediaCodec &emsp;&emsp;NDK API： OpenSL ES 下一节，我们将讲述怎么录制音频","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"音视频","slug":"音视频","permalink":"http://yoursite.com/tags/音视频/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"}]},{"title":"listview相关问题——只更新某一个item","slug":"listview2","date":"2018-04-15T05:28:27.000Z","updated":"2018-04-15T05:29:41.195Z","comments":true,"path":"2018/04/15/listview2/","link":"","permalink":"http://yoursite.com/2018/04/15/listview2/","excerpt":"","text":"我们都知道，更新listview通常调用修改adapter的数据源，然后调用adapter的notifyDataSetChanged(); 但是有时候只是需要更新某一个指定的item，比如微信聊天应用中。这个时候，我们不需要去调用Adapter的notifyDataSetChanged（）方法。可以写一个updateItem(int position)的方法去更新指定项,这样代价就会小一些。 那么我们怎么拿到这个item然后去更新它的数据呢，其实listview提供了getChildAt(int index)方法让我们去获取，这个方法其实是ViewGroup的方法。并且由于一般使用了ViewHolder缓存机制，所以我们获取子item的时候要注意在可见区域的position去获取。123456789101112public void updataItem(int position) &#123; int firstVisiblePos = listView.getFirstVisiblePosition(); int lastVisibalePos = listView.getLastVisiblePosition(); if (position &gt;= firstVisiblePos &amp;&amp; position &lt;= lastVisibalePos) &#123; View view = listView.getChildAt(position - firstVisiblePos); ViewHolder viewHolder = (ViewHolder) view.getTag(); //然后使用viewholder去更新需要更新的view。 //TextView textView = (TextView) viewHolder.findViewById(R.id.textView); //textView.setText(&quot;11111&quot;); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ListView","slug":"ListView","permalink":"http://yoursite.com/tags/ListView/"},{"name":"EditText","slug":"EditText","permalink":"http://yoursite.com/tags/EditText/"}]},{"title":"Android近场通讯——NFC(二)","slug":"nfc2","date":"2018-04-15T05:21:18.000Z","updated":"2018-04-15T05:27:12.475Z","comments":true,"path":"2018/04/15/nfc2/","link":"","permalink":"http://yoursite.com/2018/04/15/nfc2/","excerpt":"","text":"在上一篇中，简单的介绍了下nfc的相关知识，这一篇将以代码的形式更深入的理解nfc。 准备工作首先肯定要申请相应的权限：&lt;uses-permission android:name=&quot;android.permission.NFC&quot; /&gt;&lt;uses-feature android:name=&quot;android.hardware.nfc&quot; android:required=&quot;true&quot; /&gt;&lt;uses-sdk android:minSdkVersion=&quot;14&quot;/&gt;同时要注意最小api的版本，根据谷歌官方的说话，NFC在Android上，也是从API9才开始支持的，但是到了API14 Google才对NFC大力开发，所以等到了API15的时候，NFC的传输速度就得到了很大的加强，所以最小api最好设置为14. 然后在相应的要接收nfc信息的activity中注册intent filter：123456789101112131415&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot;/&gt; &lt;data android:mimeType=&quot;text/plain&quot;/&gt;&lt;/intent-filter&gt;&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;/&gt;&lt;/intent-filter&gt;&lt;meta-data android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot; android:resource=&quot;@xml/nfc_tech_filter&quot;/&gt;&lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.TAG_DISCOVERED&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;&lt;/intent-filter&gt; 如果您的活动过滤器是ACTION_TECH_DISCOVERED，你必须创建一个指定的活动支持内技术的XML资源文件，可以通过android.nfc.Tag类的getTechList()获取子集其中名为nfc_tech_filter的xml文件如下：1234567891011121314151617181920212223&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcF&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcV&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NdefFormatable&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.MifareClassic&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.MifareUltralight&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt; 当然您也可以指定多个tech-list组。每个的tech-list集独立地考虑，并且您的活动被认为是一个匹配，如果任何一个 tech-list组是由返回的技术的一个子集getTechList()，这提供了AND与OR匹配技术，语义。下面的例子相匹配，可以支持NFCA和NDEF技术或可以支持NfcB和NDEF技术代码：12345678910111213&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt;&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt; 读取数据做了这么多，终于可以在activity里面读取，写入nfc了，首先我们定义了NfcScanActivity来扫描nfc设备1234567891011121314151617181920212223 ......//关键代码，onCreate中 // 获取默认的NFC控制器 mAdapter = NfcAdapter.getDefaultAdapter(this); if (mAdapter == null) &#123; promt.setText(&quot;设备不支持NFC！&quot;); return; &#125; if (!mAdapter.isEnabled()) &#123; promt.setText(&quot;请在系统设置中先启用NFC功能！&quot;); return; &#125; //创建intent检测nfc mPendingIntent = PendingIntent .getActivity(this, 0, new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);//onResumeif (this.mAdapter == null) return; if (!this.mAdapter.isEnabled()) &#123; promt.setText(&quot;请在系统设置中先启用NFC功能！&quot;); &#125; //监听nfc设备 this.mAdapter.enableForegroundDispatch(this, this.mPendingIntent, null, null); 因为我们注册了Intent Filter，当扫描到设备后，系统会调用我们的app，进而会进入activity的onNewIntent(Intent paramIntent)方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Override public void onNewIntent(Intent intent) &#123; setIntent(paramIntent); //我们接受到消息啦，可以处理了// 得到是否检测到TAG触发 if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(intent.getAction()) || NfcAdapter.ACTION_TAG_DISCOVERED.equals(intent.getAction()) || NfcAdapter.ACTION_NDEF_DISCOVERED.equals(intent.getAction())) &#123; // 处理该intent Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG); // 获取标签id数组 byte[] bytesId = tag.getId(); //获取消息内容 NfcMessageParser nfcMessageParser = new NfcMessageParser(intent); List&lt;String&gt; tagMessage = nfcMessageParser.getTagMessage(); if (tagMessage == null || tagMessage.size() == 0) &#123; //Toast.makeText(this, &quot;NFC格式不支持...&quot;, Toast.LENGTH_LONG).show(); &#125; else &#123; for (int i = 0; i &lt; tagMessage.size(); i++) &#123; Log.e(&quot;tag&quot;, tagMessage.get(i)); &#125; datas = tagMessage.get(0); &#125; String info = &quot;&quot;; if (datas != null) &#123; info += &quot;内容：&quot; + datas + &quot;\\n卡片ID：&quot; + bytesToHexString(bytesId) + &quot;\\n&quot;; &#125; else &#123; info += &quot;内容：空&quot; + &quot;\\n卡片ID：&quot; + bytesToHexString(bytesId) + &quot;\\n&quot;; &#125; String[] techList = tag.getTechList(); //分析NFC卡的类型： Mifare Classic/UltraLight Info String cardType = &quot;&quot;; for (String aTechList : techList) &#123; if (TextUtils.equals(aTechList, &quot;android.nfc.tech.Ndef&quot;)) &#123; Ndef ndef = Ndef.get(tag); cardType += &quot;最大数据尺寸:&quot; + ndef.getMaxSize() + &quot;字节&quot;; &#125; &#125; info += cardType; promt.setText(&quot;NFC信息如下：\\n&quot; + info); &#125; &#125; 传来的intent中包含了：EXTRA_TAG：一个Tag对象，表示扫描标签。EXTRA_NDEF_MESSAGES（可选）：从标签解析NDEF消息的数组，这个就是我们要的数据，显示到屏幕上。EXTRA_ID（可选）：标签的ID。处理消息的代码如下：1234567891011121314151617181920212223242526272829303132// 得到Intent中的NDEF数据 private NdefMessage[] getTagNdef(Intent intent) &#123; // TODO Auto-generated method stub NdefMessage[] msgs = null; Parcelable[] rawMsgs = intent .getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES); //把序列化数据转成Messaeg对象 if (rawMsgs != null) &#123; msgs = new NdefMessage[rawMsgs.length]; for (int i = 0; i &lt; rawMsgs.length; i++) &#123; msgs[i] = (NdefMessage) rawMsgs[i]; &#125; &#125; else &#123; // Unknown tag type byte[] empty = new byte[]&#123;&#125;; NdefRecord record = new NdefRecord(NdefRecord.TNF_UNKNOWN, empty, empty, empty); NdefMessage msg = new NdefMessage(new NdefRecord[]&#123;record&#125;); msgs = new NdefMessage[]&#123;msg&#125;; &#125; return msgs; &#125; // 把Message转成List private List&lt;String&gt; getNdefString(NdefMessage[] msgs) &#123; // TODO Auto-generated method stub if (msgs != null &amp;&amp; msgs.length != 0) &#123; List&lt;String&gt; tagMessage = parser(msgs[0]); return tagMessage; &#125; return null; &#125; 然后就可以显示到你想要的地方去了 写入数据NdefRecord对象写入数据最关键的就是创建一个NdefRecord对象，然后通过Ndef对象的writeNdefMessage(NdefMessage message)方法写入,当然前提还是要检测到设备，这里格式是TNF_WELL_KNOWN with RTD_TEXT，即写入文本字符串，如果你想写入其他数据，请参考官方文档12345678910111213141516171819202122/** * 创建record，格式为TNF_WELL_KNOWN with RTD_TEXT * * @param payload 你要写入的数据 * @param locale * @param encodeInUtf8 编码 * @return */public NdefRecord createTextRecord(String payload, Locale locale, boolean encodeInUtf8) &#123; byte[] langBytes = locale.getLanguage().getBytes(Charset.forName(&quot;US-ASCII&quot;)); Charset utfEncoding = encodeInUtf8 ? Charset.forName(&quot;UTF-8&quot;) : Charset.forName(&quot;UTF-16&quot;); byte[] textBytes = payload.getBytes(utfEncoding); int utfBit = encodeInUtf8 ? 0 : (1 &lt;&lt; 7); char status = (char) (utfBit + langBytes.length); byte[] data = new byte[1 + langBytes.length + textBytes.length]; data[0] = (byte) status; System.arraycopy(langBytes, 0, data, 1, langBytes.length); System.arraycopy(textBytes, 0, data, 1 + langBytes.length, textBytes.length); NdefRecord record = new NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_TEXT, new byte[0], data); return record;&#125; 生成需要的NdefMessage对象12 //textRecord就是上面生成的NdefRecordNdefMessage message = new NdefMessage(new NdefRecord[]&#123;textRecord&#125;); 最后写入数据：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 写入数据 * @param message * @param tag intent.getParcelableExtra(NfcAdapter.EXTRA_TAG); * @return */ boolean writeTag(NdefMessage message, Tag tag) &#123; int size = message.toByteArray().length; try &#123; //链接nfc Ndef ndef = Ndef.get(tag); if (ndef != null) &#123; ndef.connect(); if (!ndef.isWritable()) &#123;Toast.makeText(this, &quot;tag不允许写入&quot;, Toast.LENGTH_SHORT).show(); return false; &#125; if (ndef.getMaxSize() &lt; size) &#123;Toast.makeText(this,&quot;文件大小超出容量&quot;, Toast.LENGTH_SHORT).show(); return false; &#125; ndef.writeNdefMessage(message);Toast.makeText(this,&quot;写入数据成功.&quot;, Toast.LENGTH_SHORT).show(); isWrite = false; finish(); return true; &#125; else &#123; NdefFormatable format = NdefFormatable.get(tag); if (format != null) &#123; try &#123; format.connect(); format.format(message); Toast.makeText(this,&quot;格式化tag并且写入message&quot;, Toast.LENGTH_SHORT).show(); return true; &#125; catch (IOException e) &#123; Toast.makeText(this, &quot;格式化tag失败.&quot;, Toast.LENGTH_SHORT).show(); return false; &#125; &#125; else &#123; Toast.makeText(this, &quot;Tag不支持NDEF&quot;, Toast.LENGTH_SHORT).show(); return false; &#125; &#125; &#125; catch (Exception e) &#123; Toast.makeText(this,&quot;写入数据失败&quot;, Toast.LENGTH_SHORT).show(); &#125; return false; &#125; 完整代码已上传至github，欢迎clone，谢谢star","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://yoursite.com/tags/NFC/"},{"name":"近场通讯","slug":"近场通讯","permalink":"http://yoursite.com/tags/近场通讯/"}]},{"title":"Android近场通讯——NFC(一)","slug":"nfc1","date":"2018-04-15T05:07:18.000Z","updated":"2018-04-15T05:45:57.582Z","comments":true,"path":"2018/04/15/nfc1/","link":"","permalink":"http://yoursite.com/2018/04/15/nfc1/","excerpt":"","text":"前言&emsp;&emsp;NFC（Near Field Communication 近场通讯），它是前几年逐渐起来的一种技术，出来之后，感觉一直不温不火的样子。直到最近有个朋友需要手机与nfc标签读写信息，让我帮忙，所以才了解这门技术，下面我们一起来了解并学习一下。官方文档 近场通讯&emsp;&emsp;大家都知道android近场通讯包括我们最熟知的wifi，蓝牙，还有已经慢慢消失的红外，最后就是我们今天的主角nfc了，nfc与其他通信类型不同的是要求距离不能超过4cm（不同的nfc标签略有差别），查看官方文档，我们知道nfc通信的模式有一下三种： &emsp;&emsp;读卡器模式（Reader/Writer Mode）&emsp;&emsp;仿真卡模式（Card Emulation Mode）&emsp;&emsp;点对点模式（P2P Mode）nfc标签&emsp;&emsp;今天主要讲的是读写模式，在开始写代码之前，有必要了解nfc的标签调度系统，标签调度系统如何解析NFC标签和特殊的工作，当它检测到NDEF消息的标记调度系统一样。NFC标签来在广泛的技术和还可以有许多不同的方式写入到其中的数据。机器人具有用于NDEF标准NDEF数据被封装的消息（内部NdefMessage），其中包含一个或多个记录（NdefRecord）。每个NDEF记录必须根据您要创建的记录类型的规格良好的。Android版 ​​还支持其它类型的标签不包含NDEF的数据，您可以通过在使用类的工作android.nfc.tech包。要了解更多有关这些技术，请参阅高级NFC主题。这些其他类型的标签工作包括编写你自己的协议栈与标签进行通信，因此，我们建议使用NDEF在可能的情况，便于开发和最大支持Android的供电设备。 现在，你有NFC标签的背景，下面的章节详细描述了Android的如何处理NDEF格式化的标签。当一个Android设备扫描包含NDEF格式的数据的NFC标签，它解析该消息并试图找出数据的MIME类型或标识的URI。要做到这一点，系统读取所述第一NdefRecord内部的NdefMessage，以确定如何解释整个NDEF消息（一个NDEF消息可以有多个NDEF记录）。在一个结构良好的NDEF消息，第一个NdefRecord 包含以下字段： 3-bit TNF (Type Name Format) :指示如何解释可变长度类型字段 0HF]EHB8]IQN5AC1BFIAY3M.png Variable length type:描述了记录的类型。如果使用TNF_WELL_KNOWN，使用此字段指定记录类型定义（RTD） ZMUO)G4X)HRB%ZH0)DK_7J1.png Variable length payload:要读取或写入的实际数据的有效载荷。一个NDEF消息可以包含多个NDEF记录，所以不承担全部有效载荷在NDEF消息的第一NDEF纪录。 nfc分发&emsp;&emsp;说了这么多，Android系统是怎么检测到nfc靠近并通知相应的应用程序呢？其实就是用的Intent Filter,当我们在AndroidManifest.xml的activity中注册了相应的nfc intent后，当有相应的action来临时，系统就会把nfc分发到该App中，如果有多个App符合要求，则系统会弹出对话框让用户选择。标签调度系统定义了三个意图，优先级从高到低如下： ACTION_NDEF_DISCOVERED：&emsp;&emsp;本意图是用来启动一个活动时，它包含一个NDEF净荷标签的扫描和是一个公认的类型。&emsp;&emsp;这是最高优先级的意图，并且标签调度系统尝试尽可能任何其他意图，之前启动这一意图的活动。 ACTION_TECH_DISCOVERED：&emsp;&emsp;如果没有App注册过ACTION_NDEF_DISCOVERED，标签调度系统试图启动与此意向的应用程序。此意向也直接启动（不启动ACTION_NDEF_DISCOVERED在前），如果被扫描的标签包含无法映射到MIME类型或URI，或者如果标签不包含NDEF数据，但是是一个已知的标签技术NDEF数据。 ACTION_TAG_DISCOVERED：&emsp;&emsp;如果没有活动处理这一意图已启动ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED意图。 标签调度系统工作的基本方法如下：&emsp;&emsp;1.尝试启动与由标签调度系统解析NFC标签时（无论是创建一个意图活动ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED）。 &emsp;&emsp;2.如果这一意图没有活动过滤器，尝试下一个优先级最低的意图（无论是启动一个活动ACTION_TECH_DISCOVERED或ACTION_TAG_DISCOVERED，直到意图或直至标签调度系统中的应用程序过滤器尝试所有可能的目的。 &emsp;&emsp;3.如果没有应用程序筛选任何意图的，什么也不做。 nfc_tag_dispatch.png 只要有可能，以NDEF消息和工作ACTION_NDEF_DISCOVERED的意图，因为它是最特定出的三个。此意向，您可以在比其他两个意图更适当的时间启动应用程序，给用户更好的体验。 下一篇Android NFC(二)","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://yoursite.com/tags/NFC/"},{"name":"近场通讯","slug":"近场通讯","permalink":"http://yoursite.com/tags/近场通讯/"}]},{"title":"listview相关问题——item包含EditText","slug":"listview","date":"2018-04-15T04:56:01.000Z","updated":"2018-04-15T05:44:59.222Z","comments":true,"path":"2018/04/15/listview/","link":"","permalink":"http://yoursite.com/2018/04/15/listview/","excerpt":"","text":"&emsp;&emsp;在日常开发中，ListView是我们常用的控件，也是遇到坑比较多的一个控件。在之前的项目中，有这样的一个布局需求，在ListView的item中包含有EditText，第一个问题就是焦点问题，会发现edittext获取不到焦点。 焦点问题&emsp;&emsp;比如我们有如下的代码： activity_main.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@+id/listView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/RelativeLayout&gt; MainActivity.java1234567891011public class MainActivity extends Activity &#123; ListView mListView; MyAdapter mMyAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mListView = (ListView) findViewById(R.id.listView); mMyAdapter = new MyAdapter(this); mListView.setAdapter(mMyAdapter); &#125;&#125; MyAdapter.java1234567891011121314151617181920212223242526272829public class MyAdapter extends BaseAdapter &#123; private Context mContext; public MyAdapter(Context context) &#123; this.mContext = context; &#125; @Override public int getCount() &#123; return 20; &#125; @Override public Object getItem(int position) &#123; return null; &#125; @Override public long getItemId(int position) &#123; return 0; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; EditText editText; if (convertView == null) &#123; editText = new EditText(mContext); convertView = editText; &#125; else &#123; editText = (EditText) convertView; &#125; System.out.println(&quot;current pos:&quot; + position); return convertView; &#125;&#125; &emsp;&emsp;当你运行上述简单的代码后发现EditText是无法获取焦点的，导致无法输入任何东东，那么原因何在呢？ &emsp;&emsp;其实，是listview先于子item抢占了焦点，那么我们首先想到的就是让listview失去焦点，让子item获取焦点（当然，listview 的onitem相关监听事件会失效）。1mListView.setFocusable(false); &emsp;&emsp;这是再运行发现键盘弹出了，可是editText获取到焦点然后又失去了，需要你手动再次点击才能获取到，然后才能输入。而且当你输入完毕，关闭软键盘，发现输入的东西不见了，自动清空。这又产生了两个问题。 第一个问题是listview每次调用getview都会使EditText失去焦点，第二个问题归结于下面要讲的listview的item复用产生的问题。 第一种方式行不通，查询相关资料发现，可以通过给listview的item的根布局设置descendantFocusability属性。 android:descendantFocusability属性有三个值：beforeDescendants：viewgroup会优先其子类控件而获取到焦点 afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点 blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点 那么我们修改adapter中的getView方法12345678910111213@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; EditText editText; if (convertView == null) &#123; convertView = LayoutInflater.from(mContext).inflate(R.layout.list_edittext, parent, false); editText = (EditText) convertView.findViewById(R.id.editText); convertView.setTag(editText); &#125; else &#123; editText = (EditText) convertView.getTag(); &#125; System.out.println(&quot;current pos:&quot; + position); return convertView;&#125; list_edittext.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:descendantFocusability=&quot;beforeDescendants&quot; android:orientation=&quot;vertical&quot;&gt; &lt;EditText android:id=&quot;@+id/editText&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt; 发现还是无效果，其实我们少了一句关键的代码，就是给相应的 activity 设置 windowSoftInputMode= adjustPan 即可。。 终上所述，我认为的解决方案就是给ListView或者ListView的item的根布局添加android:descendantFocusability=”beforeDescendants”，然后设置相应的activity 的windowSoftInputMode属性为adjustPan 。 数据问题&emsp;&emsp;解决完焦点问题后，另一个问题就是edittext的数据问题了。当我们在当前屏幕的edittext中输入东东后，往下滑，发现下面的edittext自动输入了我们输入过得东东，这明显是我们不愿意看到的。 其实这是由于getView方法的复用view导致的，加入你在position=0的edittext中输入了内容，当你往下滑时，当position为0的view完全消失时，该view会被加入到 mActiveViews[]中，当下方的item检测到由可用的view，则从该数组中取出，所以下方的edittext的内容会跟上面你输入的一样，其实就是同一个edittext。关于listview源码级解析详见链接 解决方案——保存edittext的内容修改adapter代码：12//新增一个数组用于保存edittext的内容private SparseArray&lt;String&gt; mStringSparseArray; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overridepublic View getView(final int position, View convertView, ViewGroup parent) &#123; EditTextHolder editTextHolder; if (convertView == null) &#123; convertView = LayoutInflater.from(mContext).inflate(R.layout.list_edittext, parent, false); editTextHolder = new EditTextHolder(); editTextHolder.mEditText = (EditText) convertView.findViewById(R.id.editText); editTextHolder.mMyTextWatcher = new MyTextWatcher(position, mStringSparseArray); //给edittext设置watcher editTextHolder.mEditText.addTextChangedListener(editTextHolder.mMyTextWatcher); convertView.setTag(editTextHolder); &#125; else &#123; editTextHolder = (EditTextHolder) convertView.getTag(); //由于复用了edittext，导致他的watcher里的position还是之前的positiono，所以需要通知 //watcher更新positon，才能保存正确的positon的值 editTextHolder.updatePosition(position); &#125; System.out.println(position); editTextHolder.mEditText.setText(mStringSparseArray.get(position)); return convertView;&#125;static class EditTextHolder &#123; EditText mEditText; MyTextWatcher mMyTextWatcher; public void updatePosition(int position) &#123; mMyTextWatcher.updatePosition(position); &#125;&#125;static class MyTextWatcher implements TextWatcher &#123; private int position; private SparseArray&lt;String&gt; sparseArray; //更新postion public void updatePosition(int position) &#123; this.position = position; &#125; public MyTextWatcher(int position, SparseArray&lt;String&gt; sparseArray) &#123; this.position = position; this.sparseArray = sparseArray; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; //保存edittext的值 sparseArray.put(position, s.toString()); &#125;&#125; 运行代码，发现edittext数据错乱问题解决，此方法同样适用于checkbox错乱等问题。 demo工程已上传至github，有需要的可去download","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ListView","slug":"ListView","permalink":"http://yoursite.com/tags/ListView/"},{"name":"EditText","slug":"EditText","permalink":"http://yoursite.com/tags/EditText/"}]},{"title":"表格筛选控件","slug":"grid","date":"2018-04-15T04:03:32.000Z","updated":"2018-04-15T05:44:24.966Z","comments":true,"path":"2018/04/15/grid/","link":"","permalink":"http://yoursite.com/2018/04/15/grid/","excerpt":"","text":"&emsp;&emsp;最近在做一个ERP的项目，产品要求做一个类似京东，淘宝，伙伴云表格的筛选控件，如下图所示： S70301-160019.jpg 思路&emsp;&emsp;这个页面其实一个主页面的Activity，右滑弹出一个抽屉DrawerLayout，抽屉其实是一个fragment，我们主要的布局就在fragment里面。而这个筛选控件其中的一个其实是下拉菜单。当然原生的spinner太丑而且不符合要求，所以我用一个LinearLayout包含一个TextView（drawableRight下拉图标），加一个listview来构造。 行动代码&emsp;&emsp;思路有了，接下来就是代码行动了，首先我们封装这个控件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412public class MySpinnerView extends LinearLayout implements MySpinnerAdapter.RadioButtonClick &#123; //用于下拉图标的动画 private static final int MAX_LEVEL = 10000; //用于状态保存 private static final String INSTANCE_STATE = &quot;instance_state&quot;; private static final String SELECTED_INDEX = &quot;selected_index&quot;; private static final String IS_POPUP_SHOWING = &quot;is_popup_showing&quot;; private int selectedIndex;//选中的位置 private Drawable drawable;//下拉图标 private ListView listView; private MySpinnerAdapter adapter;//用于listview的adapter private AdapterView.OnItemClickListener onItemClickListener; private AdapterView.OnItemSelectedListener onItemSelectedListener; private boolean isArrowHide, isShowing;//是否显示 private int textColor; private int backgroundSelector;//选中颜色 private int datasId; private TextView titleView;//title private String titleText; private int defaultPadding;//默认padding private List&lt;FilterDataItem&gt; mFilterDataItems;//筛选的数据源 private String startDate, endDate; private int lastPos = -1;//保存最近一次选中的位置 public MySpinnerView(Context context) &#123; super(context); getAttrs(context, null); init(context, null); &#125; public MySpinnerView(Context context, AttributeSet attrs) &#123; super(context, attrs); getAttrs(context, attrs); init(context, attrs); &#125; public MySpinnerView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); getAttrs(context, attrs); init(context, attrs); &#125; @Override public Parcelable onSaveInstanceState() &#123; Bundle bundle = new Bundle(); bundle.putParcelable(INSTANCE_STATE, super.onSaveInstanceState()); bundle.putInt(SELECTED_INDEX, selectedIndex); bundle.putBoolean(IS_POPUP_SHOWING, isShowing); dismissDropDown(); return bundle; &#125; @Override public void onRestoreInstanceState(Parcelable savedState) &#123; if (savedState instanceof Bundle) &#123; Bundle bundle = (Bundle) savedState; selectedIndex = bundle.getInt(SELECTED_INDEX); if (adapter != null) &#123; setTitle(selectedIndex); // adapter.notifyItemSelected(selectedIndex); &#125; if (bundle.getBoolean(IS_POPUP_SHOWING)) &#123; if (isShowing) &#123; post(new Runnable() &#123; @Override public void run() &#123; showDropDown(); &#125; &#125;); &#125; &#125; savedState = bundle.getParcelable(INSTANCE_STATE); &#125; super.onRestoreInstanceState(savedState); &#125; /** * 获取相关属性attr * * @param context * @param attrs */ private void getAttrs(Context context, AttributeSet attrs) &#123; // TODO Auto-generated constructor stub // 通过这个方法，将你在attrs.xml中定义的declare=styleable // 的所有属性的值存储到TypedArray中 TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.MySpinnerView); // 从TypedArray中取出对应的值来为要设置的属性赋值 titleText = ta.getString(R.styleable.MySpinnerView_msv_title); datasId = ta.getResourceId(R.styleable.MySpinnerView_msv_array, 0); defaultPadding = getResources().getDimensionPixelSize(R.dimen.one_and_a_half_grid_unit); setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);// setPadding(getResources().getDimensionPixelSize(R.dimen.three_grid_unit), defaultPadding, defaultPadding,// defaultPadding); setClickable(true); backgroundSelector = ta.getResourceId(R.styleable.MySpinnerView_msv_backgroundSelector, R.drawable.spinner_selector); textColor = ta.getColor(R.styleable.MySpinnerView_msv_textTint, -1); isShowing = ta.getBoolean(R.styleable.MySpinnerView_msv_isShow, false); isArrowHide = ta.getBoolean(R.styleable.MySpinnerView_msv_hideArrow, false); if (!isArrowHide) &#123; //不隐藏则显示图标 Drawable basicDrawable = ContextCompat.getDrawable(context, R.drawable.spinner_arrow); int resId = ta.getColor(R.styleable.MySpinnerView_msv_arrowTint, -1); if (basicDrawable != null) &#123; drawable = DrawableCompat.wrap(basicDrawable); if (resId != -1) &#123; DrawableCompat.setTint(drawable, resId); &#125; &#125; &#125; ta.recycle(); &#125; private void init(final Context context, AttributeSet attrs) &#123; setOrientation(VERTICAL); titleView = new TextView(context); titleView.setText(titleText); titleView.setPadding(defaultPadding, defaultPadding, defaultPadding, defaultPadding); if (!isArrowHide) &#123; titleView.setCompoundDrawablesWithIntrinsicBounds(null, null, drawable, null); &#125; listView = new ListViewInSrcollView(context); listView.setId(getId()); listView.setDivider(null); listView.setItemsCanFocus(true); //隐藏scrollbars listView.setVerticalScrollBarEnabled(false); listView.setHorizontalScrollBarEnabled(false); listView.setBackgroundResource(backgroundSelector); //数据源，这里测试用的是assets中的json，开发者可自行构造bean和数据源 if (datasId != 0) &#123; final String[] temp = getResources().getStringArray(datasId); mFilterDataItems = new ArrayList&lt;&gt;(); for (String aTemp : temp) &#123; mFilterDataItems.add(new FilterDataItem(0, aTemp, false)); &#125; adapter = new MySpinnerAdapter(mFilterDataItems, this); setAdapterInternal(adapter); &#125; listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; spinnerClick(position); &#125; &#125;); addView(titleView); addView(listView); if (isShowing) &#123; listView.setVisibility(View.VISIBLE); &#125; else &#123; listView.setVisibility(View.GONE); &#125; &#125; /** * 获取当前选中的位置 * * @return */ public int getSelectedIndex() &#123; return selectedIndex; &#125; /** * 设置当前选中位置 * * @param position 位置 */ public void setSelectedIndex(int position) &#123; if (adapter != null) &#123; if (position &gt;= 0 &amp;&amp; position &lt;= adapter.getCount()) &#123; //adapter.notifyItemSelected(position); selectedIndex = position; setTitle(position); &#125; else &#123; throw new IllegalArgumentException(&quot;Position must be lower than adapter count!&quot;); &#125; &#125; &#125; public void addOnItemClickListener(@NonNull AdapterView.OnItemClickListener onItemClickListener) &#123; this.onItemClickListener = onItemClickListener; &#125; public void setOnItemSelectedListener(@NonNull AdapterView.OnItemSelectedListener onItemSelectedListener) &#123; this.onItemSelectedListener = onItemSelectedListener; &#125; /** * 设置adapter * * @param adapter */ private void setAdapterInternal(MySpinnerAdapter adapter) &#123; // If the adapter needs to be settled again, ensure to reset the selected index as well //selectedIndex = 0; listView.setAdapter(adapter); //setTitle(selectedIndex); &#125; /** * 设置adapter * * @param filterDataItems 数据源 */ public void setAdapter(List&lt;FilterDataItem&gt; filterDataItems) &#123; this.mFilterDataItems = filterDataItems; this.adapter = new MySpinnerAdapter(filterDataItems, this); setAdapterInternal(adapter); &#125; @Override public boolean onTouchEvent(@NonNull MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_UP) &#123; if (!isShowing) &#123; showDropDown(); &#125; else &#123; dismissDropDown(); &#125; &#125; return super.onTouchEvent(event); &#125; /** * 点击动画效果 * * @param shouldRotateUp */ private void animateArrow(boolean shouldRotateUp) &#123; int start = shouldRotateUp ? 0 : MAX_LEVEL; int end = shouldRotateUp ? MAX_LEVEL : 0; ObjectAnimator animator = ObjectAnimator.ofInt(drawable, &quot;level&quot;, start, end); animator.setInterpolator(new LinearOutSlowInInterpolator()); animator.start(); &#125; /** * 隐藏 */ public void dismissDropDown() &#123; if (!isArrowHide) &#123; animateArrow(false); &#125; listView.setVisibility(View.GONE); isShowing = false; &#125; /** * 展开 */ public void showDropDown() &#123; if (!isArrowHide) &#123; animateArrow(true); &#125; listView.setVisibility(View.VISIBLE); isShowing = true; &#125; public void setTintColor(@ColorRes int resId) &#123; if (drawable != null &amp;&amp; !isArrowHide) &#123; DrawableCompat.setTint(drawable, ContextCompat.getColor(getContext(), resId)); &#125; &#125; public void setTitle(int position) &#123; String text = null; lastPos = position; if (adapter.getItem(position) instanceof String) &#123; text = titleText + &quot;&lt;font color=\\&quot;red\\&quot;&gt; &quot; + &quot;(&quot; + adapter.getItem(position).toString() + &quot;)&quot; + &quot;&lt;/font&gt;&quot;; &#125; if (adapter.getItem(position) instanceof FilterDataItem) &#123; FilterDataItem bean = (FilterDataItem) adapter.getItem(position); text = titleText + &quot;&lt;font color=\\&quot;#3b597b\\&quot;&gt; &quot; + &quot;(&quot; + bean.getName() + &quot;)&quot; + &quot;&lt;/font&gt;&quot;; &#125; titleView.setText(Html.fromHtml(text)); &#125; /** * 获取选中的数据源 * * @return */ public FilterDataItem getSelectedData() &#123; if (selectedIndex &gt;= 8) &#123; FilterDataItem item = new FilterDataItem(); item.setName(startDate + &quot;|&quot; + endDate); item.setId(-5); if (TextUtils.isEmpty(startDate) || TextUtils.isEmpty(endDate)) &#123; item.setChecked(false); &#125; else &#123; item.setChecked(true); &#125; return item; &#125; else &#123; return mFilterDataItems.get(selectedIndex); &#125; &#125; @Override public void click(int position) &#123; spinnerClick(position); &#125; /** * 点击方法 * * @param position */ private void spinnerClick(int position) &#123; final FilterDataItem bean = mFilterDataItems.get(position); System.out.println(&quot;点击的位置&quot; + position); if (!bean.isChecked()) &#123; //更改点击状态 bean.setChecked(true); //把最近的已经设为true的变为false if (lastPos != -1) &#123; FilterDataItem item = mFilterDataItems.get(lastPos); item.setChecked(false); &#125; &#125; selectedIndex = position; final int tempPos = position; if (bean.getName().contains(&quot;时间&quot;)) &#123; Calendar c = Calendar.getInstance(); // 直接创建一个DatePickerDialog对话框实例，并将它显示出来 new DatePickerDialog(getContext(), // 绑定监听器 new DatePickerDialog.OnDateSetListener() &#123; @Override public void onDateSet(DatePicker view, int year, int monthOfYear, int dayOfMonth) &#123; if (bean.getName().contains(&quot;开始时间&quot;)) &#123; startDate = year + &quot;.&quot; + (monthOfYear + 1) + &quot;.&quot; + dayOfMonth; bean.setName(&quot;开始时间 &quot; + startDate); &#125; else &#123; endDate = year + &quot;.&quot; + (monthOfYear + 1) + &quot;.&quot; + dayOfMonth; bean.setName(&quot;结束时间 &quot; + endDate); &#125; adapter.notifyDataSetChanged(); setTitle(tempPos); &#125; &#125; // 设置初始日期 , c.get(Calendar.YEAR), c.get(Calendar.MONTH), c .get(Calendar.DAY_OF_MONTH)).show(); &#125; else &#123; postDelayed(new Runnable() &#123; @Override public void run() &#123; dismissDropDown(); &#125; &#125;, 500); adapter.notifyDataSetChanged(); setTitle(position); &#125; &#125; 然后就是在fragment的布局文件中引入它fragment_filter.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/white&quot; android:orientation=&quot;vertical&quot; &gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;@string/filter&quot;/&gt; &lt;TextView android:id=&quot;@+id/tvEnsure&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;10dp&quot; android:background=&quot;@drawable/corner_btn&quot; android:padding=&quot;5dp&quot; android:text=&quot;@string/ensure&quot; android:textColor=&quot;@color/white&quot;/&gt; &lt;/RelativeLayout&gt; &lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.dy.filter.MySpinnerView android:id=&quot;@+id/groupView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:msv_backgroundSelector=&quot;@color/radio_bg&quot; app:msv_isShow=&quot;false&quot; app:msv_title=&quot;对象&quot;/&gt; &lt;com.dy.filter.MySpinnerView android:id=&quot;@+id/exponentView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:msv_backgroundSelector=&quot;@color/radio_bg&quot; app:msv_isShow=&quot;false&quot; app:msv_title=&quot;指数&quot;/&gt; &lt;com.dy.filter.MySpinnerView android:id=&quot;@+id/timeView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:msv_backgroundSelector=&quot;@color/radio_bg&quot; app:msv_isShow=&quot;false&quot; app:msv_title=&quot;查询时间&quot;/&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 最后上activity的布局文件，就是一个drawerlayout12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/blue&quot;&gt; &lt;TextView android:id=&quot;@+id/tvBack&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;10dp&quot; android:text=&quot;返回&quot; android:textColor=&quot;@color/white&quot;/&gt; &lt;TextView android:id=&quot;@+id/tvFilterExponent&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:textColor=&quot;@color/white&quot; tools:text=&quot;订单金额&quot;/&gt; &lt;TextView android:id=&quot;@+id/tvFilter&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_margin=&quot;10dp&quot; android:drawableLeft=&quot;@drawable/ic_action_select&quot; android:gravity=&quot;center&quot; android:text=&quot;筛选&quot; android:textColor=&quot;@color/white&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;!-- 抽屉内容 --&gt; &lt;FrameLayout android:id=&quot;@+id/drawer_content&quot; android:layout_width=&quot;280dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;end&quot; android:clickable=&quot;true&quot; /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 上效果图 123.jpg 最后上demo地址，点击github","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"http://yoursite.com/tags/自定义View/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-04-14T13:23:41.917Z","updated":"2018-04-14T15:58:58.848Z","comments":true,"path":"2018/04/14/hello-world/","link":"","permalink":"http://yoursite.com/2018/04/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}