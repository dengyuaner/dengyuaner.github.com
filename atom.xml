<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>又尔enter的blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-15T12:24:26.302Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>又尔enter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android线程间通信基础——Handler,Looper,MessageQueue</title>
    <link href="http://yoursite.com/2018/04/15/handler/"/>
    <id>http://yoursite.com/2018/04/15/handler/</id>
    <published>2018-04-15T12:13:58.000Z</published>
    <updated>2018-04-15T12:24:26.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android单线程模型"><a href="#Android单线程模型" class="headerlink" title="Android单线程模型"></a>Android单线程模型</h2><p>&emsp;&emsp;我们知道进程是cpu<strong>资源分配的最小单位</strong>，线程是cpu<strong>调度的最小单位</strong>。早期的操作系统里进程既是资源分配也是调度的最小单位，后来随着cpu速度越来越快，为了更合理的使用cpu，减少进程切换的开销，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。<br>&emsp;&emsp;当我们第一次打开一个App时，系统就会给这个App分配一个进程，并且启动一个main thread线程，主线程主要负责处理与UI相关的事件，如：用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以主线程通常又被叫做UI线程。<br>&emsp;&emsp;在开发Android 应用时必须遵守单线程模型的原则： Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>&emsp;&emsp;既然UI操作只能在UI线程里更新，那么可不可以把所有操作都放在UI线程里面呢？答案是不可能的，可能会导致ANR。所以一些常用的耗时操作只能在非UI线程里执行，比如网络，数据库，IO操作等。那在非UI线程执行完后我们想把处理结果通知给UI线程怎么办，这就涉及到线程间通信的问题。<br>&emsp;&emsp;传统的Java线程间通信包括volatile，synchronized，CountDownLatch等不适合于Android，因为AndroidUI线程是消息驱动模式，主线程在启动时会初始化一个Looper，并调用loop()方法开启死循环，在循环里执行处理消息的操作。</p><h3 id="大致流程图如下："><a href="#大致流程图如下：" class="headerlink" title="大致流程图如下："></a>大致流程图如下：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-e0bba3dad40a7508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="handler.png" title="">                </div>                <div class="image-caption">handler.png</div>            </figure><h2 id="流程讲解"><a href="#流程讲解" class="headerlink" title="流程讲解"></a>流程讲解</h2><p>&emsp;&emsp;接下来我们以handler的创建为起始点，结合源码开始讲解。</p><h3 id="hander创建（UI线程中）"><a href="#hander创建（UI线程中）" class="headerlink" title="hander创建（UI线程中）"></a>hander创建（UI线程中）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler = new Handler();</span><br></pre></td></tr></table></figure><p>查看构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">        this(null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以传入两个参数，一个为callback，他是Handler的内部接口，里面只有一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback &#123;</span><br><span class="line">        /**</span><br><span class="line">         * @param msg A &#123;@link android.os.Message Message&#125; object</span><br><span class="line">         * @return True if no further handling is desired</span><br><span class="line">         */</span><br><span class="line">        public boolean handleMessage(Message msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是我们初始化Handler的时候可以传入一个Callback，之后Looper会回调这个Callback。<br>另一个参数表示是否是异步消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Handler.java</span><br><span class="line"></span><br><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        if (mLooper == null) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看见这里面会获取Looper，如果Looper为空，则会报错；由于Handler实在主线程里面创建的，默认用的是主线程的Looper，而主线程的Looper实在ActivityThread的main方法中创建的。所以如果在其他线程创建Handler必须显示的创建Looper。</p><p>&emsp;&emsp;我们进入Looper.myLooper()方法里面看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Handler.java</span><br><span class="line"></span><br><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">/**</span><br><span class="line">     * Return the Looper object associated with the current thread.  Returns</span><br><span class="line">     * null if the calling thread is not associated with a Looper.</span><br><span class="line">     */</span><br><span class="line">    public static @Nullable Looper myLooper() &#123;</span><br><span class="line">        return sThreadLocal.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;ThreadLocal是一个类似于HashMap的数据结构，它主要是用于保存线程的局部变量，ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。<br>&emsp;&emsp;也就是myLooper()会获取当前线程的Looper，那么主线程的Looper实在哪创建的呢？答案是在ActivityThread中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.java</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ...</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Looper.java</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Initialize the current thread as a looper, marking it as an</span><br><span class="line">     * application&apos;s main looper. The main looper for your application</span><br><span class="line">     * is created by the Android environment, so you should never need</span><br><span class="line">     * to call this function yourself.  See also: &#123;@link #prepare()&#125;</span><br><span class="line">     */</span><br><span class="line">    public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>调用prepare方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        if (sThreadLocal.get() != null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>所以就是在这创建完Looper的，并且创建想赢的MessageQueue，然后把Looper保存到ThreadLocal中</strong><br><strong>结论：一个线程对应一个Looper对应一个MessageQueue</strong></p><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>&emsp;&emsp; Handler创建完毕后，我们就可以发送消息了，发送消息有几种方式，如post(),sendMessage();最终都会调用handler的sendMessageAtTime()方法(post 的Runnnale也会包装成Message)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            RuntimeException e = new RuntimeException(</span><br><span class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">mQueue就是在创建Handler时赋值的，它会调用MessageQueue的enqueueMessage方法</span><br></pre></td></tr></table></figure><p>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {<br>        msg.target = this;<br>        if (mAsynchronous) {<br>            msg.setAsynchronous(true);<br>        }<br>        return queue.enqueueMessage(msg, uptimeMillis);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里要注意的是把msg.target指向了自己，这是为了Looper处理完消息后回调自己的相关方法。</span><br><span class="line">接下来进入MessageQueue里面</span><br></pre></td></tr></table></figure></p><p>boolean enqueueMessage(Message msg, long when) {<br>        …<br>        //防止多个子线程同时发送消息，导致不可预知的错误<br>        synchronized (this) {<br>             …<br>            msg.markInUse();<br>            msg.when = when;<br>            Message p = mMessages;<br>            boolean needWake;<br>            if (p == null || when == 0 || when &lt; p.when) {<br>                // New head, wake up the event queue if blocked.<br>                msg.next = p;<br>                mMessages = msg;<br>                needWake = mBlocked;<br>            } else {<br>                // Inserted within the middle of the queue.  Usually we don’t have to wake<br>                // up the event queue unless there is a barrier at the head of the queue<br>                // and the message is the earliest asynchronous message in the queue.<br>                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();<br>                Message prev;<br>                for (;;) {<br>                    prev = p;<br>                    p = p.next;<br>                    if (p == null || when &lt; p.when) {<br>                        break;<br>                    }<br>                    if (needWake &amp;&amp; p.isAsynchronous()) {<br>                        needWake = false;<br>                    }<br>                }<br>                msg.next = p; // invariant: p == prev.next<br>                prev.next = msg;<br>            }</p><pre><code>    // We can assume mPtr != 0 because mQuitting is false.    if (needWake) {        nativeWake(mPtr);    }    ....}....</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;mMessages是当前Looper正在处理的消息，即消息队列的队头，赋值的地方是在next()方法里面；即如果当前队头的消息为空或者待入队的消息延时为0或者待入队的消息的延时小于队头的延时，则把待入队的消息插入到队的头部；</span><br><span class="line">&amp;emsp;&amp;emsp;**这可以看出MessageQueue是一个按when顺序排列的优先级队列，队头的when是最小**；</span><br><span class="line">&amp;emsp;&amp;emsp;**同时加入之前是延迟消息，会阻塞当前队列，所以还需要唤醒**</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;else里面会开启for循环，这个循环的目的是插入消息到链表的中间：如果插入消息到链表头部的条件不具备，**则依次循环消息链表比较触发时间的长短**，然后将消息插入到消息链表的合适位置。接着如果需要唤醒线程处理则调用C++中的nativeWake()函数。 </span><br><span class="line"></span><br><span class="line">**这样handler插入消息的流程就完毕了**</span><br><span class="line"></span><br><span class="line">## Looper消息循环</span><br><span class="line">&amp;emsp;&amp;emsp;当消息队列中有消息的时候，Looper就会去取出消息并执行，具体在Looper的loop()方法中。</span><br></pre></td></tr></table></figure></p><p>public static void loop() {<br>        final Looper me = myLooper();<br>        if (me == null) {<br>            throw new RuntimeException(“No Looper; Looper.prepare() wasn’t called on this thread.”);<br>        }<br>        final MessageQueue queue = me.mQueue;<br>        …<br>        for (;;) {<br>            Message msg = queue.next(); // might block<br>            if (msg == null) {<br>                // No message indicates that the message queue is quitting.<br>                return;<br>            }</p><pre><code>    ...    try {        msg.target.dispatchMessage(msg);        end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();    } finally {        if (traceTag != 0) {            Trace.traceEnd(traceTag);        }    }    ...    msg.recycleUnchecked();}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;这里面主要就是从MessageQueue中取出Message执行，即调用queue.next()，然后handler的dispatchMessage()方法，前面提到过msg.target执行的就是我们的handler。然后回收message，可以复用；这也是为什么建议用Message.obtain()来生成message的原因。</span><br><span class="line">&amp;emsp;&amp;emsp;接下来看MessageQueue的next方法</span><br></pre></td></tr></table></figure></p><p>Message next() {<br>        …<br>        for (;;) {<br>               …<br>              nativePollOnce(ptr, nextPollTimeoutMillis);<br>              synchronized (this) {<br>                // Try to retrieve the next message.  Return if found.<br>                final long now = SystemClock.uptimeMillis();<br>                Message prevMsg = null;<br>                Message msg = mMessages;<br>                if (msg != null &amp;&amp; msg.target == null) {<br>                    // Stalled by a barrier.  Find the next asynchronous message in the queue.<br>                    do {<br>                        prevMsg = msg;<br>                        msg = msg.next;<br>                    } while (msg != null &amp;&amp; !msg.isAsynchronous());<br>                }<br>                if (msg != null) {<br>                    if (now &lt; msg.when) {<br>                        // Next message is not ready.  Set a timeout to wake up when it is ready.<br>                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                    } else {<br>                        // Got a message.<br>                        mBlocked = false;<br>                        if (prevMsg != null) {<br>                            prevMsg.next = msg.next;<br>                        } else {<br>                            mMessages = msg.next;<br>                        }<br>                        msg.next = null;<br>                        if (DEBUG) Log.v(TAG, “Returning message: “ + msg);<br>                        msg.markInUse();<br>                        return msg;<br>                    }<br>                } else {<br>                    // No more messages.<br>                    nextPollTimeoutMillis = -1;<br>                }</p><pre><code>        // Process the quit message now that all pending messages have been handled.        if (mQuitting) {            dispose();            return null;        }        // If first time idle, then get the number of idlers to run.        // Idle handles only run if the queue is empty or if the first message        // in the queue (possibly a barrier) is due to be handled in the future.        if (pendingIdleHandlerCount &lt; 0                &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {            pendingIdleHandlerCount = mIdleHandlers.size();        }        if (pendingIdleHandlerCount &lt;= 0) {            // No idle handlers to run.  Loop and wait some more.            mBlocked = true;            continue;        }        if (mPendingIdleHandlers == null) {            mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];        }        mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);    }}...</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;nativePollOnce(ptr, nextPollTimeoutMillis);是一个native方法，它的作用是在native层阻塞，对用nativeWake()唤醒，接下通过do while循环在MessageQueue中找message，如果Handler传入了async参数为true，这里的msg.isAsynchronous()为true，循环退出，即找出第一个不为空的同步message或者异步message；</span><br><span class="line">&amp;emsp;&amp;emsp;找到后会计算该message的执行时间是不是现在这个时间点，如果还没到它该执行的时间点，则计算剩余的时间 nextPollTimeoutMillis，否则的话该message就是我们要找的message，然后取出该message，并改变链表的指针。</span><br><span class="line">&amp;emsp;&amp;emsp;**值得一提的是MessageQueue有个有趣的接口IdleHandler**，看名字就知道它是个空的handler，当MessageQueue中没有消息的时候，如果有IdleHandler，则会调用queueIdle()方法，关于它的用法之后我们会讲到。</span><br><span class="line">## Message走了一圈又回到了Handler</span><br><span class="line">**Message从子线程走到了主线程，走了一圈又回到了Handler**</span><br></pre></td></tr></table></figure></p><p>/**</p><pre><code> * Handle system messages here. */public void dispatchMessage(Message msg) {    if (msg.callback != null) {        handleCallback(msg);    } else {        if (mCallback != null) {            if (mCallback.handleMessage(msg)) {                return;            }        }        handleMessage(msg);    }}</code></pre><p><code>`</code></p><p>&emsp;&emsp;如果Message设置了回调方法的话，则回调该方法，这个是当我们调用handler.post(Runnable able)时设置的，即这个callback就是runnable，他会调用用runnable的run方法；<br>&emsp;&emsp;如果Message没设置回调，并且handler设置了callback，这个callback是在构造方法里面设置的，之前讲到过，然后回调callback的handleMessage()；<br>&emsp;&emsp;如果前两步都没设置回调，则会调用自身的handleMessage(msg)方法，这个就是我们熟悉的，经常复写的方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;终上所述，一个message从子线程走到了主线程，这其中都是Handler的功劳，handler负责发送消息入队，然后处理消息，这样完成了一个操作从子线程到主线程的切换，其本质就是把一个操作从子线程传递给主线程。关于子线程更新UI的相关有趣操作我们会在另外的文章里讲。<br>&emsp;&emsp;<strong>Tips1</strong>: handler在哪个线程创建，持有的就是哪个线程的Looper，MessageQueue。当然你也可以在构造函数中显示的指定哪个线程的Looper。比如主线程创建的默认是主线程的mainLooper。<br>&emsp;&emsp;<strong>Tips2</strong>: 子线程创建Handler，由于子线程没有自己的Looper，所以必须显示调用Looper.prepare()创建Looper，并且显示的调用Looper.loop()方法开启消息循环。<br>&emsp;&emsp;<strong>Tips3</strong>: handler的底层用的是Linux的管道通信，至于原因，我们之后再讲；</p><h2 id="Message流向图"><a href="#Message流向图" class="headerlink" title="Message流向图"></a>Message流向图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-f58dac345c81044e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message.png" title="">                </div>                <div class="image-caption">message.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android单线程模型&quot;&gt;&lt;a href=&quot;#Android单线程模型&quot; class=&quot;headerlink&quot; title=&quot;Android单线程模型&quot;&gt;&lt;/a&gt;Android单线程模型&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;我们知道进程是cpu&lt;strong&gt;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Handler" scheme="http://yoursite.com/tags/Handler/"/>
    
      <category term="MessageQueue" scheme="http://yoursite.com/tags/MessageQueue/"/>
    
      <category term="Message" scheme="http://yoursite.com/tags/Message/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（五）——使用ffmpeg播放音频</title>
    <link href="http://yoursite.com/2018/04/15/audio5/"/>
    <id>http://yoursite.com/2018/04/15/audio5/</id>
    <published>2018-04-15T06:28:44.000Z</published>
    <updated>2018-04-15T06:32:01.223Z</updated>
    
    <content type="html"><![CDATA[<p>上一节，我们做了很多准备工作，把ffmpeg源码编译成so供我们使用，这下我们终于可以来真正的使用它了。请大家使用最新版本你的AS，使用cmake，抛弃以前的mk。</p><h2 id="首先，创建一个新的project，记得勾上Include-C-support，然后一路next就ok了。"><a href="#首先，创建一个新的project，记得勾上Include-C-support，然后一路next就ok了。" class="headerlink" title="首先，创建一个新的project，记得勾上Include C++ support，然后一路next就ok了。"></a>首先，创建一个新的project，记得勾上Include C++ support，然后一路next就ok了。</h2><p>我们发现main下面多了一个cpp文件夹，这就是你放c/c++源代码的地方，为了用到我们的ffmpeg so文件，我们在main下面创建jniLibs,把编好的lib里面的so放进去。<br>PS：之前我们编译的平台是armeabi，如果你想要x86可修改脚本文件中相关配置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-b3d339e13cae94ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="111.jpg" title="">                </div>                <div class="image-caption">111.jpg</div>            </figure><p>其中main，sdl不是ffmpeg编译的so，大家不必在意。然后把include放进cpp文件夹，这些是需要的头文件，</p><h2 id="然后在cpp目录下创建play-audio-cpp"><a href="#然后在cpp目录下创建play-audio-cpp" class="headerlink" title="然后在cpp目录下创建play_audio.cpp"></a>然后在cpp目录下创建play_audio.cpp</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-465e48a05eb76058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a3.png" title="">                </div>                <div class="image-caption">a3.png</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &quot;log.h&quot;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#include &quot;AudioDevice.h&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注意加extern &quot;C&quot;，否则将按照C++的编译方法吧方法名改了，则java层找不到相应的方法</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_com_dy_ffmpeg_PlayMusicActivity_play(JNIEnv *env, jobject instance, jstring url_) &#123;</span><br><span class="line">    const char *url = env-&gt;GetStringUTFChars(url_, 0);</span><br><span class="line"></span><br><span class="line">    LOGD(&quot;play&quot;);</span><br><span class="line">    int code = play(url);</span><br><span class="line">    return code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_com_dy_ffmpeg_PlayMusicActivity_stop(JNIEnv *env, jobject instance) &#123;</span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line">    LOGD(&quot;stop&quot;);</span><br><span class="line">    int code = shutdown();</span><br><span class="line">    return code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下面贴出关键代码"><a href="#下面贴出关键代码" class="headerlink" title="下面贴出关键代码"></a>下面贴出关键代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 初始化操作，创建解码器</span><br><span class="line"> * @param file_name  文件名</span><br><span class="line"> * @param rate 采样率</span><br><span class="line"> * @param channel 通道数</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">int init(const char *file_name, int *rate, int *channel) &#123;</span><br><span class="line"></span><br><span class="line">    //初始化</span><br><span class="line">    av_register_all();</span><br><span class="line">    aFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //读取输入的音频文件地址</span><br><span class="line">    if (avformat_open_input(&amp;aFormatCtx, file_name, NULL, NULL) != 0) &#123;</span><br><span class="line">        LOGE(&quot;文件%s不存在！\n&quot;, file_name);</span><br><span class="line">        return -1; // Couldn&apos;t open file</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找文件的流信息</span><br><span class="line">    if (avformat_find_stream_info(aFormatCtx, NULL) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;文件流信息错误\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找到第一个音频帧</span><br><span class="line">    int i;</span><br><span class="line">    audioStream = -1;</span><br><span class="line">    for (i = 0; i &lt; aFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        if (aFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            audioStream = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (audioStream == -1) &#123;</span><br><span class="line">        LOGE(&quot;音频流未找到!&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    aCodecCtx = aFormatCtx-&gt;streams[audioStream]-&gt;codec;</span><br><span class="line"></span><br><span class="line">    //获取相应音频流的解码器</span><br><span class="line">    AVCodec *aCodec = avcodec_find_decoder(aCodecCtx-&gt;codec_id);</span><br><span class="line">    if (!aCodec) &#123;</span><br><span class="line">        fprintf(stderr, &quot;不支持的音频格式!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (avcodec_open2(aCodecCtx, aCodec, NULL) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;无法打开解码器！\n&quot;);</span><br><span class="line">        return -1; // Could not open codec</span><br><span class="line">    &#125;</span><br><span class="line">    //分配一个帧指针，指向解码后的原始帧</span><br><span class="line">    aFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    // 设置格式转换</span><br><span class="line">    swr = swr_alloc();</span><br><span class="line">    //输入通道数</span><br><span class="line">    av_opt_set_int(swr, &quot;in_channel_layout&quot;, aCodecCtx-&gt;channel_layout, 0);</span><br><span class="line">    //输出通道数</span><br><span class="line">    av_opt_set_int(swr, &quot;out_channel_layout&quot;, aCodecCtx-&gt;channel_layout, 0);</span><br><span class="line">    //输入采样率</span><br><span class="line">    av_opt_set_int(swr, &quot;in_sample_rate&quot;, aCodecCtx-&gt;sample_rate, 0);</span><br><span class="line">    //输出采样率</span><br><span class="line">    av_opt_set_int(swr, &quot;out_sample_rate&quot;, aCodecCtx-&gt;sample_rate, 0);</span><br><span class="line">    //输入采样位宽</span><br><span class="line">    av_opt_set_sample_fmt(swr, &quot;in_sample_fmt&quot;, aCodecCtx-&gt;sample_fmt, 0);</span><br><span class="line">    //输出采样位宽，16bit</span><br><span class="line">    av_opt_set_sample_fmt(swr, &quot;out_sample_fmt&quot;, AV_SAMPLE_FMT_S16, 0);</span><br><span class="line">    swr_init(swr);</span><br><span class="line"></span><br><span class="line">    // 分配PCM数据缓冲区大小</span><br><span class="line">    outputBufferSize = 8196;</span><br><span class="line">    outputBuffer = (uint8_t *) malloc(sizeof(uint8_t) * outputBufferSize);</span><br><span class="line"></span><br><span class="line">    // 返回采样率和通道数</span><br><span class="line">    *rate = aCodecCtx-&gt;sample_rate;</span><br><span class="line">    *channel = aCodecCtx-&gt;channels;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 获取PCM数据, 自动回调获取</span><br><span class="line">int getPCM(void **pcm, size_t *pcmSize) &#123;</span><br><span class="line">    LOGD(&quot;getPcm&quot;);</span><br><span class="line">    while (av_read_frame(aFormatCtx, &amp;packet) &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">        int frameFinished = 0;</span><br><span class="line">        // Is this a packet from the audio stream?</span><br><span class="line">        if (packet.stream_index == audioStream) &#123;</span><br><span class="line">            avcodec_decode_audio4(aCodecCtx, aFrame, &amp;frameFinished, &amp;packet);</span><br><span class="line"></span><br><span class="line">            if (frameFinished) &#123;</span><br><span class="line">                // data_size为音频数据所占的字节数</span><br><span class="line">                int data_size = av_samples_get_buffer_size(</span><br><span class="line">                        aFrame-&gt;linesize, aCodecCtx-&gt;channels,</span><br><span class="line">                        aFrame-&gt;nb_samples, aCodecCtx-&gt;sample_fmt, 1);</span><br><span class="line"></span><br><span class="line">                // 这里内存再分配可能存在问题</span><br><span class="line">                if (data_size &gt; outputBufferSize) &#123;</span><br><span class="line">                    outputBufferSize = data_size;</span><br><span class="line">                    outputBuffer = (uint8_t *) realloc(outputBuffer,</span><br><span class="line">                                                       sizeof(uint8_t) * outputBufferSize);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 音频格式转换</span><br><span class="line">                swr_convert(swr, &amp;outputBuffer, aFrame-&gt;nb_samples,</span><br><span class="line">                            (uint8_t const **) (aFrame-&gt;extended_data),</span><br><span class="line">                            aFrame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                // 返回pcm数据</span><br><span class="line">                *pcm = outputBuffer;</span><br><span class="line">                *pcmSize = data_size;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="然后是activity"><a href="#然后是activity" class="headerlink" title="然后是activity"></a>然后是activity</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package com.dy.ffmpeg;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.Button;</span><br><span class="line"></span><br><span class="line">public class PlayMusicActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;play_audio&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Button play;</span><br><span class="line">    private Button stop;</span><br><span class="line">    private String url;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_play_music);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        play = (Button) findViewById(R.id.play);</span><br><span class="line">        stop = (Button) findViewById(R.id.stop);</span><br><span class="line"></span><br><span class="line">        play.setOnClickListener(this);</span><br><span class="line">        stop.setOnClickListener(this);</span><br><span class="line">        //获取文件地址,注意把音频文件放在该目录下，或者修改成你自己需要的路径</span><br><span class="line">        String folderurl = Environment.getExternalStorageDirectory().getPath();</span><br><span class="line">        url = folderurl + &quot;/Valentine.mp3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        switch (v.getId()) &#123;</span><br><span class="line">            case R.id.play:</span><br><span class="line">                new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        int code = play(url);</span><br><span class="line">                        System.out.println(&quot;开始播放&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">            case R.id.stop:</span><br><span class="line">                new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        int code = stop();</span><br><span class="line">                        if (code == 0) &#123;</span><br><span class="line">                            System.out.println(&quot;停止成功&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private native int play(String url);</span><br><span class="line"></span><br><span class="line">    private native int stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接下来就是最重要的编写cmake"><a href="#接下来就是最重要的编写cmake" class="headerlink" title="接下来就是最重要的编写cmake"></a>接下来就是最重要的编写cmake</h2><p>接下来就是最重要的编写cmake</p><p>接下来就是最重要的编写cmake</p><p>上面我们做了这么多工作，gradle编译的时候怎么知道去哪找这些东西呢，就是重要的app目录下得CMakeLists.txt文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line">#设置so目录</span><br><span class="line">set(lib_src_DIR $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;)</span><br><span class="line">#添加头文件查找路径，包括引入库的和自己写的</span><br><span class="line">include_directories(</span><br><span class="line">     $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/include</span><br><span class="line">)</span><br><span class="line">#添加动态库或静态库，其中本地的动态库名称,位置可以由set_target_properties设置</span><br><span class="line">add_library(avcodec-57_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(avcodec-57_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                          $&#123;lib_src_DIR&#125;/libavcodec-57.so)</span><br><span class="line"></span><br><span class="line">add_library(avformat-57_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(avformat-57_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                     $&#123;lib_src_DIR&#125;/libavformat-57.so)</span><br><span class="line"></span><br><span class="line">add_library(avutil-55_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(avutil-55_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                     $&#123;lib_src_DIR&#125;/libavutil-55.so)</span><br><span class="line"></span><br><span class="line">add_library(swresample-2_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(swresample-2_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                     $&#123;lib_src_DIR&#125;/libswresample-2.so)</span><br><span class="line"></span><br><span class="line">add_library(swscale-4_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(swscale-4_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                     $&#123;lib_src_DIR&#125;/libswscale-4.so)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># build application&apos;s shared lib</span><br><span class="line">#这里是你自己编写的c/c++，因为用到ffmpeg的so，所以下面要链接它的库</span><br><span class="line">add_library(play_video SHARED</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/play_video.cpp)</span><br><span class="line">add_library(decode_video SHARED</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/decode_video.cpp)</span><br><span class="line">add_library(play_audio SHARED</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/play_audio.cpp</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/AudioDevice.c</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/FFmpegAudioPlay.c)</span><br><span class="line">#通过名称查找并引入库，可以引入 NDK 中的库，比如日志模块</span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              log )</span><br><span class="line">#添加参加编译的库名称，也可以是绝对路径，注意被依赖的模块写在后面</span><br><span class="line">#特别注意，你想生成几个so，就要写几个link，写在一个link里面是错误的</span><br><span class="line">target_link_libraries(play_video</span><br><span class="line">log</span><br><span class="line">android</span><br><span class="line">avcodec-57_lib</span><br><span class="line">avformat-57_lib</span><br><span class="line">avutil-55_lib</span><br><span class="line">swresample-2_lib</span><br><span class="line">swscale-4_lib</span><br><span class="line">)</span><br><span class="line">target_link_libraries(decode_video</span><br><span class="line">log</span><br><span class="line">android</span><br><span class="line">avcodec-57_lib</span><br><span class="line">avformat-57_lib</span><br><span class="line">avutil-55_lib</span><br><span class="line">swresample-2_lib</span><br><span class="line">swscale-4_lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#我们需要opensl es来辅助播放，注意加入opensl es</span><br><span class="line">target_link_libraries(play_audio</span><br><span class="line">log</span><br><span class="line">OpenSLES</span><br><span class="line">android</span><br><span class="line">avcodec-57_lib</span><br><span class="line">avformat-57_lib</span><br><span class="line">avutil-55_lib</span><br><span class="line">swresample-2_lib</span><br><span class="line">swscale-4_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="然后编译执行，done，完整demo请移步我的github"><a href="#然后编译执行，done，完整demo请移步我的github" class="headerlink" title="然后编译执行，done，完整demo请移步我的github"></a>然后编译执行，done，完整demo请移步<a href="https://github.com/dengyuaner/ffmpegDemo" target="_blank" rel="noopener">我的github</a></h3><p>参考<a href="http://blog.csdn.net/leixiaohua1020/article/details/47008825" target="_blank" rel="noopener">http://blog.csdn.net/leixiaohua1020/article/details/47008825</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节，我们做了很多准备工作，把ffmpeg源码编译成so供我们使用，这下我们终于可以来真正的使用它了。请大家使用最新版本你的AS，使用cmake，抛弃以前的mk。&lt;/p&gt;
&lt;h2 id=&quot;首先，创建一个新的project，记得勾上Include-C-support，然后一
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="NDK" scheme="http://yoursite.com/categories/Android/NDK/"/>
    
      <category term="ffmpeg" scheme="http://yoursite.com/categories/Android/NDK/ffmpeg/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
      <category term="ffmpeg" scheme="http://yoursite.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（四）——ffmpeg的编译</title>
    <link href="http://yoursite.com/2018/04/15/audio4/"/>
    <id>http://yoursite.com/2018/04/15/audio4/</id>
    <published>2018-04-15T06:25:28.000Z</published>
    <updated>2018-04-15T06:29:16.861Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前几节我们讲的都是调用android原生API来进行音频的播放，编解码等操作，是在java层面，而且由于<a href="https://developer.android.google.cn/reference/android/media/MediaCodec.html" target="_blank" rel="noopener">MediaCodec</a>兼容性的限制，导致无法在API16以下使用，所以我们不得不放弃java层，转而寻求更为成熟的c/c++处理方案，再用jni去调用。所以，大名鼎鼎的<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">ffmpeg</a>闪亮登场了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-4291bd7ba1434eb0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a1.jpg" title="">                </div>                <div class="image-caption">a1.jpg</div>            </figure><p>&emsp;&emsp;那么问题来了，怎么使用这个玩意儿了？接下来跟着我走</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-32f0ef86ceebe8c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a2.jpg" title="">                </div>                <div class="image-caption">a2.jpg</div>            </figure><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>&emsp;&emsp;去官网下载源码<a href="http://ffmpeg.org/download.html，最新版本是3.3.3，下载完成后我们在linux下把源码编译成android能用的so文件，当然你也可以直接打开cmd命令去使用它，熟悉它的一些命令。" target="_blank" rel="noopener">http://ffmpeg.org/download.html，最新版本是3.3.3，下载完成后我们在linux下把源码编译成android能用的so文件，当然你也可以直接打开cmd命令去使用它，熟悉它的一些命令。</a></p><p>&emsp;&emsp;我这里用的是VirtualBox+Ubuntu的方式去编译，为了方便，我这里专门设置了共享文件夹方便windows和ubuntu传输文件。共享文件夹的设置大家请百度吧。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-e223d9e6b4d714b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a3.jpg" title="">                </div>                <div class="image-caption">a3.jpg</div>            </figure></p><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>首先要安装NDK，下载好NDK后解压在用户根目录，并配置好环境变量</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-dcfddc9f4eee7857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a3.png" title="">                </div>                <div class="image-caption">a3.png</div>            </figure><p>输入gedit ~/.bashrc,加入以下代码<br>export NDK_HOME=/home/dy/android-ndk-r14b<br>注意换成你自己的路径，保存然后输入source ~/.bashrc编译一下即可</p><p>你可以<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>一下有没有安装成功：$ cd $NDK_ROOT$ ./ndk-build NDK_PROJECT_PATH=$NDK_ROOT/samples/two-libs</p><p>在根目录下新建一个工程media，用于存放ffmpeg，和编译脚本，把你下载的ffmpeg源码放进来。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-511d4ec3dbfdad11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a4.png" title="">                </div>                <div class="image-caption">a4.png</div>            </figure><p>然后找到ffmpeg文件夹下得configure文件，替换其中的几行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;</span><br><span class="line">LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</span><br><span class="line">SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;</span><br><span class="line">SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;</span><br><span class="line">将其修改成：</span><br><span class="line">SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;</span><br><span class="line">LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</span><br><span class="line">SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;</span><br><span class="line">SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;为什么要这么做呢，这是因为如果直接按照未修改的配置进行编译，结果编译出来的so文件类似libavcodec.so.55.39.101，版本号位于so之后，Android无法加载</p><h2 id="接下来在ffmpeg目录下新建脚本文件buildff-sh，文件内容如下"><a href="#接下来在ffmpeg目录下新建脚本文件buildff-sh，文件内容如下" class="headerlink" title="接下来在ffmpeg目录下新建脚本文件buildff.sh，文件内容如下"></a>接下来在ffmpeg目录下新建脚本文件buildff.sh，文件内容如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#清除上次编译的东西</span><br><span class="line">make clean</span><br><span class="line">#配置NDK路径,注意换成你自己的路径</span><br><span class="line">export NDK=/home/dy/android-ndk-r14b</span><br><span class="line">#配置工具链，注意查看是否有该路径，各个ndk版本不同，路径会有不同</span><br><span class="line">export PREBUILT=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt</span><br><span class="line">#配置平台，同上注意路径</span><br><span class="line">export PLATFORM=$NDK/platforms/android-9/arch-arm</span><br><span class="line">#配置编译好了之后的文件输出目录，$(pwd)当前目录下</span><br><span class="line">export PREFIX=$(pwd)/android/</span><br><span class="line">build_one()&#123;</span><br><span class="line">  ./configure --target-os=linux --prefix=$PREFIX \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--enable-runtime-cpudetect \</span><br><span class="line">--disable-asm \</span><br><span class="line">--arch=arm \</span><br><span class="line">--cc=$PREBUILT/linux-x86_64/bin/arm-linux-androideabi-gcc \</span><br><span class="line">--cross-prefix=$PREBUILT/linux-x86_64/bin/arm-linux-androideabi- \</span><br><span class="line">--disable-stripping \</span><br><span class="line">--nm=$PREBUILT/linux-x86_64/bin/arm-linux-androideabi-nm \</span><br><span class="line">--sysroot=$PLATFORM \</span><br><span class="line">--enable-gpl --enable-shared --disable-static --enable-nonfree --enable-version3 --enable-small \</span><br><span class="line">--enable-zlib --disable-ffprobe --disable-ffplay --disable-ffmpeg --disable-ffserver --disable-debug \</span><br><span class="line">--extra-cflags=&quot;-fPIC -DANDROID -D__thumb__ -mthumb -Wfatal-errors -Wno-deprecated -mfloat-abi=softfp -marm -march=armv7-a&quot; </span><br><span class="line">&#125;</span><br><span class="line">build_one</span><br><span class="line"></span><br><span class="line">#4线程编译</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>然后输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 ./buildff.sh</span><br><span class="line"> ./build_android.sh</span><br></pre></td></tr></table></figure></p><p>就开始编译了</p><p>编译完成后会在ffmpeg下生成android文件夹，里面就是include源文件和编译好的so文件，然后通过共享文件夹把android文件夹传给windows，供我们使用即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-0575ff4443906d56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a5.png" title="">                </div>                <div class="image-caption">a5.png</div>            </figure><p>最后上个妹子图缓解一下视力，接下来就是在AS里面运用了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-eb9dd8820032b5cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6VD[D]L1MLP{EEZX8S498DG.png" title="">                </div>                <div class="image-caption">6VD[D]L1MLP{EEZX8S498DG.png</div>            </figure><p><a href="https://www.dyenter.top/2018/04/15/audio5/" target="_blank" rel="noopener">下一篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;前几节我们讲的都是调用android原生API来进行音频的播放，编解码等操作，是在java层面，而且由于&lt;a href=&quot;https://developer.android.google.cn/reference/android/media/Medi
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="NDK" scheme="http://yoursite.com/categories/Android/NDK/"/>
    
      <category term="ffmpeg" scheme="http://yoursite.com/categories/Android/NDK/ffmpeg/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
      <category term="ffmpeg" scheme="http://yoursite.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（三）——音频编解码</title>
    <link href="http://yoursite.com/2018/04/15/audio3/"/>
    <id>http://yoursite.com/2018/04/15/audio3/</id>
    <published>2018-04-15T06:21:30.000Z</published>
    <updated>2018-04-15T06:25:17.222Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一节中我们讲了怎么采集音频并播放，由于AudioRecord采集的是PCM数据，没有经过处理，所有播放的时候会有杂音，啸叫等现象出现。因此处理掉这些不需要的数据就是本节的内容，编码与解码。</p><h2 id="原理知识"><a href="#原理知识" class="headerlink" title="原理知识"></a>原理知识</h2><p>&emsp;&emsp;Android官方提供给我们的用于编解码的类是<a href="https://developer.android.google.cn/reference/android/media/MediaCodec.html" target="_blank" rel="noopener">MediaCodec</a>,它是android 4.1（API 16）才引入的，所以只能工作于andorid4.1以上的手机，如果想兼容4.1以下版本的手机，只能使用第三方库，如大名鼎鼎的<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">ffmpeg</a>,B站的<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">ijkplayer</a>等。</p><h3 id="MediaCodec介绍"><a href="#MediaCodec介绍" class="headerlink" title="MediaCodec介绍"></a>MediaCodec介绍</h3><p>（1）提供了一套访问 Android 底层多媒体模块的接口，主要是音视频的编解码接口</p><p>（2）在Android上，预设的多媒体框架是基于第三方PacketVideo公司的OpenCORE来实现，OpenCORE的优点是兼顾了跨平台的移植性，而且已经过多方验证，所以相对来说较为稳定；缺点是国语庞大复杂，需要耗费相当多的时间去维护。因此从Android 2.0开始，Google引进了较为简洁的StageFright。Android 底层多媒体模块采用的是 StageFright 框架，它是基于OpenMax标准实现的，任何 Android 底层编解码模块的实现，都必须遵循 OpenMax 标准。值得一提的是，OpenMAX是Khronos制定的API，Khronos也是OpenGL的制定者。Google 官方默认提供了一系列的软件编解码器：包括：OMX.google.h264.encoder，OMX.google.h264.encoder， OMX.google.aac.encoder， OMX.google.aac.decoder 等等，而硬件编解码功能，则需要由芯片厂商依照 OpenMax 框架标准来完成，所以，一般采用不同芯片型号的手机，硬件编解码的实现和性能是不同的</p><p>（3）Android 应用层统一由 MediaCodec API 来提供各种音视频编解码功能，由参数配置来决定采用何种编解码算法、是否采用硬件编解码加速等等</p><h3 id="MediaCodec原理"><a href="#MediaCodec原理" class="headerlink" title="MediaCodec原理"></a>MediaCodec原理</h3><p><img src="http://upload-images.jianshu.io/upload_images/3287039-c2a7d9ad88655df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6b5f1f9ee2d1075465f27078176e4e08_b.png"></p><p>根据android官方文档的描述，MediaCodec的核心就是使用缓冲区队列来操作数据，使用流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- createEncoderByType/createDecoderByType</span><br><span class="line">- configure</span><br><span class="line">- start</span><br><span class="line">- while(1) &#123;</span><br><span class="line">    - dequeueInputBuffer</span><br><span class="line">    - queueInputBuffer</span><br><span class="line">    - dequeueOutputBuffer</span><br><span class="line">    - releaseOutputBuffer</span><br><span class="line">&#125;</span><br><span class="line">- stop</span><br><span class="line">- release</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;MediaCodec 架构上采用了2个缓冲区队列，异步处理数据，下面描述的 Client 和 MediaCodec 模块是并行工作的（注：这里的 Client 就是指 “开发者，API 的使用者”）：</p><p>（1）Client 从 input 缓冲区队列申请 empty buffer [dequeueInputBuffer]</p><p>（2）Client 把需要编解码的数据拷贝到 empty buffer，然后放入 input 缓冲区队列 [queueInputBuffer]</p><p>（3）MediaCodec 模块从 input 缓冲区队列取一帧数据进行编解码处理</p><p>（4）编解码处理结束后，MediaCodec 将原始数据 buffer 置为 empty 后放回 input 缓冲区队列，将编解码后的数据放入到 output 缓冲区队列</p><p>（5）Client 从 output 缓冲区队列申请编解码后的 buffer [dequeueOutputBuffer]</p><p>（6）Client 对编解码后的 buffer 进行渲染/播放</p><p>（7）渲染/播放完成后，Client 再将该 buffer 放回 output 缓冲区队列 [releaseOutputBuffer]</p><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>&emsp;&emsp;那么杂实际操作中，我们该怎么使用呢，MediaCodec给我们提供了同步和异步两种使用方式,而在Android 5.0之后又引入了心得Buffer API，所以使用的时候必须兼容考虑这点</p><h3 id="同步使用"><a href="#同步使用" class="headerlink" title="同步使用"></a>同步使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//name既是媒体文件的类型，如audio/3gpp，详情参考MediaFormat的MIMETYPE常量</span><br><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line">codec.configure(format, …);</span><br><span class="line">MediaFormat outputFormat = codec.getOutputFormat(); // option B</span><br><span class="line">codec.start();</span><br><span class="line">for (;;) &#123;</span><br><span class="line">  ////获取可用的inputBuffer -1代表一直等待，0表示不等待 建议-1,避免丢帧</span><br><span class="line">  int inputBufferId = codec.dequeueInputBuffer(-1);</span><br><span class="line">  if (inputBufferId &gt;= 0) &#123;</span><br><span class="line">    ByteBuffer inputBuffer = codec.getInputBuffer(…);</span><br><span class="line">    // fill inputBuffer with valid data</span><br><span class="line">    …</span><br><span class="line">    codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">  &#125;</span><br><span class="line">  //执行上面的操作后就把待编解码的数据存入了输入缓冲区，然后下一步就是操作然后把编解码的数据存入输出缓冲区</span><br><span class="line">  int outputBufferId = codec.dequeueOutputBuffer(…);</span><br><span class="line">  if (outputBufferId &gt;= 0) &#123;</span><br><span class="line">    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</span><br><span class="line">    MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</span><br><span class="line">    // bufferFormat is identical to outputFormat</span><br><span class="line">    // outputBuffer is ready to be processed or rendered.</span><br><span class="line">    …</span><br><span class="line">    codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">  &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">    // Subsequent data will conform to new format.</span><br><span class="line">    // Can ignore if using getOutputFormat(outputBufferId)</span><br><span class="line">    outputFormat = codec.getOutputFormat(); // option B</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">codec.stop();</span><br><span class="line">codec.release();</span><br></pre></td></tr></table></figure><h3 id="异步使用"><a href="#异步使用" class="headerlink" title="异步使用"></a>异步使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line">MediaFormat mOutputFormat; // member variable</span><br><span class="line">codec.setCallback(new MediaCodec.Callback() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  void onInputBufferAvailable(MediaCodec mc, int inputBufferId) &#123;</span><br><span class="line">    ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId);</span><br><span class="line">    // fill inputBuffer with valid data</span><br><span class="line">    …</span><br><span class="line">    codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  void onOutputBufferAvailable(MediaCodec mc, int outputBufferId, …) &#123;</span><br><span class="line">    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</span><br><span class="line">    MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</span><br><span class="line">    // bufferFormat is equivalent to mOutputFormat</span><br><span class="line">    // outputBuffer is ready to be processed or rendered.</span><br><span class="line">    …</span><br><span class="line">    codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  void onOutputFormatChanged(MediaCodec mc, MediaFormat format) &#123;</span><br><span class="line">    // Subsequent data will conform to new format.</span><br><span class="line">    // Can ignore if using getOutputFormat(outputBufferId)</span><br><span class="line">    mOutputFormat = format; // option B</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  void onError(…) &#123;</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">codec.configure(format, …);</span><br><span class="line">mOutputFormat = codec.getOutputFormat(); // option B</span><br><span class="line">codec.start();</span><br><span class="line">// wait for processing to complete</span><br><span class="line">codec.stop();</span><br><span class="line">codec.release();</span><br></pre></td></tr></table></figure><h3 id="android-5-0以下使用"><a href="#android-5-0以下使用" class="headerlink" title="android 5.0以下使用"></a>android 5.0以下使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line"> codec.configure(format, …);</span><br><span class="line"> codec.start();</span><br><span class="line">//API的区别在这里</span><br><span class="line"> ByteBuffer[] inputBuffers = codec.getInputBuffers();</span><br><span class="line"> ByteBuffer[] outputBuffers = codec.getOutputBuffers();</span><br><span class="line"> for (;;) &#123;</span><br><span class="line">   int inputBufferId = codec.dequeueInputBuffer(…);</span><br><span class="line">   if (inputBufferId &gt;= 0) &#123;</span><br><span class="line">     // fill inputBuffers[inputBufferId] with valid data</span><br><span class="line">     …</span><br><span class="line">     codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">   &#125;</span><br><span class="line">   int outputBufferId = codec.dequeueOutputBuffer(…);</span><br><span class="line">   if (outputBufferId &gt;= 0) &#123;</span><br><span class="line">     // outputBuffers[outputBufferId] is ready to be processed or rendered.</span><br><span class="line">     …</span><br><span class="line">     codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">     outputBuffers = codec.getOutputBuffers();</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">     // Subsequent data will conform to new format.</span><br><span class="line">     MediaFormat format = codec.getOutputFormat();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> codec.stop();</span><br><span class="line"> codec.release();</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>&emsp;&emsp;在实际开发中，由于API版本的限制，我们很少使用android原生api进行编解码的操作，一般使用第三方库或者自己写c++写native代码打包成so库然后使用。但是我们必须了解其API原理，更进一步了解Java层的API是调用的C++的api来操作的，对于我们学习ndk开发及了解底层原理很有帮助，实例代码已上传至我的<a href="https://github.com/dengyuaner/AudioDemo" target="_blank" rel="noopener">github</a>，代码内容包括录音，播放，编码，解码等。<br><a href="https://www.dyenter.top/2018/04/15/audio4/" target="_blank" rel="noopener">下一篇</a><br>参考：<br><a href="https://developer.android.google.cn/reference/android/media/MediaCodec.html" target="_blank" rel="noopener">android mediacodec</a><br><a href="https://zhuanlan.zhihu.com/p/20706983" target="_blank" rel="noopener">音频数据的编解码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;上一节中我们讲了怎么采集音频并播放，由于AudioRecord采集的是PCM数据，没有经过处理，所有播放的时候会有杂音，啸叫等现象出现。因此处理掉这些不需要的数据就是本节的内容，编码与解码。&lt;/p&gt;
&lt;h2 id=&quot;原理知识&quot;&gt;&lt;a href=&quot;#原
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="NDK" scheme="http://yoursite.com/categories/Android/NDK/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（二）——音频采集与播放</title>
    <link href="http://yoursite.com/2018/04/15/audio2/"/>
    <id>http://yoursite.com/2018/04/15/audio2/</id>
    <published>2018-04-15T05:46:24.000Z</published>
    <updated>2018-04-15T05:49:59.370Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一节中我们介绍了音频的一些基本知识，这一节我们来讲述如何采集音频数据，然后将采集到的音频播放出来。</p><p>&emsp;&emsp;Android SDK 提供了两套音频采集的API，分别是：MediaRecorder 和 AudioRecord。根据官方文档的说法，该AudioRecord类管理Java应用程序的音频资源记录来自平台的音频输入硬件音频。<br>这是通过“拉”（读）从AudioRecord对象中的数据来实现的。<br>&emsp;&emsp;该应用程序负责轮询使用以下三种方法之一AudioRecord对象在时间：<br>&emsp;&emsp;read(byte[], int, int)，read(byte[], int, int)，read(short[], int, int)，read(short[], int, int)或read(ByteBuffer, int)，read(java.nio.ByteBuffer, int)。要使用的方法的选择将基于这是最方便的AudioRecord的用户的声音数据的存储格式。</p><p>&emsp;&emsp;可以看见，它是更接近底层的方法，我们可以拿到byte原始的pcm数据。而MediaRecorder是更上层的API，它不仅可以记录音频，还可以录制视频，它的工作流如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-7643ed2a00e3df54.gif?imageMogr2/auto-orient/strip" alt="mediarecorder_state_diagram.gif" title="">                </div>                <div class="image-caption">mediarecorder_state_diagram.gif</div>            </figure></p><p>同理MediaPlayer和AudioTrack。</p><p>本节我们将用AudioRecord来采集音频并用AudioTrack播放出来</p><h2 id="使用AudioRecord之前的准备工作"><a href="#使用AudioRecord之前的准备工作" class="headerlink" title="使用AudioRecord之前的准备工作"></a>使用AudioRecord之前的准备工作</h2><h3 id="首先，我们了解一下-AudioRecord-的工作流程："><a href="#首先，我们了解一下-AudioRecord-的工作流程：" class="headerlink" title="首先，我们了解一下 AudioRecord 的工作流程："></a>首先，我们了解一下 AudioRecord 的工作流程：</h3><p>（1） 配置参数，初始化内部的音频缓冲区<br>（2） 开始采集<br>（3） 新建一个线程，不断地从 AudioRecord 的缓冲区将音频数据“读”出来，注意，这个过程一定要及时，否则就会出现“overrun”的错误，该错误在音频开发中比较常见，意味着应用层没有及时地“取走”音频数据，导致内部的音频缓冲区溢出。<br>（4） 停止采集，释放资源<br>注意：缓冲区即类似生产者-消费者模型，AudioRecord把采集到的音频数据放在缓冲区，我们从缓冲区取出数据。我们不要自己设置缓冲区的大小，因为采集音频实际上是调用底层的c函数，这跟具体的设备相关，我们需要通过下面的方法可以获得最小缓冲区的大小：<br>AudioRecord.getMinBufferSize(sampleRateInHz, channelInConfig, audioFormat);<br>它实际上是调用的native_get_min_buff_size(int sampleRateInHz, int channelCount, int audioFormat);</p><h3 id="然后，肯定要申请权限"><a href="#然后，肯定要申请权限" class="headerlink" title="然后，肯定要申请权限"></a>然后，肯定要申请权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="接下来，设置相关的参数，如采样率，通道数，位宽等。"><a href="#接下来，设置相关的参数，如采样率，通道数，位宽等。" class="headerlink" title="接下来，设置相关的参数，如采样率，通道数，位宽等。"></a>接下来，设置相关的参数，如采样率，通道数，位宽等。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int recBufSize, playBufSize;//采集缓冲区的大小，播放缓冲区的大小</span><br><span class="line">private static final int sampleRateInHz = 44100;//采样率</span><br><span class="line">private static final int channelInConfig = AudioFormat.CHANNEL_IN_MONO;//采集通道数</span><br><span class="line">private static final int channelOutConfig = AudioFormat.CHANNEL_OUT_MONO;//播放通道数</span><br><span class="line">private static final int audioFormat = AudioFormat.ENCODING_PCM_16BIT;//位数</span><br><span class="line"></span><br><span class="line">private AudioRecord mAudioRecord;</span><br><span class="line">private AudioTrack mAudioTrack;</span><br><span class="line"></span><br><span class="line">private boolean isRecording;//采集状态</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">recBufSize = AudioRecord.getMinBufferSize(sampleRateInHz, channelInConfig, audioFormat);</span><br><span class="line">playBufSize = AudioTrack.getMinBufferSize(sampleRateInHz, channelOutConfig, audioFormat);</span><br><span class="line"></span><br><span class="line">mAudioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC,</span><br><span class="line">            sampleRateInHz, channelInConfig, audioFormat, recBufSize);</span><br><span class="line"></span><br><span class="line">mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC,</span><br><span class="line">            sampleRateInHz, channelOutConfig, audioFormat, playBufSize, AudioTrack.MODE_STREAM);</span><br></pre></td></tr></table></figure><h3 id="然后就是用线程去取数据"><a href="#然后就是用线程去取数据" class="headerlink" title="然后就是用线程去取数据"></a>然后就是用线程去取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class RecordThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            //采集的音频缓冲区</span><br><span class="line">            byte[] buffer = new byte[recBufSize];</span><br><span class="line">            //开始采集</span><br><span class="line">            mAudioRecord.startRecording();</span><br><span class="line">            //采集的同时播放</span><br><span class="line">            mAudioTrack.play();</span><br><span class="line"></span><br><span class="line">            while (isRecording) &#123;</span><br><span class="line">                 //从音频缓冲区取出声音数据</span><br><span class="line">                int bufferReadResult = mAudioRecord.read(buffer, 0, recBufSize);</span><br><span class="line">                //播放音频缓冲区</span><br><span class="line">                byte[] tempBuffer = new byte[bufferReadResult];</span><br><span class="line"></span><br><span class="line">                 //把音频数据拷贝到播放缓冲区</span><br><span class="line">                System.arraycopy(buffer, 0, tempBuffer, 0, bufferReadResult);</span><br><span class="line">                //播放声音</span><br><span class="line">                mAudioTrack.write(tempBuffer, 0, tempBuffer.length);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //结束播放和采集</span><br><span class="line">            mAudioTrack.stop();</span><br><span class="line">            mAudioRecord.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以设置按钮停止采集与播放，只需要设置isRecording为false即可。</p><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>当你拿到手机上使用时，会发现声音会有很大回音，但是带上耳机后就没了。</p><p>这是由于采集的原始pcm数据没有降噪处理，这种现象叫啸叫。所以这也是为什么我们要编码去除冗余的信息的原因，下一节我们将讲怎么编码音频数据。</p><h2 id="下一篇"><a href="#下一篇" class="headerlink" title="下一篇"></a><a href="https://www.dyenter.top/2018/04/15/audio3/" target="_blank" rel="noopener">下一篇</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;上一节中我们介绍了音频的一些基本知识，这一节我们来讲述如何采集音频数据，然后将采集到的音频播放出来。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Android SDK 提供了两套音频采集的API，分别是：MediaRecorder 和 AudioReco
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="NDK" scheme="http://yoursite.com/categories/Android/NDK/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（一）——基础知识</title>
    <link href="http://yoursite.com/2018/04/15/audio1/"/>
    <id>http://yoursite.com/2018/04/15/audio1/</id>
    <published>2018-04-15T05:30:33.000Z</published>
    <updated>2018-04-15T05:36:47.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;前几天看到一个新闻说陌陌靠直播盈利了，在以前的印象中，陌陌只是一个那啥的软件，现在居然靠直播营收，说明现在直播的火热，因此我们有必要了解下Android音视频方面的知识。我们先了解一下音频。</p><h2 id="音频的基本概念"><a href="#音频的基本概念" class="headerlink" title="音频的基本概念"></a>音频的基本概念</h2><h3 id="采样率（sampleRateInHz）"><a href="#采样率（sampleRateInHz）" class="headerlink" title="采样率（sampleRateInHz）"></a>采样率（sampleRateInHz）</h3><p>&emsp;&emsp;我们知道，自然界中的声音是连续的模拟信号，而计算机只能识别二进制，因此需要把模拟信号转化为数字信号，这个过程就叫做采样。顾名思义，就是选取一些间断的点来转化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-ce1ce1c488ff7fcd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="d53f8794a4c27d1e5f214be71bd5ad6eddc43889.jpg" title="">                </div>                <div class="image-caption">d53f8794a4c27d1e5f214be71bd5ad6eddc43889.jpg</div>            </figure><br>&emsp;&emsp;如上图，当采样周期越短，即采样率越高，选取的点越多，则存储到计算机中的声音播放出来的效果更接近原声，根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音，所以采样率越高越好吗？<br>当然不是，通常人耳能听到频率范围大约在20Hz～20kHz之间的声音，为了保证声音不失真，采样频率应在40kHz以上。常用的音频采样频率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz等。</p><h3 id="采样精度（位宽audioFormat）"><a href="#采样精度（位宽audioFormat）" class="headerlink" title="采样精度（位宽audioFormat）"></a>采样精度（位宽audioFormat）</h3><p>&emsp;&emsp;上图中，每一个红色的采样点，都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit等等，位数越多，表示得就越精细，声音质量自然就越好，当然，数据量也会成倍增大。为了保持android各个版本的兼容性，一般选择16bit。</p><h3 id="声道数（channelConfig）"><a href="#声道数（channelConfig）" class="headerlink" title="声道数（channelConfig）"></a>声道数（channelConfig）</h3><p>&emsp;&emsp;声道数是指支持能不同发声的音响的个数，常见的有单通道，双通道，立体声四通道等</p><h3 id="音频帧（bufferSizeInBytes）"><a href="#音频帧（bufferSizeInBytes）" class="headerlink" title="音频帧（bufferSizeInBytes）"></a>音频帧（bufferSizeInBytes）</h3><p>&emsp;&emsp;大家都知道视频帧就是一幅图像，音频的帧的概念没有视频帧那么清晰，几乎所有视频编码格式都可以简单的认为一帧就是编码后的一副图像。但音频帧跟编码格式相关，它是各个编码标准自己实现的。在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的，我们可以计算一下一帧音频帧的大小：<br>假设某音频信号是采样率为44.1kHz、双通道、位宽为16bit，40ms一帧，则一帧音频数据的大小为：<br>                          int size =44100 x 2 x 16bit x 0.04s = 56488 bit = 7056 byte</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>&emsp;&emsp;android中采集音频后得到的是原始的PCM数据，这些数据代表着无损的原始数字音频信号，添加一些文件头信息，就可以存储为WAV文件了，它是一种由微软和IBM联合开发的用于音频数字存储的标准，可以很容易地被解析和播放。而其他格式如mp3等要经过编码后才能播放，编码的目的就是去除冗余信息。所以，一般你会发现你把mp3格式的音频转为wav后体积会变很大。</p><p>&emsp;&emsp;再简单介绍一下音频数据压缩的最基本的原理：因为有冗余信息，所以可以压缩。</p><p>&emsp;&emsp;（1） 频谱掩蔽效应： 人耳所能察觉的声音信号的频率范围为20Hz～20KHz，在这个频率范围以外的音频信号属于冗余信号。<br>&emsp;&emsp;（2） 时域掩蔽效应： 当强音信号和弱音信号同时出现时，弱信号会听不到，因此，弱音信号也属于冗余信号。</p><h2 id="Android应用层提供的API"><a href="#Android应用层提供的API" class="headerlink" title="Android应用层提供的API"></a>Android应用层提供的API</h2><p>&emsp;&emsp;android提供了很多丰富的类供我们处理音频，而这些类实际上是通过jni调用了c/c++的函数。</p><p>&emsp;&emsp;音频采集： MediaRecoder，AudioRecord</p><p>&emsp;&emsp;音频播放： SoundPool，MediaPlayer，AudioTrack </p><p>&emsp;&emsp;音频编解码： MediaCodec</p><p>&emsp;&emsp;NDK API： OpenSL ES</p><h2 id="下一节，我们将讲述怎么录制音频"><a href="#下一节，我们将讲述怎么录制音频" class="headerlink" title="下一节，我们将讲述怎么录制音频"></a><a href="https://www.dyenter.top/2018/04/15/audio2/" target="_blank" rel="noopener">下一节</a>，我们将讲述怎么录制音频</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;前几天看到一个新闻说陌陌靠直播盈利了，在以前的印象中，陌陌只是一个那啥的软件，现在居然靠直播营收，说明现在直播的火热
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="NDK" scheme="http://yoursite.com/categories/Android/NDK/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>listview相关问题——只更新某一个item</title>
    <link href="http://yoursite.com/2018/04/15/listview2/"/>
    <id>http://yoursite.com/2018/04/15/listview2/</id>
    <published>2018-04-15T05:28:27.000Z</published>
    <updated>2018-04-15T05:29:41.195Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，更新listview通常调用修改adapter的数据源，然后调用adapter的notifyDataSetChanged();</p><p>但是有时候只是需要更新某一个指定的item，比如微信聊天应用中。这个时候，我们不需要去调用Adapter的notifyDataSetChanged（）方法。可以写一个updateItem(int position)的方法去更新指定项,这样代价就会小一些。</p><p>那么我们怎么拿到这个item然后去更新它的数据呢，其实listview提供了getChildAt(int index)方法让我们去获取，这个方法其实是ViewGroup的方法。并且由于一般使用了ViewHolder缓存机制，所以我们获取子item的时候要注意在可见区域的position去获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void updataItem(int position) &#123;</span><br><span class="line">      int firstVisiblePos = listView.getFirstVisiblePosition();</span><br><span class="line">      int lastVisibalePos = listView.getLastVisiblePosition();</span><br><span class="line">      if (position &gt;= firstVisiblePos &amp;&amp; position &lt;= lastVisibalePos) &#123;</span><br><span class="line">          View view = listView.getChildAt(position - firstVisiblePos);</span><br><span class="line">          ViewHolder viewHolder = (ViewHolder) view.getTag();</span><br><span class="line">          //然后使用viewholder去更新需要更新的view。 </span><br><span class="line">          //TextView textView = (TextView) viewHolder.findViewById(R.id.textView);</span><br><span class="line">          //textView.setText(&quot;11111&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们都知道，更新listview通常调用修改adapter的数据源，然后调用adapter的notifyDataSetChanged();&lt;/p&gt;
&lt;p&gt;但是有时候只是需要更新某一个指定的item，比如微信聊天应用中。这个时候，我们不需要去调用Adapter的notifyD
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ListView" scheme="http://yoursite.com/tags/ListView/"/>
    
      <category term="EditText" scheme="http://yoursite.com/tags/EditText/"/>
    
  </entry>
  
  <entry>
    <title>Android近场通讯——NFC(二)</title>
    <link href="http://yoursite.com/2018/04/15/nfc2/"/>
    <id>http://yoursite.com/2018/04/15/nfc2/</id>
    <published>2018-04-15T05:21:18.000Z</published>
    <updated>2018-04-15T05:27:12.475Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.dyenter.top/2018/04/15/nfc1/" target="_blank" rel="noopener">上一篇</a>中，简单的介绍了下nfc的相关知识，这一篇将以代码的形式更深入的理解nfc。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="首先肯定要申请相应的权限："><a href="#首先肯定要申请相应的权限：" class="headerlink" title="首先肯定要申请相应的权限："></a>首先肯定要申请相应的权限：</h3><p><code>&lt;uses-permission android:name=&quot;android.permission.NFC&quot; /&gt;</code><br><code>&lt;uses-feature android:name=&quot;android.hardware.nfc&quot; android:required=&quot;true&quot; /&gt;</code><br><code>&lt;uses-sdk android:minSdkVersion=&quot;14&quot;/&gt;</code><br>同时要注意最小api的版本，根据谷歌官方的说话，NFC在Android上，也是从API9才开始支持的，但是到了API14 Google才对NFC大力开发，所以等到了API15的时候，NFC的传输速度就得到了很大的加强，所以最小api最好设置为14.</p><h3 id="然后在相应的要接收nfc信息的activity中注册intent-filter："><a href="#然后在相应的要接收nfc信息的activity中注册intent-filter：" class="headerlink" title="然后在相应的要接收nfc信息的activity中注册intent filter："></a>然后在相应的要接收nfc信息的activity中注册intent filter：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot;/&gt;</span><br><span class="line">    &lt;data android:mimeType=&quot;text/plain&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;</span><br><span class="line">    android:resource=&quot;@xml/nfc_tech_filter&quot;/&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.nfc.action.TAG_DISCOVERED&quot;/&gt;</span><br><span class="line">    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure><p>如果您的活动过滤器是ACTION_TECH_DISCOVERED，你必须创建一个指定的活动支持内技术的XML资源文件，可以通过android.nfc.Tag类的getTechList()获取子集<br>其中名为nfc_tech_filter的xml文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt;</span><br><span class="line">    &lt;tech-list&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcF&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcV&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NdefFormatable&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.MifareClassic&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.MifareUltralight&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">    &lt;/tech-list&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>当然您也可以指定多个tech-list组。每个的tech-list集独立地考虑，并且您的活动被认为是一个匹配，如果任何一个 tech-list组是由返回的技术的一个子集getTechList()，这提供了AND与OR匹配技术，语义。<br>下面的例子相匹配，可以支持NFCA和NDEF技术或可以支持NfcB和NDEF技术代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt;</span><br><span class="line">    &lt;tech-list&gt;</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt;</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt;</span><br><span class="line">    &lt;/tech-list&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt;</span><br><span class="line">    &lt;tech-list&gt;</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt;</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt;</span><br><span class="line">    &lt;/tech-list&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>做了这么多，终于可以在activity里面读取，写入nfc了，首先我们定义了NfcScanActivity来扫描nfc设备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  ......//关键代码，onCreate中</span><br><span class="line">  // 获取默认的NFC控制器</span><br><span class="line">  mAdapter = NfcAdapter.getDefaultAdapter(this);</span><br><span class="line">  if (mAdapter == null) &#123;</span><br><span class="line">      promt.setText(&quot;设备不支持NFC！&quot;);</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!mAdapter.isEnabled()) &#123;</span><br><span class="line">      promt.setText(&quot;请在系统设置中先启用NFC功能！&quot;);</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">  //创建intent检测nfc</span><br><span class="line">  mPendingIntent = PendingIntent</span><br><span class="line">          .getActivity(this, 0, new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);</span><br><span class="line">//onResume</span><br><span class="line">if (this.mAdapter == null)</span><br><span class="line">      return;</span><br><span class="line">  if (!this.mAdapter.isEnabled()) &#123;</span><br><span class="line">      promt.setText(&quot;请在系统设置中先启用NFC功能！&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //监听nfc设备</span><br><span class="line">  this.mAdapter.enableForegroundDispatch(this, this.mPendingIntent, null, null);</span><br></pre></td></tr></table></figure></p><p>因为我们注册了Intent Filter，当扫描到设备后，系统会调用我们的app，进而会进入activity的onNewIntent(Intent paramIntent)方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onNewIntent(Intent intent) &#123;</span><br><span class="line">        setIntent(paramIntent);</span><br><span class="line">        //我们接受到消息啦，可以处理了</span><br><span class="line">// 得到是否检测到TAG触发</span><br><span class="line">        if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(intent.getAction())</span><br><span class="line">                || NfcAdapter.ACTION_TAG_DISCOVERED.equals(intent.getAction())</span><br><span class="line">                || NfcAdapter.ACTION_NDEF_DISCOVERED.equals(intent.getAction())) &#123;</span><br><span class="line">            // 处理该intent</span><br><span class="line">            Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);</span><br><span class="line">            // 获取标签id数组</span><br><span class="line">            byte[] bytesId = tag.getId();</span><br><span class="line">            //获取消息内容</span><br><span class="line">            NfcMessageParser nfcMessageParser = new NfcMessageParser(intent);</span><br><span class="line">            List&lt;String&gt; tagMessage = nfcMessageParser.getTagMessage();</span><br><span class="line"></span><br><span class="line">            if (tagMessage == null || tagMessage.size() == 0) &#123;</span><br><span class="line"></span><br><span class="line">                //Toast.makeText(this, &quot;NFC格式不支持...&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i = 0; i &lt; tagMessage.size(); i++) &#123;</span><br><span class="line">                    Log.e(&quot;tag&quot;, tagMessage.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                datas = tagMessage.get(0);</span><br><span class="line">            &#125;</span><br><span class="line">            String info = &quot;&quot;;</span><br><span class="line">            if (datas != null) &#123;</span><br><span class="line">                info += &quot;内容：&quot; + datas + &quot;\n卡片ID：&quot; + bytesToHexString(bytesId) + &quot;\n&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                info += &quot;内容：空&quot; + &quot;\n卡片ID：&quot; + bytesToHexString(bytesId) + &quot;\n&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            String[] techList = tag.getTechList();</span><br><span class="line"></span><br><span class="line">            //分析NFC卡的类型： Mifare Classic/UltraLight Info</span><br><span class="line">            String cardType = &quot;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            for (String aTechList : techList) &#123;</span><br><span class="line">                if (TextUtils.equals(aTechList, &quot;android.nfc.tech.Ndef&quot;)) &#123;</span><br><span class="line">                    Ndef ndef = Ndef.get(tag);</span><br><span class="line">                    cardType += &quot;最大数据尺寸:&quot; + ndef.getMaxSize() + &quot;字节&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info += cardType;</span><br><span class="line"></span><br><span class="line">            promt.setText(&quot;NFC信息如下：\n&quot; + info);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>传来的intent中包含了：<br><a href="https://developer.android.google.cn/reference/android/nfc/NfcAdapter.html#EXTRA_TAG" target="_blank" rel="noopener">EXTRA_TAG</a>：一个<a href="https://developer.android.google.cn/reference/android/nfc/Tag.html" target="_blank" rel="noopener">Tag</a>对象，表示扫描标签。<br><a href="https://developer.android.google.cn/reference/android/nfc/NfcAdapter.html#EXTRA_NDEF_MESSAGES" target="_blank" rel="noopener">EXTRA_NDEF_MESSAGES</a>（可选）：从标签解析NDEF消息的数组，这个就是我们要的数据，显示到屏幕上。<br><a href="https://developer.android.google.cn/reference/android/nfc/NfcAdapter.html#EXTRA_ID" target="_blank" rel="noopener">EXTRA_ID</a>（可选）：标签的ID。<br>处理消息的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 得到Intent中的NDEF数据</span><br><span class="line">    private NdefMessage[] getTagNdef(Intent intent) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        NdefMessage[] msgs = null;</span><br><span class="line">        Parcelable[] rawMsgs = intent</span><br><span class="line">                .getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);</span><br><span class="line"></span><br><span class="line">        //把序列化数据转成Messaeg对象</span><br><span class="line">        if (rawMsgs != null) &#123;</span><br><span class="line">            msgs = new NdefMessage[rawMsgs.length];</span><br><span class="line">            for (int i = 0; i &lt; rawMsgs.length; i++) &#123;</span><br><span class="line">                msgs[i] = (NdefMessage) rawMsgs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Unknown tag type</span><br><span class="line">            byte[] empty = new byte[]&#123;&#125;;</span><br><span class="line">            NdefRecord record = new NdefRecord(NdefRecord.TNF_UNKNOWN, empty,</span><br><span class="line">                    empty, empty);</span><br><span class="line">            NdefMessage msg = new NdefMessage(new NdefRecord[]&#123;record&#125;);</span><br><span class="line">            msgs = new NdefMessage[]&#123;msg&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return msgs;</span><br><span class="line">    &#125;</span><br><span class="line">     // 把Message转成List</span><br><span class="line">    private List&lt;String&gt; getNdefString(NdefMessage[] msgs) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        if (msgs != null &amp;&amp; msgs.length != 0) &#123;</span><br><span class="line">            List&lt;String&gt; tagMessage = parser(msgs[0]);</span><br><span class="line">            return tagMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后就可以显示到你想要的地方去了</p><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><h3 id="NdefRecord对象"><a href="#NdefRecord对象" class="headerlink" title="NdefRecord对象"></a>NdefRecord对象</h3><p>写入数据最关键的就是创建一个NdefRecord对象，然后通过Ndef对象的writeNdefMessage(NdefMessage message)方法写入,当然前提还是要检测到设备，这里格式是TNF_WELL_KNOWN with RTD_TEXT，即写入文本字符串，如果你想写入其他数据，请参考官方文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 创建record，格式为TNF_WELL_KNOWN with RTD_TEXT</span><br><span class="line">     *</span><br><span class="line">     * @param payload      你要写入的数据</span><br><span class="line">     * @param locale</span><br><span class="line">     * @param encodeInUtf8 编码</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">public NdefRecord createTextRecord(String payload, Locale locale, boolean encodeInUtf8) &#123;</span><br><span class="line">    byte[] langBytes = locale.getLanguage().getBytes(Charset.forName(&quot;US-ASCII&quot;));</span><br><span class="line">    Charset utfEncoding = encodeInUtf8 ? Charset.forName(&quot;UTF-8&quot;) : Charset.forName(&quot;UTF-16&quot;);</span><br><span class="line">    byte[] textBytes = payload.getBytes(utfEncoding);</span><br><span class="line">    int utfBit = encodeInUtf8 ? 0 : (1 &lt;&lt; 7);</span><br><span class="line">    char status = (char) (utfBit + langBytes.length);</span><br><span class="line">    byte[] data = new byte[1 + langBytes.length + textBytes.length];</span><br><span class="line">    data[0] = (byte) status;</span><br><span class="line">    System.arraycopy(langBytes, 0, data, 1, langBytes.length);</span><br><span class="line">    System.arraycopy(textBytes, 0, data, 1 + langBytes.length, textBytes.length);</span><br><span class="line">    NdefRecord record = new NdefRecord(NdefRecord.TNF_WELL_KNOWN,</span><br><span class="line">    NdefRecord.RTD_TEXT, new byte[0], data);</span><br><span class="line">    return record;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="生成需要的NdefMessage对象"><a href="#生成需要的NdefMessage对象" class="headerlink" title="生成需要的NdefMessage对象"></a>生成需要的NdefMessage对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> //textRecord就是上面生成的NdefRecord</span><br><span class="line">NdefMessage message = new NdefMessage(new NdefRecord[]&#123;textRecord&#125;);</span><br></pre></td></tr></table></figure><h3 id="最后写入数据："><a href="#最后写入数据：" class="headerlink" title="最后写入数据："></a>最后写入数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 写入数据</span><br><span class="line">     * @param message</span><br><span class="line">     * @param tag  intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean writeTag(NdefMessage message, Tag tag) &#123;</span><br><span class="line">        int size = message.toByteArray().length;</span><br><span class="line">        try &#123;</span><br><span class="line">            //链接nfc</span><br><span class="line">            Ndef ndef = Ndef.get(tag);</span><br><span class="line">            if (ndef != null) &#123;</span><br><span class="line">                ndef.connect();</span><br><span class="line">                if (!ndef.isWritable()) &#123;</span><br><span class="line">Toast.makeText(this, &quot;tag不允许写入&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                 </span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (ndef.getMaxSize() &lt; size) &#123;</span><br><span class="line">Toast.makeText(this,&quot;文件大小超出容量&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                 </span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ndef.writeNdefMessage(message);</span><br><span class="line">Toast.makeText(this,&quot;写入数据成功.&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">           </span><br><span class="line">                isWrite = false;</span><br><span class="line">                finish();</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NdefFormatable format = NdefFormatable.get(tag);</span><br><span class="line">                if (format != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        format.connect();</span><br><span class="line">                        format.format(message);</span><br><span class="line">                        Toast.makeText(this,&quot;格式化tag并且写入message&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      </span><br><span class="line">                        return true;</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                            Toast.makeText(this, &quot;格式化tag失败.&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      </span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                        Toast.makeText(this, &quot;Tag不支持NDEF&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">               </span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">                Toast.makeText(this,&quot;写入数据失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码已上传至github，欢迎clone，谢谢star"><a href="#完整代码已上传至github，欢迎clone，谢谢star" class="headerlink" title="完整代码已上传至github，欢迎clone，谢谢star"></a>完整代码已上传至<a href="https://github.com/dengyuaner/AndroidNFCDemo" target="_blank" rel="noopener">github</a>，欢迎clone，谢谢star</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://www.dyenter.top/2018/04/15/nfc1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇&lt;/a&gt;中，简单的介绍了下nfc的相关知识，这一篇将以代码的形式更深入的理解nfc。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="NFC" scheme="http://yoursite.com/tags/NFC/"/>
    
      <category term="近场通讯" scheme="http://yoursite.com/tags/%E8%BF%91%E5%9C%BA%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>Android近场通讯——NFC(一)</title>
    <link href="http://yoursite.com/2018/04/15/nfc1/"/>
    <id>http://yoursite.com/2018/04/15/nfc1/</id>
    <published>2018-04-15T05:07:18.000Z</published>
    <updated>2018-04-15T05:45:57.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;NFC（Near Field Communication 近场通讯），它是前几年逐渐起来的一种技术，出来之后，感觉一直不温不火的样子。直到最近有个朋友需要手机与nfc标签读写信息，让我帮忙，所以才了解这门技术，下面我们一起来了解并学习一下。<br><a href="https://developer.android.google.cn/guide/topics/connectivity/nfc/nfc.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="近场通讯"><a href="#近场通讯" class="headerlink" title="近场通讯"></a>近场通讯</h2><p>&emsp;&emsp;大家都知道android近场通讯包括我们最熟知的wifi，蓝牙，还有已经慢慢消失的红外，最后就是我们今天的主角nfc了，nfc与其他通信类型不同的是要求距离不能超过4cm（不同的nfc标签略有差别），查看官方文档，我们知道nfc通信的模式有一下三种：</p><h2 id="emsp-emsp-读卡器模式（Reader-Writer-Mode）"><a href="#emsp-emsp-读卡器模式（Reader-Writer-Mode）" class="headerlink" title="&emsp;&emsp;读卡器模式（Reader/Writer Mode）"></a>&emsp;&emsp;读卡器模式（Reader/Writer Mode）</h2><h2 id="emsp-emsp-仿真卡模式（Card-Emulation-Mode）"><a href="#emsp-emsp-仿真卡模式（Card-Emulation-Mode）" class="headerlink" title="&emsp;&emsp;仿真卡模式（Card Emulation Mode）"></a>&emsp;&emsp;仿真卡模式（Card Emulation Mode）</h2><h2 id="emsp-emsp-点对点模式（P2P-Mode）"><a href="#emsp-emsp-点对点模式（P2P-Mode）" class="headerlink" title="&emsp;&emsp;点对点模式（P2P Mode）"></a>&emsp;&emsp;点对点模式（P2P Mode）</h2><h2 id="nfc标签"><a href="#nfc标签" class="headerlink" title="nfc标签"></a>nfc标签</h2><p>&emsp;&emsp;今天主要讲的是读写模式，在开始写代码之前，有必要了解nfc的标签调度系统，标签调度系统如何解析NFC标签和特殊的工作，当它检测到NDEF消息的标记调度系统一样。NFC标签来在广泛的技术和还可以有许多不同的方式写入到其中的数据。机器人具有用于NDEF标准NDEF数据被封装的消息（内部NdefMessage），其中包含一个或多个记录（NdefRecord）。每个NDEF记录必须根据您要创建的记录类型的规格良好的。Android版 ​​还支持其它类型的标签不包含NDEF的数据，您可以通过在使用类的工作android.nfc.tech包。要了解更多有关这些技术，请参阅高级NFC主题。这些其他类型的标签工作包括编写你自己的协议栈与标签进行通信，因此，我们建议使用NDEF在可能的情况，便于开发和最大支持Android的供电设备。</p><p>现在，你有NFC标签的背景，下面的章节详细描述了Android的如何处理NDEF格式化的标签。<br>当一个Android设备扫描包含NDEF格式的数据的NFC标签，它解析该消息并试图找出数据的MIME类型或标识的URI。要做到这一点，系统读取所述第一<a href="https://developer.android.google.cn/reference/android/nfc/NdefRecord.html" target="_blank" rel="noopener">NdefRecord</a><br>内部的<a href="https://developer.android.google.cn/reference/android/nfc/NdefMessage.html" target="_blank" rel="noopener">NdefMessage</a>，以确定如何解释整个NDEF消息（一个NDEF消息可以有多个NDEF记录）。<br>在一个结构良好的NDEF消息，第一个<a href="https://developer.android.google.cn/reference/android/nfc/NdefRecord.html" target="_blank" rel="noopener">NdefRecord</a></p><p>包含以下字段：</p><p>3-bit TNF (Type Name Format) :指示如何解释可变长度类型字段</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-406ac40629b31ff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="0HF]EHB8]IQN5AC1BFIAY3M.png" title="">                </div>                <div class="image-caption">0HF]EHB8]IQN5AC1BFIAY3M.png</div>            </figure><p>Variable length type:描述了记录的类型。如果使用TNF_WELL_KNOWN，使用此字段指定记录类型定义（RTD）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-a799d2711eb454b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ZMUO)G4X)HRB%ZH0)DK_7J1.png" title="">                </div>                <div class="image-caption">ZMUO)G4X)HRB%ZH0)DK_7J1.png</div>            </figure><p>Variable length payload:要读取或写入的实际数据的有效载荷。一个NDEF消息可以包含多个NDEF记录，所以不承担全部有效载荷在NDEF消息的第一NDEF纪录。</p><h2 id="nfc分发"><a href="#nfc分发" class="headerlink" title="nfc分发"></a>nfc分发</h2><p>&emsp;&emsp;说了这么多，Android系统是怎么检测到nfc靠近并通知相应的应用程序呢？其实就是用的Intent Filter,当我们在AndroidManifest.xml的activity中注册了相应的nfc intent后，当有相应的action来临时，系统就会把nfc分发到该App中，如果有多个App符合要求，则系统会弹出对话框让用户选择。标签调度系统定义了三个意图，优先级从高到低如下：</p><h3 id="ACTION-NDEF-DISCOVERED："><a href="#ACTION-NDEF-DISCOVERED：" class="headerlink" title="ACTION_NDEF_DISCOVERED："></a>ACTION_NDEF_DISCOVERED：</h3><p>&emsp;&emsp;本意图是用来启动一个活动时，它包含一个NDEF净荷标签的扫描和是一个公认的类型。<br>&emsp;&emsp;这是最高优先级的意图，并且标签调度系统尝试尽可能任何其他意图，之前启动这一意图的活动。</p><h3 id="ACTION-TECH-DISCOVERED："><a href="#ACTION-TECH-DISCOVERED：" class="headerlink" title="ACTION_TECH_DISCOVERED："></a>ACTION_TECH_DISCOVERED：</h3><p>&emsp;&emsp;如果没有App注册过ACTION_NDEF_DISCOVERED，标签调度系统试图启动与此意向的应用程序。此意向也直接启动（不启动ACTION_NDEF_DISCOVERED在前），如果被扫描的标签包含无法映射到MIME类型或URI，或者如果标签不包含NDEF数据，但是是一个已知的标签技术NDEF数据。</p><h3 id="ACTION-TAG-DISCOVERED："><a href="#ACTION-TAG-DISCOVERED：" class="headerlink" title="ACTION_TAG_DISCOVERED："></a>ACTION_TAG_DISCOVERED：</h3><p>&emsp;&emsp;如果没有活动处理这一意图已启动ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED意图。</p><h2 id="标签调度系统工作的基本方法如下："><a href="#标签调度系统工作的基本方法如下：" class="headerlink" title="标签调度系统工作的基本方法如下："></a>标签调度系统工作的基本方法如下：</h2><p>&emsp;&emsp;1.尝试启动与由标签调度系统解析NFC标签时（无论是创建一个意图活动ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED）。</p><p>&emsp;&emsp;2.如果这一意图没有活动过滤器，尝试下一个优先级最低的意图（无论是启动一个活动ACTION_TECH_DISCOVERED或ACTION_TAG_DISCOVERED，直到意图或直至标签调度系统中的应用程序过滤器尝试所有可能的目的。</p><p>&emsp;&emsp;3.如果没有应用程序筛选任何意图的，什么也不做。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-639426c951292b51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nfc_tag_dispatch.png" title="">                </div>                <div class="image-caption">nfc_tag_dispatch.png</div>            </figure><p>只要有可能，以NDEF消息和工作ACTION_NDEF_DISCOVERED的意图，因为它是最特定出的三个。<br>此意向，您可以在比其他两个意图更适当的时间启动应用程序，给用户更好的体验。</p><h2 id="下一篇Android-NFC-二"><a href="#下一篇Android-NFC-二" class="headerlink" title="下一篇Android NFC(二)"></a>下一篇<a href="https://www.dyenter.top/2018/04/15/nfc2/" target="_blank" rel="noopener">Android NFC(二)</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;NFC（Near Field Communication 近场通讯），它是前几年逐渐起来的一种技术，出来之后，感觉一
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="NFC" scheme="http://yoursite.com/tags/NFC/"/>
    
      <category term="近场通讯" scheme="http://yoursite.com/tags/%E8%BF%91%E5%9C%BA%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>listview相关问题——item包含EditText</title>
    <link href="http://yoursite.com/2018/04/15/listview/"/>
    <id>http://yoursite.com/2018/04/15/listview/</id>
    <published>2018-04-15T04:56:01.000Z</published>
    <updated>2018-04-15T05:44:59.222Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在日常开发中，ListView是我们常用的控件，也是遇到坑比较多的一个控件。在之前的项目中，有这样的一个布局需求，在ListView的item中包含有EditText，第一个问题就是焦点问题，会发现edittext获取不到焦点。</p><h2 id="焦点问题"><a href="#焦点问题" class="headerlink" title="焦点问题"></a>焦点问题</h2><p>&emsp;&emsp;比如我们有如下的代码：</p><h3 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class="line">        android:id=&quot;@+id/activity_main&quot;    </span><br><span class="line">        android:layout_width=&quot;match_parent&quot;    </span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;    </span><br><span class="line">        &lt;ListView  android:id=&quot;@+id/listView&quot;       </span><br><span class="line">                   android:layout_width=&quot;match_parent&quot;        </span><br><span class="line">                   android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><h3 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;     </span><br><span class="line">    ListView mListView;    </span><br><span class="line">    MyAdapter mMyAdapter;    </span><br><span class="line">    @Override    </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;        </span><br><span class="line">        super.onCreate(savedInstanceState);        </span><br><span class="line">        setContentView(R.layout.activity_main);        </span><br><span class="line">        mListView = (ListView) findViewById(R.id.listView);        </span><br><span class="line">        mMyAdapter = new MyAdapter(this);        </span><br><span class="line">        mListView.setAdapter(mMyAdapter);   </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="MyAdapter-java"><a href="#MyAdapter-java" class="headerlink" title="MyAdapter.java"></a>MyAdapter.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdapter extends BaseAdapter &#123;    </span><br><span class="line">    private Context mContext;    </span><br><span class="line">    public MyAdapter(Context context) &#123;        </span><br><span class="line">        this.mContext = context;   </span><br><span class="line">    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public int getCount() &#123;        </span><br><span class="line">        return 20;    </span><br><span class="line">    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public Object getItem(int position) &#123;        </span><br><span class="line">        return null;   </span><br><span class="line">    &#125;   </span><br><span class="line">     @Override   </span><br><span class="line">     public long getItemId(int position) &#123;       </span><br><span class="line">         return 0;    </span><br><span class="line">    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;        </span><br><span class="line">        EditText editText;        </span><br><span class="line">        if (convertView == null) &#123;            </span><br><span class="line">            editText = new EditText(mContext);            </span><br><span class="line">            convertView = editText;       </span><br><span class="line">        &#125; else &#123;            </span><br><span class="line">            editText = (EditText) convertView;        </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(&quot;current pos:&quot; + position);        </span><br><span class="line">        return convertView;    </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当你运行上述简单的代码后发现EditText是无法获取焦点的，导致无法输入任何东东，那么原因何在呢？</p><p>&emsp;&emsp;其实，是listview先于子item抢占了焦点，那么我们首先想到的就是让listview失去焦点，让子item获取焦点（当然，listview 的onitem相关监听事件会失效）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mListView.setFocusable(false);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这是再运行发现键盘弹出了，可是editText获取到焦点然后又失去了，需要你手动再次点击才能获取到，然后才能输入。<br>而且当你输入完毕，关闭软键盘，发现输入的东西不见了，自动清空。这又产生了两个问题。</p><p>第一个问题是listview每次调用getview都会使EditText失去焦点，第二个问题归结于下面要讲的listview的item复用产生的问题。</p><p>第一种方式行不通，查询相关资料发现，可以通过给listview的item的根布局设置descendantFocusability属性。</p><h4 id="android-descendantFocusability属性有三个值："><a href="#android-descendantFocusability属性有三个值：" class="headerlink" title="android:descendantFocusability属性有三个值："></a>android:descendantFocusability属性有三个值：</h4><pre><code>beforeDescendants：viewgroup会优先其子类控件而获取到焦点afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点</code></pre><h3 id="那么我们修改adapter中的getView方法"><a href="#那么我们修改adapter中的getView方法" class="headerlink" title="那么我们修改adapter中的getView方法"></a>那么我们修改adapter中的getView方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;    </span><br><span class="line">    EditText editText;   </span><br><span class="line">    if (convertView == null) &#123;        </span><br><span class="line">        convertView = LayoutInflater.from(mContext).inflate(R.layout.list_edittext, parent, false);        </span><br><span class="line">        editText = (EditText) convertView.findViewById(R.id.editText);       </span><br><span class="line">        convertView.setTag(editText);    </span><br><span class="line">     &#125; else &#123;        </span><br><span class="line">        editText = (EditText) convertView.getTag();   </span><br><span class="line">     &#125;    </span><br><span class="line">     System.out.println(&quot;current pos:&quot; + position);    </span><br><span class="line">     return convertView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list-edittext-xml"><a href="#list-edittext-xml" class="headerlink" title="list_edittext.xml"></a>list_edittext.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;       </span><br><span class="line">    android:layout_width=&quot;match_parent&quot;              </span><br><span class="line">    android:layout_height=&quot;match_parent&quot;   </span><br><span class="line">   android:descendantFocusability=&quot;beforeDescendants&quot;         </span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;    </span><br><span class="line">    &lt;EditText  android:id=&quot;@+id/editText&quot;        </span><br><span class="line">        android:layout_width=&quot;match_parent&quot;        </span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>发现还是无效果，其实我们少了一句关键的代码，就是给相应的 activity 设置 windowSoftInputMode= adjustPan 即可。。</p><p>终上所述，我认为的解决方案就是给ListView或者ListView的item的根布局添加android:descendantFocusability=”beforeDescendants”，然后设置相应的activity 的windowSoftInputMode属性为adjustPan 。</p><h2 id="数据问题"><a href="#数据问题" class="headerlink" title="数据问题"></a>数据问题</h2><p>&emsp;&emsp;解决完焦点问题后，另一个问题就是edittext的数据问题了。当我们在当前屏幕的edittext中输入东东后，往下滑，发现下面的edittext自动输入了我们输入过得东东，这明显是我们不愿意看到的。</p><p>其实这是由于getView方法的复用view导致的，加入你在position=0的edittext中输入了内容，当你往下滑时，当position为0的view完全消失时，该view会被加入到 mActiveViews[]中，当下方的item检测到由可用的view，则从该数组中取出，所以下方的edittext的内容会跟上面你输入的一样，其实就是同一个edittext。关于listview源码级解析详见<a href="http://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">链接</a></p><h3 id="解决方案——保存edittext的内容"><a href="#解决方案——保存edittext的内容" class="headerlink" title="解决方案——保存edittext的内容"></a>解决方案——保存edittext的内容</h3><p>修改adapter代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//新增一个数组用于保存edittext的内容</span><br><span class="line">private SparseArray&lt;String&gt; mStringSparseArray;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(final int position, View convertView, ViewGroup parent) &#123;    </span><br><span class="line">    EditTextHolder editTextHolder;    </span><br><span class="line">    if (convertView == null) &#123;        </span><br><span class="line">        convertView = LayoutInflater.from(mContext).inflate(R.layout.list_edittext, parent, false);                    </span><br><span class="line"></span><br><span class="line">        editTextHolder = new EditTextHolder();       </span><br><span class="line">        editTextHolder.mEditText = (EditText) convertView.findViewById(R.id.editText);                      </span><br><span class="line"></span><br><span class="line">        editTextHolder.mMyTextWatcher = new MyTextWatcher(position, mStringSparseArray);                        </span><br><span class="line">        //给edittext设置watcher</span><br><span class="line">        editTextHolder.mEditText.addTextChangedListener(editTextHolder.mMyTextWatcher);                        </span><br><span class="line"></span><br><span class="line">        convertView.setTag(editTextHolder);    </span><br><span class="line">    &#125; else &#123;        </span><br><span class="line">         editTextHolder = (EditTextHolder) convertView.getTag();        </span><br><span class="line">         //由于复用了edittext，导致他的watcher里的position还是之前的positiono，所以需要通知</span><br><span class="line">         //watcher更新positon，才能保存正确的positon的值</span><br><span class="line">         editTextHolder.updatePosition(position);   </span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(position);    </span><br><span class="line">    editTextHolder.mEditText.setText(mStringSparseArray.get(position));   </span><br><span class="line">    return convertView;</span><br><span class="line">&#125;</span><br><span class="line">static class EditTextHolder &#123;    </span><br><span class="line">    EditText mEditText;    </span><br><span class="line">    MyTextWatcher mMyTextWatcher;    </span><br><span class="line">    public void updatePosition(int position) &#123;        </span><br><span class="line">        mMyTextWatcher.updatePosition(position);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class MyTextWatcher implements TextWatcher &#123;    </span><br><span class="line">    private int position;    </span><br><span class="line">    private SparseArray&lt;String&gt; sparseArray;    </span><br><span class="line">    //更新postion</span><br><span class="line">    public void updatePosition(int position) &#123;        </span><br><span class="line">        this.position = position;    </span><br><span class="line">    &#125;   </span><br><span class="line">    public MyTextWatcher(int position, SparseArray&lt;String&gt; sparseArray) &#123;       </span><br><span class="line">         this.position = position;        </span><br><span class="line">         this.sparseArray = sparseArray;    </span><br><span class="line">    &#125;   </span><br><span class="line">    @Override   </span><br><span class="line">    public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public void onTextChanged(CharSequence s, int start, int before, int count) &#123;    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public void afterTextChanged(Editable s) &#123;        </span><br><span class="line">        //保存edittext的值</span><br><span class="line">        sparseArray.put(position, s.toString());    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，发现edittext数据错乱问题解决，此方法同样适用于checkbox错乱等问题。</p><h2 id="demo工程已上传至github，有需要的可去download"><a href="#demo工程已上传至github，有需要的可去download" class="headerlink" title="demo工程已上传至github，有需要的可去download"></a>demo工程已上传至github，有需要的可去<a href="https://github.com/dengyuaner/ListViewDemo" target="_blank" rel="noopener">download</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在日常开发中，ListView是我们常用的控件，也是遇到坑比较多的一个控件。在之前的项目中，有这样的一个布局需求，在ListView的item中包含有EditText，第一个问题就是焦点问题，会发现edittext获取不到焦点。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ListView" scheme="http://yoursite.com/tags/ListView/"/>
    
      <category term="EditText" scheme="http://yoursite.com/tags/EditText/"/>
    
  </entry>
  
  <entry>
    <title>表格筛选控件</title>
    <link href="http://yoursite.com/2018/04/15/grid/"/>
    <id>http://yoursite.com/2018/04/15/grid/</id>
    <published>2018-04-15T04:03:32.000Z</published>
    <updated>2018-04-15T05:44:24.966Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近在做一个ERP的项目，产品要求做一个类似京东，淘宝，伙伴云表格的筛选控件，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-3e460456985cbeac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="S70301-160019.jpg" title="">                </div>                <div class="image-caption">S70301-160019.jpg</div>            </figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;这个页面其实一个主页面的Activity，右滑弹出一个抽屉DrawerLayout，抽屉其实是一个fragment，我们主要的布局就在fragment里面。而这个筛选控件其中的一个其实是下拉菜单。当然原生的spinner太丑而且不符合要求，所以我用一个LinearLayout包含一个TextView（drawableRight下拉图标），加一个listview来构造。</p><h2 id="行动代码"><a href="#行动代码" class="headerlink" title="行动代码"></a>行动代码</h2><p>&emsp;&emsp;思路有了，接下来就是代码行动了，首先我们封装这个控件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br></pre></td><td class="code"><pre><span class="line">public class MySpinnerView extends LinearLayout implements MySpinnerAdapter.RadioButtonClick &#123;</span><br><span class="line">    //用于下拉图标的动画</span><br><span class="line">    private static final int MAX_LEVEL = 10000;</span><br><span class="line"></span><br><span class="line">    //用于状态保存</span><br><span class="line">    private static final String INSTANCE_STATE = &quot;instance_state&quot;;</span><br><span class="line">    private static final String SELECTED_INDEX = &quot;selected_index&quot;;</span><br><span class="line">    private static final String IS_POPUP_SHOWING = &quot;is_popup_showing&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int selectedIndex;//选中的位置</span><br><span class="line">    private Drawable drawable;//下拉图标</span><br><span class="line">    private ListView listView;</span><br><span class="line">    private MySpinnerAdapter adapter;//用于listview的adapter</span><br><span class="line">    private AdapterView.OnItemClickListener onItemClickListener;</span><br><span class="line">    private AdapterView.OnItemSelectedListener onItemSelectedListener;</span><br><span class="line">    private boolean isArrowHide, isShowing;//是否显示</span><br><span class="line">    private int textColor;</span><br><span class="line">    private int backgroundSelector;//选中颜色</span><br><span class="line">    private int datasId;</span><br><span class="line">    private TextView titleView;//title</span><br><span class="line"></span><br><span class="line">    private String titleText;</span><br><span class="line">    private int defaultPadding;//默认padding</span><br><span class="line">    private List&lt;FilterDataItem&gt; mFilterDataItems;//筛选的数据源</span><br><span class="line">    private String startDate, endDate;</span><br><span class="line">    private int lastPos = -1;//保存最近一次选中的位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MySpinnerView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        getAttrs(context, null);</span><br><span class="line">        init(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MySpinnerView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        getAttrs(context, attrs);</span><br><span class="line">        init(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MySpinnerView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        getAttrs(context, attrs);</span><br><span class="line">        init(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Parcelable onSaveInstanceState() &#123;</span><br><span class="line">        Bundle bundle = new Bundle();</span><br><span class="line">        bundle.putParcelable(INSTANCE_STATE, super.onSaveInstanceState());</span><br><span class="line">        bundle.putInt(SELECTED_INDEX, selectedIndex);</span><br><span class="line">        bundle.putBoolean(IS_POPUP_SHOWING, isShowing);</span><br><span class="line">        dismissDropDown();</span><br><span class="line"></span><br><span class="line">        return bundle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onRestoreInstanceState(Parcelable savedState) &#123;</span><br><span class="line">        if (savedState instanceof Bundle) &#123;</span><br><span class="line">            Bundle bundle = (Bundle) savedState;</span><br><span class="line">            selectedIndex = bundle.getInt(SELECTED_INDEX);</span><br><span class="line"></span><br><span class="line">            if (adapter != null) &#123;</span><br><span class="line">                setTitle(selectedIndex);</span><br><span class="line"></span><br><span class="line">                // adapter.notifyItemSelected(selectedIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bundle.getBoolean(IS_POPUP_SHOWING)) &#123;</span><br><span class="line">                if (isShowing) &#123;</span><br><span class="line">                    post(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            showDropDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            savedState = bundle.getParcelable(INSTANCE_STATE);</span><br><span class="line">        &#125;</span><br><span class="line">        super.onRestoreInstanceState(savedState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取相关属性attr</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param attrs</span><br><span class="line">     */</span><br><span class="line">    private void getAttrs(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">        // 通过这个方法，将你在attrs.xml中定义的declare=styleable</span><br><span class="line">        // 的所有属性的值存储到TypedArray中</span><br><span class="line">        TypedArray ta = context.obtainStyledAttributes(attrs,</span><br><span class="line">                R.styleable.MySpinnerView);</span><br><span class="line">        // 从TypedArray中取出对应的值来为要设置的属性赋值</span><br><span class="line">        titleText = ta.getString(R.styleable.MySpinnerView_msv_title);</span><br><span class="line">        datasId = ta.getResourceId(R.styleable.MySpinnerView_msv_array, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        defaultPadding = getResources().getDimensionPixelSize(R.dimen.one_and_a_half_grid_unit);</span><br><span class="line"></span><br><span class="line">        setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);</span><br><span class="line">//        setPadding(getResources().getDimensionPixelSize(R.dimen.three_grid_unit), defaultPadding, defaultPadding,</span><br><span class="line">//                defaultPadding);</span><br><span class="line">        setClickable(true);</span><br><span class="line"></span><br><span class="line">        backgroundSelector = ta.getResourceId(R.styleable.MySpinnerView_msv_backgroundSelector,</span><br><span class="line">                R.drawable.spinner_selector);</span><br><span class="line"></span><br><span class="line">        textColor = ta.getColor(R.styleable.MySpinnerView_msv_textTint, -1);</span><br><span class="line">        isShowing = ta.getBoolean(R.styleable.MySpinnerView_msv_isShow, false);</span><br><span class="line"></span><br><span class="line">        isArrowHide = ta.getBoolean(R.styleable.MySpinnerView_msv_hideArrow, false);</span><br><span class="line">        if (!isArrowHide) &#123;</span><br><span class="line">            //不隐藏则显示图标</span><br><span class="line">            Drawable basicDrawable = ContextCompat.getDrawable(context, R.drawable.spinner_arrow);</span><br><span class="line">            int resId = ta.getColor(R.styleable.MySpinnerView_msv_arrowTint, -1);</span><br><span class="line">            if (basicDrawable != null) &#123;</span><br><span class="line">                drawable = DrawableCompat.wrap(basicDrawable);</span><br><span class="line">                if (resId != -1) &#123;</span><br><span class="line">                    DrawableCompat.setTint(drawable, resId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init(final Context context, AttributeSet attrs) &#123;</span><br><span class="line">        setOrientation(VERTICAL);</span><br><span class="line"></span><br><span class="line">        titleView = new TextView(context);</span><br><span class="line">        titleView.setText(titleText);</span><br><span class="line">        titleView.setPadding(defaultPadding, defaultPadding, defaultPadding, defaultPadding);</span><br><span class="line">        if (!isArrowHide) &#123;</span><br><span class="line">            titleView.setCompoundDrawablesWithIntrinsicBounds(null, null, drawable, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        listView = new ListViewInSrcollView(context);</span><br><span class="line"></span><br><span class="line">        listView.setId(getId());</span><br><span class="line">        listView.setDivider(null);</span><br><span class="line">        listView.setItemsCanFocus(true);</span><br><span class="line">        //隐藏scrollbars</span><br><span class="line">        listView.setVerticalScrollBarEnabled(false);</span><br><span class="line">        listView.setHorizontalScrollBarEnabled(false);</span><br><span class="line">        listView.setBackgroundResource(backgroundSelector);</span><br><span class="line">        //数据源，这里测试用的是assets中的json，开发者可自行构造bean和数据源</span><br><span class="line">        if (datasId != 0) &#123;</span><br><span class="line">            final String[] temp = getResources().getStringArray(datasId);</span><br><span class="line"></span><br><span class="line">            mFilterDataItems = new ArrayList&lt;&gt;();</span><br><span class="line">            for (String aTemp : temp) &#123;</span><br><span class="line">                mFilterDataItems.add(new FilterDataItem(0, aTemp, false));</span><br><span class="line">            &#125;</span><br><span class="line">            adapter = new MySpinnerAdapter(mFilterDataItems, this);</span><br><span class="line">            setAdapterInternal(adapter);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;</span><br><span class="line"></span><br><span class="line">                spinnerClick(position);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        addView(titleView);</span><br><span class="line">        addView(listView);</span><br><span class="line">        if (isShowing) &#123;</span><br><span class="line">            listView.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            listView.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前选中的位置</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int getSelectedIndex() &#123;</span><br><span class="line">        return selectedIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置当前选中位置</span><br><span class="line">     *</span><br><span class="line">     * @param position 位置</span><br><span class="line">     */</span><br><span class="line">    public void setSelectedIndex(int position) &#123;</span><br><span class="line">        if (adapter != null) &#123;</span><br><span class="line">            if (position &gt;= 0 &amp;&amp; position &lt;= adapter.getCount()) &#123;</span><br><span class="line"></span><br><span class="line">                //adapter.notifyItemSelected(position);</span><br><span class="line">                selectedIndex = position;</span><br><span class="line">                setTitle(position);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Position must be lower than adapter count!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addOnItemClickListener(@NonNull AdapterView.OnItemClickListener onItemClickListener) &#123;</span><br><span class="line">        this.onItemClickListener = onItemClickListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOnItemSelectedListener(@NonNull AdapterView.OnItemSelectedListener onItemSelectedListener) &#123;</span><br><span class="line">        this.onItemSelectedListener = onItemSelectedListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置adapter</span><br><span class="line">     *</span><br><span class="line">     * @param adapter</span><br><span class="line">     */</span><br><span class="line">    private void setAdapterInternal(MySpinnerAdapter adapter) &#123;</span><br><span class="line">        // If the adapter needs to be settled again, ensure to reset the selected index as well</span><br><span class="line">        //selectedIndex = 0;</span><br><span class="line">        listView.setAdapter(adapter);</span><br><span class="line">        //setTitle(selectedIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置adapter</span><br><span class="line">     *</span><br><span class="line">     * @param filterDataItems 数据源</span><br><span class="line">     */</span><br><span class="line">    public void setAdapter(List&lt;FilterDataItem&gt; filterDataItems) &#123;</span><br><span class="line">        this.mFilterDataItems = filterDataItems;</span><br><span class="line">        this.adapter = new MySpinnerAdapter(filterDataItems, this);</span><br><span class="line">        setAdapterInternal(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(@NonNull MotionEvent event) &#123;</span><br><span class="line">        if (event.getAction() == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            if (!isShowing) &#123;</span><br><span class="line">                showDropDown();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dismissDropDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 点击动画效果</span><br><span class="line">     *</span><br><span class="line">     * @param shouldRotateUp</span><br><span class="line">     */</span><br><span class="line">    private void animateArrow(boolean shouldRotateUp) &#123;</span><br><span class="line">        int start = shouldRotateUp ? 0 : MAX_LEVEL;</span><br><span class="line">        int end = shouldRotateUp ? MAX_LEVEL : 0;</span><br><span class="line">        ObjectAnimator animator = ObjectAnimator.ofInt(drawable, &quot;level&quot;, start, end);</span><br><span class="line">        animator.setInterpolator(new LinearOutSlowInInterpolator());</span><br><span class="line">        animator.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 隐藏</span><br><span class="line">     */</span><br><span class="line">    public void dismissDropDown() &#123;</span><br><span class="line">        if (!isArrowHide) &#123;</span><br><span class="line">            animateArrow(false);</span><br><span class="line">        &#125;</span><br><span class="line">        listView.setVisibility(View.GONE);</span><br><span class="line">        isShowing = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 展开</span><br><span class="line">     */</span><br><span class="line">    public void showDropDown() &#123;</span><br><span class="line">        if (!isArrowHide) &#123;</span><br><span class="line">            animateArrow(true);</span><br><span class="line">        &#125;</span><br><span class="line">        listView.setVisibility(View.VISIBLE);</span><br><span class="line">        isShowing = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTintColor(@ColorRes int resId) &#123;</span><br><span class="line">        if (drawable != null &amp;&amp; !isArrowHide) &#123;</span><br><span class="line">            DrawableCompat.setTint(drawable, ContextCompat.getColor(getContext(), resId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(int position) &#123;</span><br><span class="line">        String text = null;</span><br><span class="line">        lastPos = position;</span><br><span class="line">        if (adapter.getItem(position) instanceof String) &#123;</span><br><span class="line">            text = titleText + &quot;&lt;font color=\&quot;red\&quot;&gt; &quot; +</span><br><span class="line">                    &quot;(&quot; + adapter.getItem(position).toString() + &quot;)&quot; + &quot;&lt;/font&gt;&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (adapter.getItem(position) instanceof FilterDataItem) &#123;</span><br><span class="line">            FilterDataItem bean = (FilterDataItem) adapter.getItem(position);</span><br><span class="line">            text = titleText + &quot;&lt;font color=\&quot;#3b597b\&quot;&gt; &quot; +</span><br><span class="line">                    &quot;(&quot; + bean.getName() + &quot;)&quot; + &quot;&lt;/font&gt;&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        titleView.setText(Html.fromHtml(text));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取选中的数据源</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public FilterDataItem getSelectedData() &#123;</span><br><span class="line">        if (selectedIndex &gt;= 8) &#123;</span><br><span class="line">            FilterDataItem item = new FilterDataItem();</span><br><span class="line">            item.setName(startDate + &quot;|&quot; + endDate);</span><br><span class="line">            item.setId(-5);</span><br><span class="line">            if (TextUtils.isEmpty(startDate)</span><br><span class="line">                    || TextUtils.isEmpty(endDate)) &#123;</span><br><span class="line">                item.setChecked(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                item.setChecked(true);</span><br><span class="line">            &#125;</span><br><span class="line">            return item;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mFilterDataItems.get(selectedIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void click(int position) &#123;</span><br><span class="line">        spinnerClick(position);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 点击方法</span><br><span class="line">     *</span><br><span class="line">     * @param position</span><br><span class="line">     */</span><br><span class="line">    private void spinnerClick(int position) &#123;</span><br><span class="line">        final FilterDataItem bean = mFilterDataItems.get(position);</span><br><span class="line">        System.out.println(&quot;点击的位置&quot; + position);</span><br><span class="line">        if (!bean.isChecked()) &#123;</span><br><span class="line">            //更改点击状态</span><br><span class="line">            bean.setChecked(true);</span><br><span class="line"></span><br><span class="line">            //把最近的已经设为true的变为false</span><br><span class="line">            if (lastPos != -1) &#123;</span><br><span class="line">                FilterDataItem item = mFilterDataItems.get(lastPos);</span><br><span class="line">                item.setChecked(false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        selectedIndex = position;</span><br><span class="line"></span><br><span class="line">        final int tempPos = position;</span><br><span class="line">        if (bean.getName().contains(&quot;时间&quot;)) &#123;</span><br><span class="line">            Calendar c = Calendar.getInstance();</span><br><span class="line">            // 直接创建一个DatePickerDialog对话框实例，并将它显示出来</span><br><span class="line">            new DatePickerDialog(getContext(),</span><br><span class="line">                    // 绑定监听器</span><br><span class="line">                    new DatePickerDialog.OnDateSetListener() &#123;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void onDateSet(DatePicker view, int year,</span><br><span class="line">                                              int monthOfYear, int dayOfMonth) &#123;</span><br><span class="line">                            if (bean.getName().contains(&quot;开始时间&quot;)) &#123;</span><br><span class="line">                                startDate = year + &quot;.&quot; + (monthOfYear + 1)</span><br><span class="line">                                        + &quot;.&quot; + dayOfMonth;</span><br><span class="line">                                bean.setName(&quot;开始时间  &quot; + startDate);</span><br><span class="line"></span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                endDate = year + &quot;.&quot; + (monthOfYear + 1)</span><br><span class="line">                                        + &quot;.&quot; + dayOfMonth;</span><br><span class="line">                                bean.setName(&quot;结束时间  &quot; + endDate);</span><br><span class="line">                            &#125;</span><br><span class="line">                            adapter.notifyDataSetChanged();</span><br><span class="line">                            setTitle(tempPos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 设置初始日期</span><br><span class="line">                    , c.get(Calendar.YEAR), c.get(Calendar.MONTH), c</span><br><span class="line">                    .get(Calendar.DAY_OF_MONTH)).show();</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            postDelayed(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    dismissDropDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 500);</span><br><span class="line">            adapter.notifyDataSetChanged();</span><br><span class="line">            setTitle(position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="然后就是在fragment的布局文件中引入它fragment-filter-xml"><a href="#然后就是在fragment的布局文件中引入它fragment-filter-xml" class="headerlink" title="然后就是在fragment的布局文件中引入它fragment_filter.xml"></a>然后就是在fragment的布局文件中引入它fragment_filter.xml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">              xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">              android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;match_parent&quot;</span><br><span class="line">              android:background=&quot;@color/white&quot;</span><br><span class="line">              android:orientation=&quot;vertical&quot;</span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot;&gt;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">            android:text=&quot;@string/filter&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tvEnsure&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_alignParentRight=&quot;true&quot;</span><br><span class="line">            android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">            android:layout_marginRight=&quot;10dp&quot;</span><br><span class="line">            android:background=&quot;@drawable/corner_btn&quot;</span><br><span class="line">            android:padding=&quot;5dp&quot;</span><br><span class="line">            android:text=&quot;@string/ensure&quot;</span><br><span class="line">            android:textColor=&quot;@color/white&quot;/&gt;</span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ScrollView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;com.dy.filter.MySpinnerView</span><br><span class="line">                android:id=&quot;@+id/groupView&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                app:msv_backgroundSelector=&quot;@color/radio_bg&quot;</span><br><span class="line">                app:msv_isShow=&quot;false&quot;</span><br><span class="line">                app:msv_title=&quot;对象&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;com.dy.filter.MySpinnerView</span><br><span class="line">                android:id=&quot;@+id/exponentView&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                app:msv_backgroundSelector=&quot;@color/radio_bg&quot;</span><br><span class="line">                app:msv_isShow=&quot;false&quot;</span><br><span class="line">                app:msv_title=&quot;指数&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;com.dy.filter.MySpinnerView</span><br><span class="line">                android:id=&quot;@+id/timeView&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                app:msv_backgroundSelector=&quot;@color/radio_bg&quot;</span><br><span class="line">                app:msv_isShow=&quot;false&quot;</span><br><span class="line">                app:msv_title=&quot;查询时间&quot;/&gt;</span><br><span class="line">        &lt;/LinearLayout&gt;</span><br><span class="line">    &lt;/ScrollView&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="最后上activity的布局文件，就是一个drawerlayout"><a href="#最后上activity的布局文件，就是一个drawerlayout" class="headerlink" title="最后上activity的布局文件，就是一个drawerlayout"></a>最后上activity的布局文件，就是一个drawerlayout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:id=&quot;@+id/drawer_layout&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RelativeLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:background=&quot;@color/blue&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id=&quot;@+id/tvBack&quot;</span><br><span class="line">                android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">                android:layout_marginLeft=&quot;10dp&quot;</span><br><span class="line">                android:text=&quot;返回&quot;</span><br><span class="line">                android:textColor=&quot;@color/white&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id=&quot;@+id/tvFilterExponent&quot;</span><br><span class="line">                android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">                android:textColor=&quot;@color/white&quot;</span><br><span class="line">                tools:text=&quot;订单金额&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id=&quot;@+id/tvFilter&quot;</span><br><span class="line">                android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_alignParentRight=&quot;true&quot;</span><br><span class="line">                android:layout_margin=&quot;10dp&quot;</span><br><span class="line">                android:drawableLeft=&quot;@drawable/ic_action_select&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:text=&quot;筛选&quot;</span><br><span class="line">                android:textColor=&quot;@color/white&quot;/&gt;</span><br><span class="line">        &lt;/RelativeLayout&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">    &lt;!-- 抽屉内容 --&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=&quot;@+id/drawer_content&quot;</span><br><span class="line">        android:layout_width=&quot;280dp&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_gravity=&quot;end&quot;</span><br><span class="line">        android:clickable=&quot;true&quot;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="上效果图"><a href="#上效果图" class="headerlink" title="上效果图"></a>上效果图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-13e943e00acdc5f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="123.jpg" title="">                </div>                <div class="image-caption">123.jpg</div>            </figure><h2 id="最后上demo地址，点击github"><a href="#最后上demo地址，点击github" class="headerlink" title="最后上demo地址，点击github"></a>最后上demo地址，<a href="https://github.com/dengyuaner/FilterDemo" target="_blank" rel="noopener">点击github</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近在做一个ERP的项目，产品要求做一个类似京东，淘宝，伙伴云表格的筛选控件，如下图所示：&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
  
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/04/14/hello-world/"/>
    <id>http://yoursite.com/2018/04/14/hello-world/</id>
    <published>2018-04-14T13:23:41.917Z</published>
    <updated>2018-04-14T15:58:58.848Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
