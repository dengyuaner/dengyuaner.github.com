<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>又尔enter的blog</title>
  
  <subtitle>Android开发工程师（4年）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dyenter.top/"/>
  <updated>2018-04-23T09:56:38.175Z</updated>
  <id>https://www.dyenter.top/</id>
  
  <author>
    <name>又尔enter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android加载大图——BitmapRegionDecoder</title>
    <link href="https://www.dyenter.top/2018/04/23/bitmapregion/"/>
    <id>https://www.dyenter.top/2018/04/23/bitmapregion/</id>
    <published>2018-04-23T09:55:28.000Z</published>
    <updated>2018-04-23T09:56:38.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Android开发中，加载图片是很常见的情况，我们一般选择传统的加载图片框架如universalimageloader，picasso，fresco等。最近群里有个朋友说，面试遇到一个面试官说加载巨图怎么解决，就是一个图片很大，比如清明上河图，世界地图等，一个屏幕显示不完，又不能缩小，压缩，该怎么解决。</p><p>像这种情况当然是查官方文档了，其实android早就给我们解决方案——BitmapRegionDecoder，从API10就引入了。如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-41ee176e3ad6ba0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NPONRY0T35GE$13{254X8Z1.png" title="">                </div>                <div class="image-caption">NPONRY0T35GE$13{254X8Z1.png</div>            </figure></p><p>看官方文档的说明，这个类就是用来显示指定区域的图像，当原始图像大，你只需要部分图像时，BitmapRegionDecoder特别有用。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="说了这么多，我们来看看怎么使用它吧"><a href="#说了这么多，我们来看看怎么使用它吧" class="headerlink" title="说了这么多，我们来看看怎么使用它吧"></a>说了这么多，我们来看看怎么使用它吧</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-92279a73b5060de9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="J1_7H5)MI{M2PV{){{3V97V.png" title="">                </div>                <div class="image-caption">J1_7H5)MI{M2PV{){{3V97V.png</div>            </figure><h3 id="最主要的就是BitmapRegionDecode-newInstance-…-获取一个对象，然后通过这个对象去调用decodeRegion（…）得到bitmap，最后就可以显示在屏幕上了。考虑到用户可以触摸移动图像，我们用手势控制器GestureDetector来控制图片显示的区域。"><a href="#最主要的就是BitmapRegionDecode-newInstance-…-获取一个对象，然后通过这个对象去调用decodeRegion（…）得到bitmap，最后就可以显示在屏幕上了。考虑到用户可以触摸移动图像，我们用手势控制器GestureDetector来控制图片显示的区域。" class="headerlink" title="最主要的就是BitmapRegionDecode.newInstance(…)获取一个对象，然后通过这个对象去调用decodeRegion（…）得到bitmap，最后就可以显示在屏幕上了。考虑到用户可以触摸移动图像，我们用手势控制器GestureDetector来控制图片显示的区域。"></a>最主要的就是BitmapRegionDecode.newInstance(…)获取一个对象，然后通过这个对象去调用decodeRegion（…）得到bitmap，最后就可以显示在屏幕上了。考虑到用户可以触摸移动图像，我们用手势控制器GestureDetector来控制图片显示的区域。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line">public class LargeImageView extends View implements GestureDetector.OnGestureListener &#123;</span><br><span class="line">    private static final String TAG = &quot;LargeImageView&quot;;</span><br><span class="line"></span><br><span class="line">    private BitmapRegionDecoder mDecoder;</span><br><span class="line"></span><br><span class="line">    //绘制的区域</span><br><span class="line">    private volatile Rect mRect = new Rect();</span><br><span class="line"></span><br><span class="line">    private int mScaledTouchSlop;</span><br><span class="line"></span><br><span class="line">    // 分别记录上次滑动的坐标</span><br><span class="line">    private int mLastX = 0;</span><br><span class="line">    private int mLastY = 0;</span><br><span class="line"></span><br><span class="line">    //图片的宽度和高度</span><br><span class="line">    private int mImageWidth, mImageHeight;</span><br><span class="line">   //手势控制器</span><br><span class="line">    private GestureDetector mGestureDetector;</span><br><span class="line">    private BitmapFactory.Options options;</span><br><span class="line"></span><br><span class="line">    public LargeImageView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LargeImageView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LargeImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        //设置显示图片的参数，如果对图片质量有要求，就选择ARGB_8888模式</span><br><span class="line">        options = new BitmapFactory.Options();</span><br><span class="line">        options.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mScaledTouchSlop = ViewConfiguration.get(getContext())</span><br><span class="line">                .getScaledTouchSlop();</span><br><span class="line">        Log.d(TAG, &quot;sts:&quot; + mScaledTouchSlop);</span><br><span class="line">        //初始化手势控制器</span><br><span class="line">        mGestureDetector = new GestureDetector(context, this);</span><br><span class="line"></span><br><span class="line">        //获取图片的宽高</span><br><span class="line">        InputStream is = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            is = context.getResources().getAssets().open(&quot;timg.jpg&quot;);</span><br><span class="line">            //初始化BitmapRegionDecode，并用它来显示图片</span><br><span class="line">            mDecoder = BitmapRegionDecoder</span><br><span class="line">                    .newInstance(is, false);</span><br><span class="line">            BitmapFactory.Options tmpOptions = new BitmapFactory.Options();</span><br><span class="line">            // 设置为true则只获取图片的宽高等信息，不加载进内存</span><br><span class="line">            tmpOptions.inJustDecodeBounds = true;</span><br><span class="line">            BitmapFactory.decodeStream(is, null, tmpOptions);</span><br><span class="line">            mImageWidth = tmpOptions.outWidth;</span><br><span class="line">            mImageHeight = tmpOptions.outHeight;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (is != null) &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        //把触摸事件交给手势控制器处理</span><br><span class="line">        return mGestureDetector.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onDown(MotionEvent e) &#123;</span><br><span class="line">        mLastX = (int) e.getRawX();</span><br><span class="line">        mLastY = (int) e.getRawY();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onShowPress(MotionEvent e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onSingleTapUp(MotionEvent e) &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</span><br><span class="line">        int x = (int) e2.getRawX();</span><br><span class="line">        int y = (int) e2.getRawY();</span><br><span class="line">        move(x, y);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移动的时候更新图片显示的区域</span><br><span class="line">     *</span><br><span class="line">     * @param x</span><br><span class="line">     * @param y</span><br><span class="line">     */</span><br><span class="line">    private void move(int x, int y) &#123;</span><br><span class="line">        int deltaX = x - mLastX;</span><br><span class="line">        int deltaY = y - mLastY;</span><br><span class="line">        Log.d(TAG, &quot;move, deltaX:&quot; + deltaX + &quot; deltaY:&quot; + deltaY);</span><br><span class="line">        //如果图片宽度大于屏幕宽度</span><br><span class="line">        if (mImageWidth &gt; getWidth()) &#123;</span><br><span class="line">            //移动rect区域</span><br><span class="line">            mRect.offset(-deltaX, 0);</span><br><span class="line">            //检查是否到达图片最右端</span><br><span class="line">            if (mRect.right &gt; mImageWidth) &#123;</span><br><span class="line">                mRect.right = mImageWidth;</span><br><span class="line">                mRect.left = mImageWidth - getWidth();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //检查左端</span><br><span class="line">            if (mRect.left &lt; 0) &#123;</span><br><span class="line">                mRect.left = 0;</span><br><span class="line">                mRect.right = getWidth();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        //如果图片高度大于屏幕高度</span><br><span class="line">        if (mImageHeight &gt; getHeight()) &#123;</span><br><span class="line">            mRect.offset(0, -deltaY);</span><br><span class="line"></span><br><span class="line">            //是否到达最底部</span><br><span class="line">            if (mRect.bottom &gt; mImageHeight) &#123;</span><br><span class="line">                mRect.bottom = mImageHeight;</span><br><span class="line">                mRect.top = mImageHeight - getHeight();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mRect.top &lt; 0) &#123;</span><br><span class="line">                mRect.top = 0;</span><br><span class="line">                mRect.bottom = getHeight();</span><br><span class="line">            &#125;</span><br><span class="line">            //重绘</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLongPress(MotionEvent e) &#123;</span><br><span class="line">        mLastX = (int) e.getRawX();</span><br><span class="line">        mLastY = (int) e.getRawY();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</span><br><span class="line">        int x = (int) e2.getRawX();</span><br><span class="line">        int y = (int) e2.getRawY();</span><br><span class="line">        move(x, y);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        //显示图片</span><br><span class="line">        Bitmap bm = mDecoder.decodeRegion(mRect, options);</span><br><span class="line">        canvas.drawBitmap(bm, 0, 0, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int width = getMeasuredWidth();</span><br><span class="line">        int height = getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">        int imageWidth = mImageWidth;</span><br><span class="line">        int imageHeight = mImageHeight;</span><br><span class="line"></span><br><span class="line">        //默认显示图片的中心区域，开发者可自行选择</span><br><span class="line">        mRect.left = imageWidth / 2 - width / 2;</span><br><span class="line">        mRect.top = imageHeight / 2 - height / 2;</span><br><span class="line">        mRect.right = mRect.left + width;</span><br><span class="line">        mRect.bottom = mRect.top + height;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码详见我的github"><a href="#完整代码详见我的github" class="headerlink" title="完整代码详见我的github"></a>完整代码详见我的<a href="https://github.com/dengyuaner/LargeImageDemo" target="_blank" rel="noopener">github</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Android开发中，加载图片是很常见的情况，我们一般选择传统的加载图片框架如universalimageloader，picasso，f
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="Bitmap" scheme="https://www.dyenter.top/tags/Bitmap/"/>
    
      <category term="大图" scheme="https://www.dyenter.top/tags/%E5%A4%A7%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程基础——线程模型</title>
    <link href="https://www.dyenter.top/2018/04/23/javathread1/"/>
    <id>https://www.dyenter.top/2018/04/23/javathread1/</id>
    <published>2018-04-23T09:49:31.000Z</published>
    <updated>2018-04-23T09:50:43.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;在Android应用开发中，由于Android系统的单线程模型（UI主线程），使得一些耗时操作必须放在子线程执行；又由于线程间需要交互信息，在多线程环境中，需要做好同步操作，以防止不可预期的错误发生。因此，掌握多线程相关知识对于开发尤为重要。比如在我们常用的Okhttp，Rxjava等框架中都可以看见多线程的身影（ThreadPoolExecutor）</p><h3 id="硬件概述"><a href="#硬件概述" class="headerlink" title="硬件概述"></a>硬件概述</h3><p>&emsp;&emsp;由于计算机的存储设备（IO）与处理器（CPU）的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。<br>&emsp;&emsp;基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的，后续将介绍Java内存模型。<br>&emsp;&emsp;除此之外，为了使得处理器内部的运算单元能竟可能被充分利用，处理器可能会对输入代码进行乱起执行（Out-Of-Order Execution）优化，处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果准确性。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Recorder）优化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-33963eb9b2f803ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="model_cache.png" title="">                </div>                <div class="image-caption">model_cache.png</div>            </figure><br><strong>现代计算机设备可能不止有一级缓存，可能还有二级，三级缓存，一般CPU读取数据的优先级是寄存器（register）-&gt;高速缓存（一级，二级，三级等待）-&gt;主内存</strong></p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>&emsp;&emsp;Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。 Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-986dfc52d7709a7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java_thread.png" title="">                </div>                <div class="image-caption">java_thread.png</div>            </figure></p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>&emsp;&emsp;关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">·lock（锁定）：  作用于主内存的变量，把一个变量标识为一条线程独占状态。</span><br><span class="line">·unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</span><br><span class="line">·read（读取）：  作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</span><br><span class="line">·load（载入）：  作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</span><br><span class="line">·use（使用）：   作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</span><br><span class="line">·assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</span><br><span class="line">·store（存储）： 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</span><br><span class="line">·write（写入）： 作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">·不允许read和load、store和write操作之一单独出现</span><br><span class="line">·不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</span><br><span class="line">·不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</span><br><span class="line">·一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</span><br><span class="line">·一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现</span><br><span class="line">·如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</span><br><span class="line">·如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</span><br><span class="line">·对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</span><br></pre></td></tr></table></figure></p><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>&emsp;&emsp;在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">·编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</span><br><span class="line">·指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</span><br><span class="line">·内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</span><br></pre></td></tr></table></figure></p><h2 id="同步关键字"><a href="#同步关键字" class="headerlink" title="同步关键字"></a>同步关键字</h2><p>Java提供了volatile和synchronized来保证同步</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>禁止指令重排序，保证内存可见性，但不保证原子性。仅作用于变量。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>禁止指令重排序，保证内存可见性，保证原子性。作用于方法，代码块。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>由Java内存模型来直接保证的原子性变量包括read,load,assign,use,store,write,我们大致可以认为基本数据类型的访问读写是具备原子性的(long，double除外)</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile就是这个作用。<br>除了vloatile外，Java还有synchronized和final能保证可见性。同步块的可见性是由”对一个变量执行unlock操作之前，必须先把次变量同步回主内存中”这条规则获得的，而final的可见性是指：被final修饰的字段在构造其中一旦初始化完成，并且构造器没有把this的引用传递出去（this引用逃逸是一件很危险的事，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final的值。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无需的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p><h2 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h2><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程即可以共享进程资源（内存地址、文件I/O等），又可以独立调度(线程是CPU调度的基本单位)。<br>实现线程主要有3中方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>一对一线程模型 ，内核线程(Kernel-Level Thread,KLT)是直接有操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器(Scheduler)对线程进行调度，并负责将线程的任务映射带各个处理器上。<br>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程间1:1的关系称为一对一的线程模型，如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-dd53033dc641f585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kernel_thread.png" title="">                </div>                <div class="image-caption">kernel_thread.png</div>            </figure><br><strong>优点：</strong>每个轻量级进程都成为一个独立的调度单元，即使其中一个在系统调用中阻塞了，也不会影响整个进程工作。<br><strong>缺点：</strong>由于是基于内核线程实现的，所以各种线程操作，如创建，析构和同步，都需要进行系统调用。而系统调用的代价高昂，需要在用户态（User Mode）和内核态（Kernel Mode）来回切换。其次</p><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>一对N线程模型 ，用户程序完全模拟线程的行为，编码时操作的线程是用户程序模拟的线程，操作系统内核不能感知你做了创建、调度等等线程操作。许多编程语言最初使用过这种方式，但现在基本放弃了这种。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-185a9e8e512a26d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="userthread.png" title="">                </div>                <div class="image-caption">userthread.png</div>            </figure></p><h3 id="用户线程加轻量级进程混合实现"><a href="#用户线程加轻量级进程混合实现" class="headerlink" title="用户线程加轻量级进程混合实现"></a>用户线程加轻量级进程混合实现</h3><p>N对M线程模型 ，也有很多语言使用混合实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-267e7becba111a7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hybrid.png" title="">                </div>                <div class="image-caption">hybrid.png</div>            </figure></p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>线程调度是指系统为线程分配处理器使用权的过程，主要的调度方式有两种：</p><h3 id="协同式线程调度（Cooperative-Threads-Scheduling）"><a href="#协同式线程调度（Cooperative-Threads-Scheduling）" class="headerlink" title="协同式线程调度（Cooperative Threads-Scheduling）"></a>协同式线程调度（Cooperative Threads-Scheduling）</h3><p>这种方式是原始方式，由一个线程执行完通知另一个线程。已经很少使用，很容易造成阻塞。</p><h3 id="抢占式线程调度（Preemptive-Threads-Scheduling）"><a href="#抢占式线程调度（Preemptive-Threads-Scheduling）" class="headerlink" title="抢占式线程调度（Preemptive Threads-Scheduling）"></a>抢占式线程调度（Preemptive Threads-Scheduling）</h3><p>主流方式，由系统来根据一系列复杂的规则为每个线程分配执行时间，线程的切换不是由线程自己做主（Java可以有Thread.yield()来让出执行时间，但是没有获取执行时间的方式）。<br>Java语言一共设置了10个优先级（Thread.MIN_PRIORITY到Thread.MAX_PRIORITY，1-10，正常值是5）;在两个线程同时处于ready状态时，优先级越高的线程越容易被烯烃选择执行。<br>但是不要依赖优先级，因为它并不靠谱，最终结果仍取决于OS。比如Java有10种优先级，而linux优先级从-20-19，那怎么对应呢；比如windows有7中优先级。</p><h2 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h2><p>Java语言定义了5中线程状态，在任意一个时间点，一个线程只能有且只有一种状态，这5种状态如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">·新建(New): 创建后，尚未启动的线程</span><br><span class="line">·运行(Runnable): 包括了操作系统状态的Running和Ready，即此时线程可能运行，也可能CPU正在为它分配时间片，还没运行。</span><br><span class="line">·无限期等待(Waiting)：处于这种状态的线程不会被分配CPU执行时间，它们要等其他线程显示的唤醒。调用如下方法会时当前线程进入Waiting状态：</span><br><span class="line">        没有设置timeout的java.lang.Object#wait();</span><br><span class="line">        没有设置timeout的threadObj.join()/threadObj.join(0)方法</span><br><span class="line">        LockSupport.park()方法</span><br><span class="line">·限期等待：同上，只是设置了timeout，在时间到了后自动唤醒</span><br><span class="line">        java.lang.Object#wait(long);</span><br><span class="line">        java.lang.Thread#sleep(long);</span><br><span class="line">        threadObj.join(n)方法</span><br><span class="line">        LockSupport.parkNanos(obj ,n)方法</span><br><span class="line">        LockSupport.parkUntil(obj ,n)方法</span><br><span class="line">·阻塞(Blocked)：线程被阻塞了，阻塞与等待的区别是：阻塞状态在等待一个排它锁，这个时间在另外一个线程放弃这个所的时候发生；而等待则是等待一段时间，或者被唤醒。</span><br><span class="line">·结束(Terminated)：已终止的线程状态，线程已结束执行。</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-ef47ed57e6273f3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="state.png" title="">                </div>                <div class="image-caption">state.png</div>            </figure><p><strong>参考：深入理解Java虚拟机，作者：周志明</strong>，侵删。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在Android应用开发中，由于Android系统的单线程模型（UI主线程），使得一些耗时操作必须放在子线程执行；又
      
    
    </summary>
    
      <category term="Java" scheme="https://www.dyenter.top/categories/Java/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="Java" scheme="https://www.dyenter.top/tags/Java/"/>
    
      <category term="Thread" scheme="https://www.dyenter.top/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Android探索更新UI的方法（二）-更新UI的方式</title>
    <link href="https://www.dyenter.top/2018/04/21/freshui2/"/>
    <id>https://www.dyenter.top/2018/04/21/freshui2/</id>
    <published>2018-04-21T07:14:40.000Z</published>
    <updated>2018-04-21T07:20:37.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;<a href="https://www.dyenter.top/2018/04/19/freshui1/">前一章</a>我们讲了更新UI的时机，即Android是在哪一刻才更新UI的，了解Android更新UI的源码流程有助于我们了解其本质，在开发过程中出错也能更快的定位。当然看源码也要不求甚解，不要一头砸进去，毫无头绪，只需顺着一条主线，适可而止。像UI怎么显示到屏幕上的，实际App进程是把显示操作发给System_Server进程的WindowManagerService线程，让它去显示，中间通过Binder线程实现进程间交互。</p><h2 id="Android更新UI的几种方式"><a href="#Android更新UI的几种方式" class="headerlink" title="Android更新UI的几种方式"></a>Android更新UI的几种方式</h2><p>&emsp;&emsp;我们知道Android中有以下几种更新UI的方式，我们探讨的都是在非UI线程更新，下同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Handler sendMessage() or post();</span><br><span class="line">Activity runOnUiThread();</span><br><span class="line">View post()</span><br><span class="line">AsyncTask</span><br><span class="line">View其他相关用法</span><br></pre></td></tr></table></figure></p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>&emsp;&emsp;handler是最常用的，也是Android中最基本的方法，Android中所有的异步更新UI的本质都是用Handler。那么我们看一下sendMessage和post有什么区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessage(Message msg)</span><br><span class="line">&#123;</span><br><span class="line">        return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">&#123;</span><br><span class="line">        if (delayMillis &lt; 0) &#123;</span><br><span class="line">            delayMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            RuntimeException e = new RuntimeException(</span><br><span class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现最后调用的是sendMessageAtTime，这个方法里面吧Message加入到MessageQueue里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r)</span><br><span class="line">&#123;</span><br><span class="line">       return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实就是把Runnable包装成一个Message，即把Message的callback设置成Runnable，之后就会在主线程回调Runnable的run方法。就这么简单实现了UI的更新。</p><h2 id="runOnUiThread"><a href="#runOnUiThread" class="headerlink" title="runOnUiThread()"></a>runOnUiThread()</h2><p>&emsp;&emsp;runOnUiThread()是Activity的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// we must have a handler before the FragmentController is constructed</span><br><span class="line">final Handler mHandler = new Handler();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Runs the specified action on the UI thread. If the current thread is the UI</span><br><span class="line">     * thread, then the action is executed immediately. If the current thread is</span><br><span class="line">     * not the UI thread, the action is posted to the event queue of the UI thread.</span><br><span class="line">     *</span><br><span class="line">     * @param action the action to run on the UI thread</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public final void runOnUiThread(Runnable action) &#123;</span><br><span class="line">        if (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">            mHandler.post(action);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            action.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果是在主线程调用该方法，则跟没调用一样的，都是立即更新UI，调用Runnable的run方法；<br>&emsp;&emsp;如果实在子线程调用该方法，则通过handler.post()把它放进消息队列。<strong>所以这个方法的本质很简单，主线程立即更新，子线程通过handler放进MessageQueue</strong><br>&emsp;&emsp;注意mHandler是Activity里面的handler,mUiThread实在Activity的attach方法中赋值的，这个方法是由ActivityThread经过一系列方法调用的，所以这个是主线程。</p><h2 id="View-post"><a href="#View-post" class="headerlink" title="View post()"></a>View post()</h2><p>Android还提供这个View.post()方法来供我们更新UI，这个方法在View.java里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * &lt;p&gt;Causes the Runnable to be added to the message queue.</span><br><span class="line">     * The runnable will be run on the user interface thread.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param action The Runnable that will be executed.</span><br><span class="line">     *</span><br><span class="line">     * @return Returns true if the Runnable was successfully placed in to the</span><br><span class="line">     *         message queue.  Returns false on failure, usually because the</span><br><span class="line">     *         looper processing the message queue is exiting.</span><br><span class="line">     *</span><br><span class="line">     * @see #postDelayed</span><br><span class="line">     * @see #removeCallbacks</span><br><span class="line">     */</span><br><span class="line">    public boolean post(Runnable action) &#123;</span><br><span class="line">        final AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">        if (attachInfo != null) &#123;</span><br><span class="line">            return attachInfo.mHandler.post(action);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Postpone the runnable until we know on which thread it needs to run.</span><br><span class="line">        // Assume that the runnable will be successfully placed after attach.</span><br><span class="line">        getRunQueue().post(action);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;从注释可以知道，当attachInfo为空时，即这时候UI还没创建好，是吧Runnable添加到队列中；当attachInfo不为空时，它是把Runnable投递到主线程的消息队列，这里用的handler是mAttachInfo的handler，我们看一下它是在哪，什么时候创建的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    AttachInfo mAttachInfo;</span><br><span class="line">/**</span><br><span class="line">     * Queue of pending runnables. Used to postpone calls to post() until this</span><br><span class="line">     * view is attached and has a handler.</span><br><span class="line">     */</span><br><span class="line">    private HandlerActionQueue mRunQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * @param info the &#123;@link android.view.View.AttachInfo&#125; to associated with</span><br><span class="line">     *        this view</span><br><span class="line">     */</span><br><span class="line">    void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</span><br><span class="line">        mAttachInfo = info;</span><br><span class="line">        .....</span><br><span class="line">        // Transfer all pending runnables.</span><br><span class="line">        if (mRunQueue != null) &#123;</span><br><span class="line">            mRunQueue.executeActions(info.mHandler);</span><br><span class="line">            mRunQueue = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>dispatchAttachedToWindow()是在ViewRootImpl中调用的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.java</span><br><span class="line"></span><br><span class="line">private void performTraversals() &#123;</span><br><span class="line">        // cache mView since it is used so much below...</span><br><span class="line">        final View host = mView;</span><br><span class="line">        .....</span><br><span class="line">        if (mFirst) &#123;</span><br><span class="line">                host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        // Execute enqueued actions on every traversal in case a detached view enqueued an action</span><br><span class="line">        getRunQueue().executeActions(mAttachInfo.mHandler);</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mView是在setView()中赋值的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mView == null) &#123;</span><br><span class="line">                mView = view;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而setView是WindowManagerGlobal中调用的，关于WMS等的源码分析我们之后再讲，这里只需要重点关注View的mRunQueue，也就是在Activity启动的流程中，会把post的Runnable放到mRunQueue这个队列里，当view显示到屏幕上，会调用ViewRootImpl的performTraversals()，然后调用View的dispatchAttachedToWindow，然后执行mRunQueue里面的任务。<br>&emsp;&emsp;<strong>总结：当view没创建好时，先把任务添加到队列中，不会执行；只有当view创建完毕，显示到屏幕上时，才回去调用任务队列里面的任务</strong>，所以我们在onCreate(),onStart()等生命周期里面post的任务不会立即执行，有兴趣的童鞋可以去试一下。<br>&emsp;&emsp;接下来我们重点关注mRunQueue这个HandlerActionQueue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Class used to enqueue pending work from Views when no Handler is attached.</span><br><span class="line"> *</span><br><span class="line"> * @hide Exposed for test framework only.</span><br><span class="line"> */</span><br><span class="line">public class HandlerActionQueue &#123;</span><br><span class="line">    private HandlerAction[] mActions;</span><br><span class="line">    private int mCount;</span><br><span class="line"></span><br><span class="line">    public void post(Runnable action) &#123;</span><br><span class="line">        postDelayed(action, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void postDelayed(Runnable action, long delayMillis) &#123;</span><br><span class="line">        final HandlerAction handlerAction = new HandlerAction(action, delayMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mActions == null) &#123;</span><br><span class="line">                mActions = new HandlerAction[4];</span><br><span class="line">            &#125;</span><br><span class="line">            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);</span><br><span class="line">            mCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeCallbacks(Runnable action) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final int count = mCount;</span><br><span class="line">            int j = 0;</span><br><span class="line"></span><br><span class="line">            final HandlerAction[] actions = mActions;</span><br><span class="line">            for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                if (actions[i].matches(action)) &#123;</span><br><span class="line">                    // Remove this action by overwriting it within</span><br><span class="line">                    // this loop or nulling it out later.</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (j != i) &#123;</span><br><span class="line">                    // At least one previous entry was removed, so</span><br><span class="line">                    // this one needs to move to the &quot;new&quot; list.</span><br><span class="line">                    actions[j] = actions[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // The &quot;new&quot; list only has j entries.</span><br><span class="line">            mCount = j;</span><br><span class="line"></span><br><span class="line">            // Null out any remaining entries.</span><br><span class="line">            for (; j &lt; count; j++) &#123;</span><br><span class="line">                actions[j] = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void executeActions(Handler handler) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final HandlerAction[] actions = mActions;</span><br><span class="line">            for (int i = 0, count = mCount; i &lt; count; i++) &#123;</span><br><span class="line">                final HandlerAction handlerAction = actions[i];</span><br><span class="line">                handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mActions = null;</span><br><span class="line">            mCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return mCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Runnable getRunnable(int index) &#123;</span><br><span class="line">        if (index &gt;= mCount) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        return mActions[index].action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getDelay(int index) &#123;</span><br><span class="line">        if (index &gt;= mCount) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        return mActions[index].delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class HandlerAction &#123;</span><br><span class="line">        final Runnable action;</span><br><span class="line">        final long delay;</span><br><span class="line"></span><br><span class="line">        public HandlerAction(Runnable action, long delay) &#123;</span><br><span class="line">            this.action = action;</span><br><span class="line">            this.delay = delay;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean matches(Runnable otherAction) &#123;</span><br><span class="line">            return otherAction == null &amp;&amp; action == null</span><br><span class="line">                    || action != null &amp;&amp; action.equals(otherAction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它里面有个内部类HandlerAction，封装了Runnable，HandlerAction[]保存了任务，初始容量大小为4。可以看到post()方法就是把Runnable放进handlerAction数组里面，并没有执行，真正的执行在dispatchAttachedToWindow方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (mRunQueue != null) &#123;</span><br><span class="line">            mRunQueue.executeActions(info.mHandler);</span><br><span class="line">            mRunQueue = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void executeActions(Handler handler) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final HandlerAction[] actions = mActions;</span><br><span class="line">            for (int i = 0, count = mCount; i &lt; count; i++) &#123;</span><br><span class="line">                final HandlerAction handlerAction = actions[i];</span><br><span class="line">                handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mActions = null;</span><br><span class="line">            mCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行就是遍历HandlerAction数组，依次执行，这里的handler是AttachInfo的handler，它是ViewRootImpl中的ViewRootHandler，它也是继承Handler的。执行完毕后清空HandlerAction数组。</p><h3 id="view-post-时序图"><a href="#view-post-时序图" class="headerlink" title="view post 时序图"></a>view post 时序图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-2c3d90d4032190b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UML时序图.png" title="">                </div>                <div class="image-caption">UML时序图.png</div>            </figure><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask的原理其实也是用Handler更新UI的，它内部有一个InternalHandler sHandler；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">        public InternalHandler(Looper looper) &#123;</span><br><span class="line">            super(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case MESSAGE_POST_RESULT:</span><br><span class="line">                    // There is only one result</span><br><span class="line">                    result.mTask.finish(result.mData[0]);</span><br><span class="line">                    break;</span><br><span class="line">                case MESSAGE_POST_PROGRESS:</span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>注意它初始化Handler用的是主线程的Looper，sHandler = new InternalHandler(Looper.getMainLooper());关于AsyncTask的工作原理之后会讲到。</p><h2 id="View其他相关用法"><a href="#View其他相关用法" class="headerlink" title="View其他相关用法"></a>View其他相关用法</h2><h3 id="ViewTreeObserver"><a href="#ViewTreeObserver" class="headerlink" title="ViewTreeObserver"></a>ViewTreeObserver</h3><p>&emsp;&emsp;在开发中，通常有这样一种需求，我们需要获取View的宽高等信息，要获取这些信息必须等View完成measure后才能获取，可以用上面我们将的View的post获取，也可以用ViewTreeObserver设置监听来获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final ViewTreeObserver observer = surfaceView.getViewTreeObserver();</span><br><span class="line">ViewTreeObserver.OnGlobalLayoutListener layoutListener = new ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onGlobalLayout() &#123;</span><br><span class="line">        if (observer.isAlive()) &#123;</span><br><span class="line">            observer.removeGlobalOnLayoutListener(this);</span><br><span class="line">            //获取宽高 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">observer.addOnGlobalLayoutListener(layoutListener);</span><br></pre></td></tr></table></figure></p><p>它会在View的layout发生变化时调用，注意可能会多次调用，用过一次后最好移除监听，否则回调会多次执行，拿它是什么时候回调的呢，我们要再一次进入ViewRootImpl的performTravels()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ViewTreeObserver.java</span><br><span class="line"></span><br><span class="line">public final void dispatchOnGlobalLayout() &#123;</span><br><span class="line">        final CopyOnWriteArray&lt;OnGlobalLayoutListener&gt; listeners = mOnGlobalLayoutListeners;</span><br><span class="line">        if (listeners != null &amp;&amp; listeners.size() &gt; 0) &#123;</span><br><span class="line">            CopyOnWriteArray.Access&lt;OnGlobalLayoutListener&gt; access = listeners.start();</span><br><span class="line">            try &#123;</span><br><span class="line">                int count = access.size();</span><br><span class="line">                for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                    access.get(i).onGlobalLayout();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                listeners.end();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ViewRootImpl.java</span><br><span class="line"></span><br><span class="line">private void performTraversals() &#123;</span><br><span class="line">        .....</span><br><span class="line">        performMeasure();</span><br><span class="line">        .....</span><br><span class="line">        performLayout();</span><br><span class="line"></span><br><span class="line">        if (triggerGlobalLayoutListener) &#123;</span><br><span class="line">            mAttachInfo.mRecomputeGlobalAttributes = false;</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">        performDraw();</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当View完成测量，布局后，如果设置了监听，则回调。所以这也能正确的获取宽高。</p><h3 id="MessageQueue-IdleHandler"><a href="#MessageQueue-IdleHandler" class="headerlink" title="MessageQueue.IdleHandler"></a>MessageQueue.IdleHandler</h3><p>在上一节中，我们提到过MessageQueue中有个有趣的接口叫IdleHandler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;();</span><br><span class="line">private IdleHandler[] mPendingIdleHandlers;</span><br><span class="line">/**</span><br><span class="line">     * Callback interface for discovering when a thread is going to block</span><br><span class="line">     * waiting for more messages.</span><br><span class="line">     */</span><br><span class="line">    public static interface IdleHandler &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Called when the message queue has run out of messages and will now</span><br><span class="line">         * wait for more.  Return true to keep your idle handler active, false</span><br><span class="line">         * to have it removed.  This may be called if there are still messages</span><br><span class="line">         * pending in the queue, but they are all scheduled to be dispatched</span><br><span class="line">         * after the current time.</span><br><span class="line">         */</span><br><span class="line">        boolean queueIdle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public void addIdleHandler(@NonNull IdleHandler handler) &#123;</span><br><span class="line">        if (handler == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;Can&apos;t add a null IdleHandler&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mIdleHandlers.add(handler);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void removeIdleHandler(@NonNull IdleHandler handler) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mIdleHandlers.remove(handler);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message next() &#123;</span><br><span class="line">        .....</span><br><span class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">                if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                    // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                    mBlocked = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Run the idle handlers.</span><br><span class="line">            // We only ever reach this code block during the first iteration.</span><br><span class="line">            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">                boolean keep = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!keep) &#123;</span><br><span class="line">                    synchronized (this) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">            pendingIdleHandlerCount = 0;</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过官方解释我们可以了解这个接口的作用：当消息队列中没有消息时，会回调该接口，前提是你设置了监听。它的返回值：返回false，那么就会移除它，返回true就会在下次message处理完了的时候继续回调。</p><p>那么这个接口到底有什么用呢，其实也可以用来获取View的宽高，在View初始化，Activity启动的时候，MessageQueue的有许多的消息，我们可以从ViewRootImpl的ViewRootHandler里面可以看出。当MessageQueue为空时，表示View真正的完成了measue，layout，draw等操作，这是我们就可以去执行一些获取view属性的操作或者做一些耗时操作，这时就不会影响UI的显示了，特别是进入App主页，经常需要向服务器请求大量的数据来更新UI，如果子线程过多，又设置了过高的优先级，就会抢占调度UI线程，导致卡顿，所以这个接口就很有用了。那么怎么具体使用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> //MessageQueue queue = Looper.getMainLooper().getQueue();</span><br><span class="line">MessageQueue queue = Looper.myQueue();</span><br><span class="line">queue.addIdleHandler(new MessageQueue.IdleHandler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean queueIdle() &#123;</span><br><span class="line">        Log.d(&quot;Activity&quot;,&quot;idleHandler&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;https://www.dyenter.top/2018/04/19/freshui1/&quot;&gt;前一章
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
      <category term="View" scheme="https://www.dyenter.top/categories/Android/View/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="UI" scheme="https://www.dyenter.top/tags/UI/"/>
    
      <category term="Handler" scheme="https://www.dyenter.top/tags/Handler/"/>
    
      <category term="View" scheme="https://www.dyenter.top/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android探索更新UI的方法（一）-更新UI的时机</title>
    <link href="https://www.dyenter.top/2018/04/19/freshui1/"/>
    <id>https://www.dyenter.top/2018/04/19/freshui1/</id>
    <published>2018-04-18T16:10:26.000Z</published>
    <updated>2018-04-21T02:48:51.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面的文章中，我们讲述了Handler，MessageQueue，Looper三者的关系，从Java层深入到native层。<br>&emsp;&emsp;1、 <a href="https://www.dyenter.top/2018/04/15/handler/">Android线程间通信基础——Handler,Looper,MessageQueue</a><br>&emsp;&emsp;2、<a href="https://www.dyenter.top/2018/04/18/handler-native/">Handler,MessageQueue,Looper源码分析（Native层）</a></p><p><strong>那么今天我们来讲讲跟Handler相关，在开发中我们经常用的更新UI的几种方式</strong>，透析他们的本质是什么？</p><h2 id="主线程更新UI"><a href="#主线程更新UI" class="headerlink" title="主线程更新UI"></a>主线程更新UI</h2><p>这其实没什么可讲的，直接更新，但是你调用更新方法是是立即显示到屏幕上吗？这里我们在onCreate()里面用一个TextView setText()为例，展开流程讲解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FreshUIActivity extends AppCompatActivity &#123;</span><br><span class="line">    TextView mTextView;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_fresh_ui);</span><br><span class="line">        mTextView = findViewById(R.id.textView);</span><br><span class="line">        mTextView.setText(&quot;1123&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进入TextView里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private CharSequence mText;</span><br><span class="line">public final void setText(CharSequence text) &#123;</span><br><span class="line">        setText(text, mBufferType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setText(CharSequence text, BufferType type) &#123;</span><br><span class="line">        setText(text, type, true, 0);</span><br><span class="line"></span><br><span class="line">        if (mCharWrapper != null) &#123;</span><br><span class="line">            mCharWrapper.mChars = null;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setText(CharSequence text, BufferType type,</span><br><span class="line">                         boolean notifyBefore, int oldlen) &#123;</span><br><span class="line">        .....</span><br><span class="line">        mBufferType = type;</span><br><span class="line">        mText = text;</span><br><span class="line">        .....</span><br><span class="line">        if (mLayout != null) &#123;</span><br><span class="line">            checkForRelayout();</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们会发现它仅仅是吧text赋值给mText成员变量而已，并没有做真正的显示操作，而且在onCreate()这个时间点，屏幕还没显现我们的内容，这时的mLayout为null，那么真正的显示操作是在什么时候呢？<br>&emsp;&emsp;我们知道，一个View要显示会经历onMeasure(),onLayout(),onDraw()三个步骤，那么显示肯定是在onDraw()里面，果然我们找到了mText的踪影：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        restartMarqueeIfNeeded();</span><br><span class="line"></span><br><span class="line">        // Draw the background for this view</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        .....</span><br><span class="line">        //绘制背景，图片等其他操作</span><br><span class="line">        .....</span><br><span class="line">        Path highlight = getUpdatedHighlightPath();</span><br><span class="line">        if (mEditor != null) &#123;</span><br><span class="line">            mEditor.onDraw(canvas, layout, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进入getUpdatedHighlightPath();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private Path getUpdatedHighlightPath() &#123;</span><br><span class="line">        Path highlight = null;</span><br><span class="line">        Paint highlightPaint = mHighlightPaint;</span><br><span class="line"></span><br><span class="line">        final int selStart = getSelectionStart();</span><br><span class="line">        final int selEnd = getSelectionEnd();</span><br><span class="line">        if (mMovement != null &amp;&amp; (isFocused() || isPressed()) &amp;&amp; selStart &gt;= 0) &#123;</span><br><span class="line">            if (selStart == selEnd) &#123;</span><br><span class="line">                if (mEditor != null &amp;&amp; mEditor.isCursorVisible()</span><br><span class="line">                        &amp;&amp; (SystemClock.uptimeMillis() - mEditor.mShowCursor)</span><br><span class="line">                        % (2 * Editor.BLINK) &lt; Editor.BLINK) &#123;</span><br><span class="line">                    if (mHighlightPathBogus) &#123;</span><br><span class="line">                        if (mHighlightPath == null) mHighlightPath = new Path();</span><br><span class="line">                        mHighlightPath.reset();</span><br><span class="line">                        //mText，找到了</span><br><span class="line">                        mLayout.getCursorPath(selStart, mHighlightPath, mText);</span><br><span class="line">                        mEditor.updateCursorsPositions();</span><br><span class="line">                        mHighlightPathBogus = false;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // XXX should pass to skin instead of drawing directly</span><br><span class="line">                    highlightPaint.setColor(mCurTextColor);</span><br><span class="line">                    highlightPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">                    highlight = mHighlightPath;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mHighlightPathBogus) &#123;</span><br><span class="line">                    if (mHighlightPath == null) mHighlightPath = new Path();</span><br><span class="line">                    mHighlightPath.reset();</span><br><span class="line">                    mLayout.getSelectionPath(selStart, selEnd, mHighlightPath);</span><br><span class="line">                    mHighlightPathBogus = false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // XXX should pass to skin instead of drawing directly</span><br><span class="line">                highlightPaint.setColor(mHighlightColor);</span><br><span class="line">                highlightPaint.setStyle(Paint.Style.FILL);</span><br><span class="line"></span><br><span class="line">                highlight = mHighlightPath;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return highlight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mLayout.getCursorPath(selStart, mHighlightPath, mText);这个方法绘制文字的路径，然后在onDraw()才绘制到屏幕上。</p><h2 id="子线程更新"><a href="#子线程更新" class="headerlink" title="子线程更新"></a>子线程更新</h2><p>我们加入以下代码，在子线程更新UI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onResume() &#123;</span><br><span class="line">        super.onPostResume();</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">              mTextView.setText(&quot;1123&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现也能更新UI，不是说子线程不能更新UI吗，其实这时候画面还没真正完全显示到屏幕上，你会发现这是mLayout还是为null，所以也仅仅是赋值给mText而已。<br>假如我们让线程阻塞2秒呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onResume() &#123;</span><br><span class="line">        super.onPostResume();</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                            Thread.sleep(2000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mTextView.setText(&quot;1123&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br></pre></td></tr></table></figure></p><p>这个错误很熟悉吧，不能在子线程更新UI，那么为什么会这样呢，这是我们断点跟进源码发现mLayout不为空了，所以会调用checkForRelayout()；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void checkForRelayout() &#123;</span><br><span class="line">        ....</span><br><span class="line">        requestLayout();</span><br><span class="line">        invalidate();</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两行代码是不是很熟悉，我们经常在自定义View的时候是不是经常用？它会调用View的requestLayout()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void requestLayout() &#123;</span><br><span class="line">        if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">               mParent.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个mParent其实就是ViewRootImpl，我们在启动Activity是，会经过ActivityThread的handleLaunchActivity-&gt;handleResumeActivity-&gt;performResumeActivity，performResumeActivity会回调Activity的performResume()方法，然后会通过Instrumentation回调onResume(),这表明onResume()回调时其实View还没显示到屏幕上，所以子线程也能更新UI。<br>&emsp;&emsp;那么现在我们看回来handleResumeActivity方法，执行完performResumeActivity方法回调了onResume方法后，会来到这一块代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.activity.mVisibleFromServer = true;</span><br><span class="line">mNumVisibleActivities++;</span><br><span class="line">if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">        r.activity.makeVisible();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着进入Activity的makeVisible()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Activity.java</span><br><span class="line">void makeVisible() &#123;</span><br><span class="line">        if (!mWindowAdded) &#123;</span><br><span class="line">            ViewManager wm = getWindowManager();</span><br><span class="line">            wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">            mWindowAdded = true;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">WindowManagerImpl.java</span><br><span class="line">@Override</span><br><span class="line">    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">WindowManagerGlobal.java</span><br><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">            Display display, Window parentWindow) &#123;</span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">            view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">            mViews.add(view);</span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">            // do this last because it fires off messages to start doing things</span><br><span class="line">            try &#123;</span><br><span class="line">                root.setView(view, wparams, panelParentView);</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                // BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">                if (index &gt;= 0) &#123;</span><br><span class="line">                    removeViewLocked(index, true);</span><br><span class="line">                &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里调用了ViewRootImpl的setView方法,这里面会把view通过IWindowSession 传递到WMS，再绘制到屏幕上，关于WMS，Window的原理我们之后再讲<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">        ...</span><br><span class="line">         view.assignParent(this);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它会把自己复制给mParent，几把ViewRootImpl给View的mParent，这就证实了前面的操作，所以它就是调用了ViewRootImpl的requestLayout()方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void requestLayout() &#123;</span><br><span class="line">        if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = true;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void checkThread() &#123;</span><br><span class="line">        if (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            throw new CalledFromWrongThreadException(</span><br><span class="line">                    &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这下是不是很明朗了？经历了这么多，到最后才检查线程是不是UI线程，如果不是，将会抛出异常。<strong>注意mThread实在ViewRootImpl的构造函数时候赋值的，而ViewRootImpl是在ActivityThraed里初始化的，即主线程</strong></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-3e0c557f6333c62e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UML时序图 .png" title="">                </div>                <div class="image-caption">UML时序图 .png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在前面的文章中，我们讲述了Handler，MessageQueue，Looper三者的关系，从Java层深入到native层。&lt;br&gt;&amp;em
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="子线程" scheme="https://www.dyenter.top/tags/%E5%AD%90%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Handler,MessageQueue,Looper源码分析（Native层）</title>
    <link href="https://www.dyenter.top/2018/04/18/handler-native/"/>
    <id>https://www.dyenter.top/2018/04/18/handler-native/</id>
    <published>2018-04-18T09:00:06.000Z</published>
    <updated>2018-04-18T09:52:35.969Z</updated>
    
    <content type="html"><![CDATA[<p>本源码分析基于Android8.0</p><h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Java层</span><br><span class="line">framework/base/core/java/andorid/os/MessageQueue.java</span><br><span class="line">framework/base/core/java/andorid/os/Looper.java</span><br><span class="line"></span><br><span class="line">Native层</span><br><span class="line">system/core/libutils/include/utils/RefBase.h</span><br><span class="line">system/core/libutils/RefBase.cpp</span><br><span class="line"></span><br><span class="line">framework/base/core/jni/android_os_MessageQueue.h</span><br><span class="line">framework/base/core/jni/android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line">system/core/libutils/include/utils/Looper.h</span><br><span class="line">system/core/libutils/Looper.cpp </span><br><span class="line"></span><br><span class="line">framework/native/include/android/looper.h</span><br><span class="line">framework/base/native/android/looper.cpp</span><br></pre></td></tr></table></figure><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>&emsp;&emsp;在上一篇文章中，<a href="https://www.dyenter.top/2018/04/15/handler">我们讲解了Handler，Looper，MessageQueue的关系</a>,其中在MessageQueue的next方法中有这样一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">        ....</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而添加消息入队的时候，有这样一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        ...</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">                ...</span><br><span class="line">                if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">                        // New head, wake up the event queue if blocked.</span><br><span class="line">                        msg.next = p;</span><br><span class="line">                        mMessages = msg;</span><br><span class="line">                        needWake = mBlocked;</span><br><span class="line">                 &#125;</span><br><span class="line">                ...</span><br><span class="line">                // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">                if (needWake) &#123;</span><br><span class="line">                        nativeWake(mPtr);</span><br><span class="line">                &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样Looper里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">        ...</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>通过以上三段代码和注释可以看出，添加消息的时候有可能在阻塞状态：即之前消息队列为空，取消息的时候也可能在阻塞状态</strong>，为什么会这样呢，阻塞不会导致ANR吗？其实关键就在于两个native方法身上<strong>nativePollOnce和nativeWake。</strong><br>&emsp;&emsp;<strong>它的本质就是Linux的管道。管道，其本质是也是文件，但又和普通的文件会有所不同：管道缓冲区大小一般为1页，即4K字节。管道分为读端和写端，读端负责从管道拿数据，当数据为空时则阻塞；写端向管道写数据，当管道缓存区满时则阻塞。</strong></p><h2 id="接下来我们进入Native层"><a href="#接下来我们进入Native层" class="headerlink" title="接下来我们进入Native层"></a>接下来我们进入Native层</h2><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-24d34b2df79741eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="uml.png" title="">                </div>                <div class="image-caption">uml.png</div>            </figure><p>首先查看MessageQueue.java里面的native方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue.java</span><br><span class="line"></span><br><span class="line">private native static long nativeInit();</span><br><span class="line">private native static void nativeDestroy(long ptr);</span><br><span class="line">private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/</span><br><span class="line">private native static void nativeWake(long ptr);</span><br><span class="line">private native static boolean nativeIsPolling(long ptr);</span><br><span class="line">private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);</span><br><span class="line"></span><br><span class="line">//构造函数</span><br><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="我们发现调用了nativeInit-方法，我们进入native层看它做了什么"><a href="#我们发现调用了nativeInit-方法，我们进入native层看它做了什么" class="headerlink" title="我们发现调用了nativeInit()方法，我们进入native层看它做了什么"></a>我们发现调用了nativeInit()方法，我们进入native层看它做了什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</span><br><span class="line">    if (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="它就是生成一个NativeMessageQueue-对象-那我们去看构造函数做了什么"><a href="#它就是生成一个NativeMessageQueue-对象-那我们去看构造函数做了什么" class="headerlink" title="它就是生成一个NativeMessageQueue()对象,那我们去看构造函数做了什么"></a>它就是生成一个NativeMessageQueue()对象,那我们去看构造函数做了什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    if (mLooper == NULL) &#123;</span><br><span class="line">        mLooper = new Looper(false);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现它生成了Looper对象，这个是native层的，跟java层的Looper不一样，它几乎重写了java层的Looper逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Looper::Looper(bool allowNonCallbacks) :</span><br><span class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),</span><br><span class="line">        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),</span><br><span class="line">        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    mWakeEventFd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);//1</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, &quot;Could not make wake event fd: %s&quot;,</span><br><span class="line">                        strerror(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);//2</span><br><span class="line">    rebuildEpollLocked();//3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1，eventfd()，使用这个函数来创建一个事件对象，该函数返回一个文件描述符来代表这个事件对象，之后我们就用这个来调用对象；<br>2，AutoMutex _l()，给mLock对象加锁；执行完后自动释放锁，它的原理是利用了c++的构造和析构函数完成自动加锁和放锁。<br>3，rebuildEpollLocked()，重建epoll事件。</p><h3 id="接下来看rebuildEpollLocked"><a href="#接下来看rebuildEpollLocked" class="headerlink" title="接下来看rebuildEpollLocked"></a>接下来看rebuildEpollLocked</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void Looper::rebuildEpollLocked() &#123;</span><br><span class="line">    // Close old epoll instance if we have one.</span><br><span class="line">    if (mEpollFd &gt;= 0) &#123;</span><br><span class="line">#if DEBUG_CALLBACKS</span><br><span class="line">        ALOGD(&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;, this);</span><br><span class="line">#endif</span><br><span class="line">//关闭旧的epoll</span><br><span class="line">        close(mEpollFd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Allocate the new epoll instance and register the wake pipe.</span><br><span class="line">   //创建新的epoll并注册管道，参数表示监听的文件描述符数目，它向内核申请了一段内存空间</span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance: %s&quot;, strerror(errno));</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItem;</span><br><span class="line">    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd;//把之前创建的mWakeEventFd赋给item</span><br><span class="line">   //把之前生成的mWakeEventFd加入到 epoll，eventItem也加入epoll，这样就能控制我们的mWakeEventFd所表示的对象了</span><br><span class="line">    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance: %s&quot;,</span><br><span class="line">                        strerror(errno));</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; mRequests.size(); i++) &#123;</span><br><span class="line">        const Request&amp; request = mRequests.valueAt(i);</span><br><span class="line">        struct epoll_event eventItem;</span><br><span class="line">        request.initEventItem(&amp;eventItem);</span><br><span class="line"></span><br><span class="line">        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</span><br><span class="line">        if (epollResult &lt; 0) &#123;</span><br><span class="line">            ALOGE(&quot;Error adding epoll events for fd %d while rebuilding epoll set: %s&quot;,</span><br><span class="line">                  request.fd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意int epoll_ctl(int epfd, intop, int fd, struct epoll_event* event);<br>他是epoll的事件注册函数：<br>          &emsp;&emsp;第一个参数是epoll_create()的返回值，<br>           &emsp;&emsp;第二个参数表示动作，用三个宏来表示：<br>           &emsp;&emsp;EPOLL_CTL_ADD：       注册新的fd到epfd中；<br>          &emsp;&emsp;EPOLL_CTL_MOD：      修改已经注册的fd的监听事件；<br>          &emsp;&emsp;EPOLL_CTL_DEL：        从epfd中删除一个fd；<br>         &emsp;&emsp;第三个参数是需要监听的fd，<br>         &emsp;&emsp;第四个参数是告诉内核需要监听什么事件</p><p><strong>我们回到NativeMessageQueue::NativeMessageQueue()</strong></p><h3 id="它不是每次都生成新的Looper，而是保存到TSL中"><a href="#它不是每次都生成新的Looper，而是保存到TSL中" class="headerlink" title="它不是每次都生成新的Looper，而是保存到TSL中"></a>它不是每次都生成新的Looper，而是保存到TSL中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Looper::setForThread(const sp&lt;Looper&gt;&amp; looper) &#123;</span><br><span class="line">    sp&lt;Looper&gt; old = getForThread(); // also has side-effect of initializing TLS</span><br><span class="line"></span><br><span class="line">    if (looper != NULL) &#123;</span><br><span class="line">        looper-&gt;incStrong((void*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_setspecific(gTLSKey, looper.get());</span><br><span class="line"></span><br><span class="line">    if (old != NULL) &#123;</span><br><span class="line">        old-&gt;decStrong((void*)threadDestructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;sp就类似于java的强引用，native层还有一个wp类似于java的弱引用，因为Android封装了c++的对象回收机制，具体的可阅读<strong>深入理解Android卷I相关源码</strong>。<br>&emsp;&emsp;TLS，即线程本地存储（Thread Local Storage），可以对比理解为Java层的ThreadLocal，在单线程模式下，所有整个程序生命周期的变量都是只有一份，那是因为只是一个执行单元；而在多线程模式下，有些变量需要支持每个线程独享一份的功能。这种每个线程独享的变量放到每个线程专有的存储区域，所以称为线程本地存储（Thread Local Storage）或者线程私有数据（Thread Specific Data）。<br>&emsp;&emsp;<strong>那么到这里初始化就完成了，即创建NativeMessageQueue，创建Looper并保存到TLS中</strong>，Looper里面创建了epoll，注册了事件，之后我们就能收到回调，这里可以对比理解为setOnclickListener。最后返回生成的NativeMessageQueue指针(jlong类型)给Java层，注意reinterpret_cast是c++的强转，通常将一个类型指针转换为另一个类型指针  。</p><h2 id="nativePollOnce"><a href="#nativePollOnce" class="headerlink" title="nativePollOnce()"></a>nativePollOnce()</h2><p>在Looper的loop()死循环里面，会调用MessageQueue的next(),next()会调用nativePollOnce()，进入native层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,</span><br><span class="line">        jlong ptr, jint timeoutMillis) &#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里传入了一个参数，就是刚刚调用nativeInit()得到的NativemessageQueue的jlong指针，再强转回来，然后调用pollOnce方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue.cpp</span><br><span class="line"></span><br><span class="line">void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = NULL;</span><br><span class="line">    mPollEnv = NULL;</span><br><span class="line"></span><br><span class="line">    if (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Looper.h</span><br><span class="line"></span><br><span class="line">inline int pollOnce(int timeoutMillis) &#123;</span><br><span class="line">        return pollOnce(timeoutMillis, NULL, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        while (mResponseIndex &lt; mResponses.size()) &#123;</span><br><span class="line">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</span><br><span class="line">            int ident = response.request.ident;</span><br><span class="line">            if (ident &gt;= 0) &#123;</span><br><span class="line">                int fd = response.request.fd;</span><br><span class="line">                int events = response.events;</span><br><span class="line">                void* data = response.request.data;</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</span><br><span class="line">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</span><br><span class="line">                        this, ident, fd, events, data);</span><br><span class="line">#endif</span><br><span class="line">                if (outFd != NULL) *outFd = fd;</span><br><span class="line">                if (outEvents != NULL) *outEvents = events;</span><br><span class="line">                if (outData != NULL) *outData = data;</span><br><span class="line">                return ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (result != 0) &#123;</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</span><br><span class="line">#endif</span><br><span class="line">            if (outFd != NULL) *outFd = 0;</span><br><span class="line">            if (outEvents != NULL) *outEvents = 0;</span><br><span class="line">            if (outData != NULL) *outData = NULL;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>pollOnce的timeoutMillis就是我们java层设置的超时参数，接下来调用pollInner<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int Looper::pollInner(int timeoutMillis) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Poll.</span><br><span class="line">    int result = POLL_WAKE;</span><br><span class="line">    mResponses.clear();</span><br><span class="line">    mResponseIndex = 0;</span><br><span class="line"></span><br><span class="line">    // We are about to idle.</span><br><span class="line">    mPolling = true;</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    //关键方法</span><br><span class="line">    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    // No longer idling.</span><br><span class="line">    mPolling = false;</span><br><span class="line"></span><br><span class="line">    // Acquire lock.</span><br><span class="line">    mLock.lock();</span><br><span class="line"></span><br><span class="line">    // Rebuild epoll set if needed.</span><br><span class="line">    if (mEpollRebuildRequired) &#123;</span><br><span class="line">        mEpollRebuildRequired = false;</span><br><span class="line">        rebuildEpollLocked();</span><br><span class="line">        goto Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check for poll error.</span><br><span class="line">    if (eventCount &lt; 0) &#123;</span><br><span class="line">        if (errno == EINTR) &#123;</span><br><span class="line">            goto Done;</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGW(&quot;Poll failed with an unexpected error: %s&quot;, strerror(errno));</span><br><span class="line">        result = POLL_ERROR;</span><br><span class="line">        goto Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check for poll timeout.</span><br><span class="line">    if (eventCount == 0) &#123;</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">        ALOGD(&quot;%p ~ pollOnce - timeout&quot;, this);</span><br><span class="line">#endif</span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        goto Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle all events.</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ pollOnce - handling events from %d fds&quot;, this, eventCount);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; eventCount; i++) &#123;</span><br><span class="line">        int fd = eventItems[i].data.fd;</span><br><span class="line">        uint32_t epollEvents = eventItems[i].events;</span><br><span class="line">        //找到我们注册事件的文件描述符</span><br><span class="line">        if (fd == mWakeEventFd) &#123;</span><br><span class="line">            if (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                //从epoll_wait()里唤醒了，读取管道内容</span><br><span class="line">                awoken();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ssize_t requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">            if (requestIndex &gt;= 0) &#123;</span><br><span class="line">                int events = 0;</span><br><span class="line">                if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">                if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">                if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">                if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;</span><br><span class="line">                        &quot;no longer registered.&quot;, epollEvents, fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">    // Invoke pending message callbacks.</span><br><span class="line">    mNextMessageUptime = LLONG_MAX;</span><br><span class="line">    while (mMessageEnvelopes.size() != 0) &#123;</span><br><span class="line">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);</span><br><span class="line">        if (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">            // Remove the envelope from the list.</span><br><span class="line">            // We keep a strong reference to the handler until the call to handleMessage</span><br><span class="line">            // finishes.  Then we drop it so that the handler can be deleted *before*</span><br><span class="line">            // we reacquire our lock.</span><br><span class="line">            &#123; // obtain handler</span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                mMessageEnvelopes.removeAt(0);</span><br><span class="line">                mSendingMessage = true;</span><br><span class="line">                mLock.unlock();</span><br><span class="line"></span><br><span class="line">#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span><br><span class="line">                ALOGD(&quot;%p ~ pollOnce - sending message: handler=%p, what=%d&quot;,</span><br><span class="line">                        this, handler.get(), message.what);</span><br><span class="line">#endif</span><br><span class="line">                handler-&gt;handleMessage(message);</span><br><span class="line">            &#125; // release handler</span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">            mSendingMessage = false;</span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // The last message left at the head of the queue determines the next wakeup time.</span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Release lock.</span><br><span class="line">    mLock.unlock();</span><br><span class="line"></span><br><span class="line">    // Invoke all response callbacks.</span><br><span class="line">    for (size_t i = 0; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">        Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">        if (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">            int fd = response.request.fd;</span><br><span class="line">            int events = response.events;</span><br><span class="line">            void* data = response.request.data;</span><br><span class="line">#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span><br><span class="line">            ALOGD(&quot;%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p&quot;,</span><br><span class="line">                    this, response.request.callback.get(), fd, events, data);</span><br><span class="line">#endif</span><br><span class="line">            // Invoke the callback.  Note that the file descriptor may be closed by</span><br><span class="line">            // the callback (and potentially even reused) before the function returns so</span><br><span class="line">            // we need to be a little careful when removing the file descriptor afterwards.</span><br><span class="line">            int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">            if (callbackResult == 0) &#123;</span><br><span class="line">                removeFd(fd, response.request.seq);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Clear the callback reference in the response structure promptly because we</span><br><span class="line">            // will not clear the response vector itself until the next poll.</span><br><span class="line">            response.request.callback.clear();</span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最关键的方法就在epoll-wait-身上-这个方法会等待事件发生或者超时，在nativeWake-方法，向管道写端写入字符时，则该方法会返回，否则一直阻塞；注意result返回值有以下几种类型："><a href="#最关键的方法就在epoll-wait-身上-这个方法会等待事件发生或者超时，在nativeWake-方法，向管道写端写入字符时，则该方法会返回，否则一直阻塞；注意result返回值有以下几种类型：" class="headerlink" title="最关键的方法就在epoll_wait()身上,这个方法会等待事件发生或者超时，在nativeWake()方法，向管道写端写入字符时，则该方法会返回，否则一直阻塞；注意result返回值有以下几种类型："></a>最关键的方法就在epoll_wait()身上,这个方法会等待事件发生或者超时，在nativeWake()方法，向管道写端写入字符时，则该方法会返回，否则一直阻塞；注意result返回值有以下几种类型：</h3><p>&emsp;&emsp;POLL_WAKE,初始化状态，它表示由管道写入端触发，pipe write；<br>&emsp;&emsp;POLL_ERROR阻塞等待期间发生错误，发生错误goto到Done处；<br>&emsp;&emsp;POLL_TIMEOUT 发生超时；<br>&emsp;&emsp;POLL_CALLBACK： 表示某个被监听的文件描述符被触发，比如我们nativeInit创建的mWakeEventFd；</p><h3 id="当唤醒后，要不断的去从管道中读取数据，这时调用了awoken-方法"><a href="#当唤醒后，要不断的去从管道中读取数据，这时调用了awoken-方法" class="headerlink" title="当唤醒后，要不断的去从管道中读取数据，这时调用了awoken()方法"></a>当唤醒后，要不断的去从管道中读取数据，这时调用了awoken()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Looper::awoken() &#123;</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ awoken&quot;, this);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    uint64_t counter;</span><br><span class="line">    TEMP_FAILURE_RETRY(read(mWakeEventFd, &amp;counter, sizeof(uint64_t)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>很简单，就是从管道里读取内容</strong>，这是我们已经拿到Native层的Message了，在Done里面，我们会处理Message，并回调handler-&gt;handleMessage()方法，注意此handler非java层的handler，它是一个MessageHandler,Message等类在Looper.h中。</p><h2 id="nativeWake"><a href="#nativeWake" class="headerlink" title="nativeWake()"></a>nativeWake()</h2><p>接下来我们看是怎么唤醒的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"> static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NativeMessageQueue::wake() &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line">void Looper::wake() &#123;</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ wake&quot;, this);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    uint64_t inc = 1;</span><br><span class="line">    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));</span><br><span class="line">    if (nWrite != sizeof(uint64_t)) &#123;</span><br><span class="line">        if (errno != EAGAIN) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(&quot;Could not write wake signal to fd %d: %s&quot;,</span><br><span class="line">                    mWakeEventFd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是调用write()向管道写入一个整数1，TEMP_FAILURE_RETRY就是失败不断的重试，知道成功唤醒为止，成功写入后，管道的另一端就会接收到，并从阻塞状态结束，即从epoll_wait()返回，执行它后面的代码。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-6edfa2ed36bd0496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="liu.png" title="">                </div>                <div class="image-caption">liu.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本源码分析基于Android8.0&lt;/p&gt;
&lt;h2 id=&quot;源码目录&quot;&gt;&lt;a href=&quot;#源码目录&quot; class=&quot;headerlink&quot; title=&quot;源码目录&quot;&gt;&lt;/a&gt;源码目录&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
      <category term="Native" scheme="https://www.dyenter.top/categories/Android/Native/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="Handler" scheme="https://www.dyenter.top/tags/Handler/"/>
    
      <category term="Native" scheme="https://www.dyenter.top/tags/Native/"/>
    
  </entry>
  
  <entry>
    <title>Android线程间通信基础——Handler,Looper,MessageQueue</title>
    <link href="https://www.dyenter.top/2018/04/15/handler/"/>
    <id>https://www.dyenter.top/2018/04/15/handler/</id>
    <published>2018-04-15T12:13:58.000Z</published>
    <updated>2018-04-16T13:01:44.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android单线程模型"><a href="#Android单线程模型" class="headerlink" title="Android单线程模型"></a>Android单线程模型</h2><p>&emsp;&emsp;我们知道进程是cpu<strong>资源分配的最小单位</strong>，线程是cpu<strong>调度的最小单位</strong>。早期的操作系统里进程既是资源分配也是调度的最小单位，后来随着cpu速度越来越快，为了更合理的使用cpu，减少进程切换的开销，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。<br>&emsp;&emsp;当我们第一次打开一个App时，系统就会给这个App分配一个进程，并且启动一个main thread线程，主线程主要负责处理与UI相关的事件，如：用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以主线程通常又被叫做UI线程。<br>&emsp;&emsp;在开发Android 应用时必须遵守单线程模型的原则： Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>&emsp;&emsp;既然UI操作只能在UI线程里更新，那么可不可以把所有操作都放在UI线程里面呢？答案是不可能的，可能会导致ANR。所以一些常用的耗时操作只能在非UI线程里执行，比如网络，数据库，IO操作等。那在非UI线程执行完后我们想把处理结果通知给UI线程怎么办，这就涉及到线程间通信的问题。<br>&emsp;&emsp;传统的Java线程间通信包括volatile，synchronized，CountDownLatch等不适合于Android，因为AndroidUI线程是消息驱动模式，主线程在启动时会初始化一个Looper，并调用loop()方法开启死循环，在循环里执行处理消息的操作。</p><h3 id="大致流程图如下"><a href="#大致流程图如下" class="headerlink" title="大致流程图如下"></a>大致流程图如下</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-49da756e0ea45d4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="handler_watermark.png" title="">                </div>                <div class="image-caption">handler_watermark.png</div>            </figure><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-1578bcc4d14af428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="uml_watermark.png" title="">                </div>                <div class="image-caption">uml_watermark.png</div>            </figure><h2 id="流程讲解"><a href="#流程讲解" class="headerlink" title="流程讲解"></a>流程讲解</h2><p>&emsp;&emsp;接下来我们以handler的创建为起始点，结合源码开始讲解。</p><h3 id="hander创建（UI线程中）"><a href="#hander创建（UI线程中）" class="headerlink" title="hander创建（UI线程中）"></a>hander创建（UI线程中）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler = new Handler();</span><br></pre></td></tr></table></figure><p>查看构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">        this(null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以传入两个参数，一个为callback，他是Handler的内部接口，里面只有一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback &#123;</span><br><span class="line">        /**</span><br><span class="line">         * @param msg A &#123;@link android.os.Message Message&#125; object</span><br><span class="line">         * @return True if no further handling is desired</span><br><span class="line">         */</span><br><span class="line">        public boolean handleMessage(Message msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是我们初始化Handler的时候可以传入一个Callback，之后Looper会回调这个Callback。<br>另一个参数表示是否是异步消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Handler.java</span><br><span class="line"></span><br><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        if (mLooper == null) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看见这里面会获取Looper，如果Looper为空，则会报错；由于Handler实在主线程里面创建的，默认用的是主线程的Looper，而主线程的Looper实在ActivityThread的main方法中创建的。所以如果在其他线程创建Handler必须显示的创建Looper。</p><p>&emsp;&emsp;我们进入Looper.myLooper()方法里面看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Handler.java</span><br><span class="line"></span><br><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">/**</span><br><span class="line">     * Return the Looper object associated with the current thread.  Returns</span><br><span class="line">     * null if the calling thread is not associated with a Looper.</span><br><span class="line">     */</span><br><span class="line">    public static @Nullable Looper myLooper() &#123;</span><br><span class="line">        return sThreadLocal.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;ThreadLocal里面是一个类似于HashMap的数据结构，它主要是用于保存线程的局部变量，ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。<br>&emsp;&emsp;也就是myLooper()会获取当前线程的Looper，那么主线程的Looper实在哪创建的呢？答案是在ActivityThread中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.java</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ...</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Looper.java</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Initialize the current thread as a looper, marking it as an</span><br><span class="line">     * application&apos;s main looper. The main looper for your application</span><br><span class="line">     * is created by the Android environment, so you should never need</span><br><span class="line">     * to call this function yourself.  See also: &#123;@link #prepare()&#125;</span><br><span class="line">     */</span><br><span class="line">    public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>调用prepare方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        if (sThreadLocal.get() != null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>所以就是在这创建完Looper的，并且创建想应的MessageQueue，然后把Looper保存到ThreadLocal中</strong><br><strong>结论：一个线程对应一个Looper对应一个MessageQueue</strong></p><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>&emsp;&emsp; Handler创建完毕后，我们就可以发送消息了，发送消息有几种方式，如post(),sendMessage();最终都会调用handler的sendMessageAtTime()方法(post 的Runnnale也会包装成Message)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            RuntimeException e = new RuntimeException(</span><br><span class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mQueue就是在创建Handler时赋值的，它会调用MessageQueue的enqueueMessage方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">        msg.target = this;</span><br><span class="line">        if (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里要注意的是把msg.target指向了自己，这是为了Looper处理完消息后回调自己的相关方法。<br>接下来进入MessageQueue里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        ...</span><br><span class="line">        //防止多个子线程同时发送消息，导致不可预知的错误</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">             ...</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            boolean needWake;</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">                // New head, wake up the event queue if blocked.</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">                // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">                // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; // invariant: p == prev.next</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mMessages是当前Looper正在处理的消息，即消息队列的队头，赋值的地方是在next()方法里面；即如果当前队头的消息为空或者待入队的消息延时为0或者待入队的消息的延时小于队头的延时，则把待入队的消息插入到队的头部；<br>&emsp;&emsp;<strong>这可以看出MessageQueue是一个按when顺序排列的优先级队列，队头的when是最小</strong>；<br>&emsp;&emsp;<strong>同时加入之前是延迟消息，会阻塞当前队列，所以还需要唤醒</strong></p><p>&emsp;&emsp;else里面会开启for循环，这个循环的目的是插入消息到链表的中间：如果插入消息到链表头部的条件不具备，<strong>则依次循环消息链表比较触发时间的长短</strong>，然后将消息插入到消息链表的合适位置。接着如果需要唤醒线程处理则调用C++中的nativeWake()函数。 </p><p><strong>这样handler插入消息的流程就完毕了</strong></p><h2 id="Looper消息循环"><a href="#Looper消息循环" class="headerlink" title="Looper消息循环"></a>Looper消息循环</h2><p>&emsp;&emsp;当消息队列中有消息的时候，Looper就会去取出消息并执行，具体在Looper的loop()方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">        final Looper me = myLooper();</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br><span class="line">        ...</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里面主要就是从MessageQueue中取出Message执行，即调用queue.next()，然后handler的dispatchMessage()方法，前面提到过msg.target执行的就是我们的handler。然后回收message，可以复用；这也是为什么建议用Message.obtain()来生成message的原因。<br>&emsp;&emsp;接下来看MessageQueue的next方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">        ...</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">               ...</span><br><span class="line">              nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">              synchronized (this) &#123;</span><br><span class="line">                // Try to retrieve the next message.  Return if found.</span><br><span class="line">                final long now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = null;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                if (msg != null) &#123;</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Got a message.</span><br><span class="line">                        mBlocked = false;</span><br><span class="line">                        if (prevMsg != null) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = null;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        return msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // No more messages.</span><br><span class="line">                    nextPollTimeoutMillis = -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Process the quit message now that all pending messages have been handled.</span><br><span class="line">                if (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If first time idle, then get the number of idlers to run.</span><br><span class="line">                // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">                // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">                if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                    // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                    mBlocked = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;nativePollOnce(ptr, nextPollTimeoutMillis);是一个native方法，底层是用管道实现的，它的作用是在native层阻塞，对应的用nativeWake()唤醒，接下通过do while循环在MessageQueue中找message，如果Handler传入了async参数为true，这里的msg.isAsynchronous()为true，循环退出，即找出第一个不为空的同步message或者异步message；<br>&emsp;&emsp;找到后会计算该message的执行时间是不是现在这个时间点，如果还没到它该执行的时间点，则计算剩余的时间 nextPollTimeoutMillis，否则的话该message就是我们要找的message，然后取出该message，并改变链表的指针。<br>&emsp;&emsp;<strong>值得一提的是MessageQueue有个有趣的接口IdleHandler</strong>，看名字就知道它是个空的handler，当MessageQueue中没有消息的时候，如果有IdleHandler，则会调用queueIdle()方法，关于它的用法之后我们会讲到。<br>&emsp;&emsp;虽然是死循环，并且有阻塞的可能，但管道的一端一旦有消息进来，另一端就会唤醒，<strong>这也可以证明为什么死循环不会导致ANR</strong></p><h2 id="Message走了一圈又回到了Handler"><a href="#Message走了一圈又回到了Handler" class="headerlink" title="Message走了一圈又回到了Handler"></a>Message走了一圈又回到了Handler</h2><p><strong>Message从子线程走到了主线程，走了一圈又回到了Handler</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Handle system messages here.</span><br><span class="line">     */</span><br><span class="line">    public void dispatchMessage(Message msg) &#123;</span><br><span class="line">        if (msg.callback != null) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mCallback != null) &#123;</span><br><span class="line">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果Message设置了回调方法的话，则回调该方法，这个是当我们调用handler.post(Runnable able)时设置的，即这个callback就是runnable，他会调用用runnable的run方法；<br>&emsp;&emsp;如果Message没设置回调，并且handler设置了callback，这个callback是在构造方法里面设置的，之前讲到过，然后回调callback的handleMessage()；<br>&emsp;&emsp;如果前两步都没设置回调，则会调用自身的handleMessage(msg)方法，这个就是我们熟悉的，经常复写的方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;终上所述，一个message从子线程走到了主线程，这其中都是Handler的功劳，handler负责发送消息入队，然后处理消息，这样完成了一个操作从子线程到主线程的切换，其本质就是把一个操作从子线程传递给主线程。关于子线程更新UI的相关有趣操作我们会在另外的文章里讲。<br>&emsp;&emsp;<strong>Tips1</strong>: handler在哪个线程创建，持有的就是哪个线程的Looper，MessageQueue。当然你也可以在构造函数中显示的指定哪个线程的Looper。比如主线程创建的默认是主线程的mainLooper。<br>&emsp;&emsp;<strong>Tips2</strong>: 子线程创建Handler，由于子线程没有自己的Looper，所以必须显示调用Looper.prepare()创建Looper，并且显示的调用Looper.loop()方法开启消息循环。<br>&emsp;&emsp;<strong>Tips3</strong>: handler的底层用的是Linux的管道通信，至于为什么不用binder的原因，我们之后再讲；</p><h2 id="Message流向图"><a href="#Message流向图" class="headerlink" title="Message流向图"></a>Message流向图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-c0cbf4c97128315e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message_watermark.png" title="">                </div>                <div class="image-caption">message_watermark.png</div>            </figure><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3287039-1231c34c5275fdf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="time_watermark.png" title="">                </div>                <div class="image-caption">time_watermark.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android单线程模型&quot;&gt;&lt;a href=&quot;#Android单线程模型&quot; class=&quot;headerlink&quot; title=&quot;Android单线程模型&quot;&gt;&lt;/a&gt;Android单线程模型&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;我们知道进程是cpu&lt;strong&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="Handler" scheme="https://www.dyenter.top/tags/Handler/"/>
    
      <category term="MessageQueue" scheme="https://www.dyenter.top/tags/MessageQueue/"/>
    
      <category term="Message" scheme="https://www.dyenter.top/tags/Message/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（五）——使用ffmpeg播放音频</title>
    <link href="https://www.dyenter.top/2018/04/15/audio5/"/>
    <id>https://www.dyenter.top/2018/04/15/audio5/</id>
    <published>2018-04-15T06:28:44.000Z</published>
    <updated>2018-04-15T06:32:01.223Z</updated>
    
    <content type="html"><![CDATA[<p>上一节，我们做了很多准备工作，把ffmpeg源码编译成so供我们使用，这下我们终于可以来真正的使用它了。请大家使用最新版本你的AS，使用cmake，抛弃以前的mk。</p><h2 id="首先，创建一个新的project，记得勾上Include-C-support，然后一路next就ok了。"><a href="#首先，创建一个新的project，记得勾上Include-C-support，然后一路next就ok了。" class="headerlink" title="首先，创建一个新的project，记得勾上Include C++ support，然后一路next就ok了。"></a>首先，创建一个新的project，记得勾上Include C++ support，然后一路next就ok了。</h2><p>我们发现main下面多了一个cpp文件夹，这就是你放c/c++源代码的地方，为了用到我们的ffmpeg so文件，我们在main下面创建jniLibs,把编好的lib里面的so放进去。<br>PS：之前我们编译的平台是armeabi，如果你想要x86可修改脚本文件中相关配置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-b3d339e13cae94ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="111.jpg" title="">                </div>                <div class="image-caption">111.jpg</div>            </figure><p>其中main，sdl不是ffmpeg编译的so，大家不必在意。然后把include放进cpp文件夹，这些是需要的头文件，</p><h2 id="然后在cpp目录下创建play-audio-cpp"><a href="#然后在cpp目录下创建play-audio-cpp" class="headerlink" title="然后在cpp目录下创建play_audio.cpp"></a>然后在cpp目录下创建play_audio.cpp</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-465e48a05eb76058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a3.png" title="">                </div>                <div class="image-caption">a3.png</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &quot;log.h&quot;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#include &quot;AudioDevice.h&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注意加extern &quot;C&quot;，否则将按照C++的编译方法吧方法名改了，则java层找不到相应的方法</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_com_dy_ffmpeg_PlayMusicActivity_play(JNIEnv *env, jobject instance, jstring url_) &#123;</span><br><span class="line">    const char *url = env-&gt;GetStringUTFChars(url_, 0);</span><br><span class="line"></span><br><span class="line">    LOGD(&quot;play&quot;);</span><br><span class="line">    int code = play(url);</span><br><span class="line">    return code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_com_dy_ffmpeg_PlayMusicActivity_stop(JNIEnv *env, jobject instance) &#123;</span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line">    LOGD(&quot;stop&quot;);</span><br><span class="line">    int code = shutdown();</span><br><span class="line">    return code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下面贴出关键代码"><a href="#下面贴出关键代码" class="headerlink" title="下面贴出关键代码"></a>下面贴出关键代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 初始化操作，创建解码器</span><br><span class="line"> * @param file_name  文件名</span><br><span class="line"> * @param rate 采样率</span><br><span class="line"> * @param channel 通道数</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">int init(const char *file_name, int *rate, int *channel) &#123;</span><br><span class="line"></span><br><span class="line">    //初始化</span><br><span class="line">    av_register_all();</span><br><span class="line">    aFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //读取输入的音频文件地址</span><br><span class="line">    if (avformat_open_input(&amp;aFormatCtx, file_name, NULL, NULL) != 0) &#123;</span><br><span class="line">        LOGE(&quot;文件%s不存在！\n&quot;, file_name);</span><br><span class="line">        return -1; // Couldn&apos;t open file</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找文件的流信息</span><br><span class="line">    if (avformat_find_stream_info(aFormatCtx, NULL) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;文件流信息错误\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找到第一个音频帧</span><br><span class="line">    int i;</span><br><span class="line">    audioStream = -1;</span><br><span class="line">    for (i = 0; i &lt; aFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        if (aFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            audioStream = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (audioStream == -1) &#123;</span><br><span class="line">        LOGE(&quot;音频流未找到!&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    aCodecCtx = aFormatCtx-&gt;streams[audioStream]-&gt;codec;</span><br><span class="line"></span><br><span class="line">    //获取相应音频流的解码器</span><br><span class="line">    AVCodec *aCodec = avcodec_find_decoder(aCodecCtx-&gt;codec_id);</span><br><span class="line">    if (!aCodec) &#123;</span><br><span class="line">        fprintf(stderr, &quot;不支持的音频格式!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (avcodec_open2(aCodecCtx, aCodec, NULL) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;无法打开解码器！\n&quot;);</span><br><span class="line">        return -1; // Could not open codec</span><br><span class="line">    &#125;</span><br><span class="line">    //分配一个帧指针，指向解码后的原始帧</span><br><span class="line">    aFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    // 设置格式转换</span><br><span class="line">    swr = swr_alloc();</span><br><span class="line">    //输入通道数</span><br><span class="line">    av_opt_set_int(swr, &quot;in_channel_layout&quot;, aCodecCtx-&gt;channel_layout, 0);</span><br><span class="line">    //输出通道数</span><br><span class="line">    av_opt_set_int(swr, &quot;out_channel_layout&quot;, aCodecCtx-&gt;channel_layout, 0);</span><br><span class="line">    //输入采样率</span><br><span class="line">    av_opt_set_int(swr, &quot;in_sample_rate&quot;, aCodecCtx-&gt;sample_rate, 0);</span><br><span class="line">    //输出采样率</span><br><span class="line">    av_opt_set_int(swr, &quot;out_sample_rate&quot;, aCodecCtx-&gt;sample_rate, 0);</span><br><span class="line">    //输入采样位宽</span><br><span class="line">    av_opt_set_sample_fmt(swr, &quot;in_sample_fmt&quot;, aCodecCtx-&gt;sample_fmt, 0);</span><br><span class="line">    //输出采样位宽，16bit</span><br><span class="line">    av_opt_set_sample_fmt(swr, &quot;out_sample_fmt&quot;, AV_SAMPLE_FMT_S16, 0);</span><br><span class="line">    swr_init(swr);</span><br><span class="line"></span><br><span class="line">    // 分配PCM数据缓冲区大小</span><br><span class="line">    outputBufferSize = 8196;</span><br><span class="line">    outputBuffer = (uint8_t *) malloc(sizeof(uint8_t) * outputBufferSize);</span><br><span class="line"></span><br><span class="line">    // 返回采样率和通道数</span><br><span class="line">    *rate = aCodecCtx-&gt;sample_rate;</span><br><span class="line">    *channel = aCodecCtx-&gt;channels;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 获取PCM数据, 自动回调获取</span><br><span class="line">int getPCM(void **pcm, size_t *pcmSize) &#123;</span><br><span class="line">    LOGD(&quot;getPcm&quot;);</span><br><span class="line">    while (av_read_frame(aFormatCtx, &amp;packet) &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">        int frameFinished = 0;</span><br><span class="line">        // Is this a packet from the audio stream?</span><br><span class="line">        if (packet.stream_index == audioStream) &#123;</span><br><span class="line">            avcodec_decode_audio4(aCodecCtx, aFrame, &amp;frameFinished, &amp;packet);</span><br><span class="line"></span><br><span class="line">            if (frameFinished) &#123;</span><br><span class="line">                // data_size为音频数据所占的字节数</span><br><span class="line">                int data_size = av_samples_get_buffer_size(</span><br><span class="line">                        aFrame-&gt;linesize, aCodecCtx-&gt;channels,</span><br><span class="line">                        aFrame-&gt;nb_samples, aCodecCtx-&gt;sample_fmt, 1);</span><br><span class="line"></span><br><span class="line">                // 这里内存再分配可能存在问题</span><br><span class="line">                if (data_size &gt; outputBufferSize) &#123;</span><br><span class="line">                    outputBufferSize = data_size;</span><br><span class="line">                    outputBuffer = (uint8_t *) realloc(outputBuffer,</span><br><span class="line">                                                       sizeof(uint8_t) * outputBufferSize);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 音频格式转换</span><br><span class="line">                swr_convert(swr, &amp;outputBuffer, aFrame-&gt;nb_samples,</span><br><span class="line">                            (uint8_t const **) (aFrame-&gt;extended_data),</span><br><span class="line">                            aFrame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                // 返回pcm数据</span><br><span class="line">                *pcm = outputBuffer;</span><br><span class="line">                *pcmSize = data_size;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="然后是activity"><a href="#然后是activity" class="headerlink" title="然后是activity"></a>然后是activity</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package com.dy.ffmpeg;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.Button;</span><br><span class="line"></span><br><span class="line">public class PlayMusicActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;play_audio&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Button play;</span><br><span class="line">    private Button stop;</span><br><span class="line">    private String url;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_play_music);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        play = (Button) findViewById(R.id.play);</span><br><span class="line">        stop = (Button) findViewById(R.id.stop);</span><br><span class="line"></span><br><span class="line">        play.setOnClickListener(this);</span><br><span class="line">        stop.setOnClickListener(this);</span><br><span class="line">        //获取文件地址,注意把音频文件放在该目录下，或者修改成你自己需要的路径</span><br><span class="line">        String folderurl = Environment.getExternalStorageDirectory().getPath();</span><br><span class="line">        url = folderurl + &quot;/Valentine.mp3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        switch (v.getId()) &#123;</span><br><span class="line">            case R.id.play:</span><br><span class="line">                new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        int code = play(url);</span><br><span class="line">                        System.out.println(&quot;开始播放&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">            case R.id.stop:</span><br><span class="line">                new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        int code = stop();</span><br><span class="line">                        if (code == 0) &#123;</span><br><span class="line">                            System.out.println(&quot;停止成功&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private native int play(String url);</span><br><span class="line"></span><br><span class="line">    private native int stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接下来就是最重要的编写cmake"><a href="#接下来就是最重要的编写cmake" class="headerlink" title="接下来就是最重要的编写cmake"></a>接下来就是最重要的编写cmake</h2><p>接下来就是最重要的编写cmake</p><p>接下来就是最重要的编写cmake</p><p>上面我们做了这么多工作，gradle编译的时候怎么知道去哪找这些东西呢，就是重要的app目录下得CMakeLists.txt文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line">#设置so目录</span><br><span class="line">set(lib_src_DIR $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/$&#123;ANDROID_ABI&#125;)</span><br><span class="line">#添加头文件查找路径，包括引入库的和自己写的</span><br><span class="line">include_directories(</span><br><span class="line">     $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/include</span><br><span class="line">)</span><br><span class="line">#添加动态库或静态库，其中本地的动态库名称,位置可以由set_target_properties设置</span><br><span class="line">add_library(avcodec-57_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(avcodec-57_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                          $&#123;lib_src_DIR&#125;/libavcodec-57.so)</span><br><span class="line"></span><br><span class="line">add_library(avformat-57_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(avformat-57_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                     $&#123;lib_src_DIR&#125;/libavformat-57.so)</span><br><span class="line"></span><br><span class="line">add_library(avutil-55_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(avutil-55_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                     $&#123;lib_src_DIR&#125;/libavutil-55.so)</span><br><span class="line"></span><br><span class="line">add_library(swresample-2_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(swresample-2_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                     $&#123;lib_src_DIR&#125;/libswresample-2.so)</span><br><span class="line"></span><br><span class="line">add_library(swscale-4_lib SHARED IMPORTED)</span><br><span class="line">set_target_properties(swscale-4_lib PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                     $&#123;lib_src_DIR&#125;/libswscale-4.so)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># build application&apos;s shared lib</span><br><span class="line">#这里是你自己编写的c/c++，因为用到ffmpeg的so，所以下面要链接它的库</span><br><span class="line">add_library(play_video SHARED</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/play_video.cpp)</span><br><span class="line">add_library(decode_video SHARED</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/decode_video.cpp)</span><br><span class="line">add_library(play_audio SHARED</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/play_audio.cpp</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/AudioDevice.c</span><br><span class="line">         $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/FFmpegAudioPlay.c)</span><br><span class="line">#通过名称查找并引入库，可以引入 NDK 中的库，比如日志模块</span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              log )</span><br><span class="line">#添加参加编译的库名称，也可以是绝对路径，注意被依赖的模块写在后面</span><br><span class="line">#特别注意，你想生成几个so，就要写几个link，写在一个link里面是错误的</span><br><span class="line">target_link_libraries(play_video</span><br><span class="line">log</span><br><span class="line">android</span><br><span class="line">avcodec-57_lib</span><br><span class="line">avformat-57_lib</span><br><span class="line">avutil-55_lib</span><br><span class="line">swresample-2_lib</span><br><span class="line">swscale-4_lib</span><br><span class="line">)</span><br><span class="line">target_link_libraries(decode_video</span><br><span class="line">log</span><br><span class="line">android</span><br><span class="line">avcodec-57_lib</span><br><span class="line">avformat-57_lib</span><br><span class="line">avutil-55_lib</span><br><span class="line">swresample-2_lib</span><br><span class="line">swscale-4_lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#我们需要opensl es来辅助播放，注意加入opensl es</span><br><span class="line">target_link_libraries(play_audio</span><br><span class="line">log</span><br><span class="line">OpenSLES</span><br><span class="line">android</span><br><span class="line">avcodec-57_lib</span><br><span class="line">avformat-57_lib</span><br><span class="line">avutil-55_lib</span><br><span class="line">swresample-2_lib</span><br><span class="line">swscale-4_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="然后编译执行，done，完整demo请移步我的github"><a href="#然后编译执行，done，完整demo请移步我的github" class="headerlink" title="然后编译执行，done，完整demo请移步我的github"></a>然后编译执行，done，完整demo请移步<a href="https://github.com/dengyuaner/ffmpegDemo" target="_blank" rel="noopener">我的github</a></h3><p>参考<a href="http://blog.csdn.net/leixiaohua1020/article/details/47008825" target="_blank" rel="noopener">http://blog.csdn.net/leixiaohua1020/article/details/47008825</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节，我们做了很多准备工作，把ffmpeg源码编译成so供我们使用，这下我们终于可以来真正的使用它了。请大家使用最新版本你的AS，使用cmake，抛弃以前的mk。&lt;/p&gt;
&lt;h2 id=&quot;首先，创建一个新的project，记得勾上Include-C-support，然后一
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/categories/Android/NDK/"/>
    
      <category term="ffmpeg" scheme="https://www.dyenter.top/categories/Android/NDK/ffmpeg/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="音视频" scheme="https://www.dyenter.top/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/tags/NDK/"/>
    
      <category term="ffmpeg" scheme="https://www.dyenter.top/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（四）——ffmpeg的编译</title>
    <link href="https://www.dyenter.top/2018/04/15/audio4/"/>
    <id>https://www.dyenter.top/2018/04/15/audio4/</id>
    <published>2018-04-15T06:25:28.000Z</published>
    <updated>2018-04-15T06:29:16.861Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前几节我们讲的都是调用android原生API来进行音频的播放，编解码等操作，是在java层面，而且由于<a href="https://developer.android.google.cn/reference/android/media/MediaCodec.html" target="_blank" rel="noopener">MediaCodec</a>兼容性的限制，导致无法在API16以下使用，所以我们不得不放弃java层，转而寻求更为成熟的c/c++处理方案，再用jni去调用。所以，大名鼎鼎的<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">ffmpeg</a>闪亮登场了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-4291bd7ba1434eb0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a1.jpg" title="">                </div>                <div class="image-caption">a1.jpg</div>            </figure><p>&emsp;&emsp;那么问题来了，怎么使用这个玩意儿了？接下来跟着我走</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-32f0ef86ceebe8c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a2.jpg" title="">                </div>                <div class="image-caption">a2.jpg</div>            </figure><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>&emsp;&emsp;去官网下载源码<a href="http://ffmpeg.org/download.html，最新版本是3.3.3，下载完成后我们在linux下把源码编译成android能用的so文件，当然你也可以直接打开cmd命令去使用它，熟悉它的一些命令。" target="_blank" rel="noopener">http://ffmpeg.org/download.html，最新版本是3.3.3，下载完成后我们在linux下把源码编译成android能用的so文件，当然你也可以直接打开cmd命令去使用它，熟悉它的一些命令。</a></p><p>&emsp;&emsp;我这里用的是VirtualBox+Ubuntu的方式去编译，为了方便，我这里专门设置了共享文件夹方便windows和ubuntu传输文件。共享文件夹的设置大家请百度吧。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-e223d9e6b4d714b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a3.jpg" title="">                </div>                <div class="image-caption">a3.jpg</div>            </figure></p><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>首先要安装NDK，下载好NDK后解压在用户根目录，并配置好环境变量</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-dcfddc9f4eee7857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a3.png" title="">                </div>                <div class="image-caption">a3.png</div>            </figure><p>输入gedit ~/.bashrc,加入以下代码<br>export NDK_HOME=/home/dy/android-ndk-r14b<br>注意换成你自己的路径，保存然后输入source ~/.bashrc编译一下即可</p><p>你可以<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>一下有没有安装成功：$ cd $NDK_ROOT$ ./ndk-build NDK_PROJECT_PATH=$NDK_ROOT/samples/two-libs</p><p>在根目录下新建一个工程media，用于存放ffmpeg，和编译脚本，把你下载的ffmpeg源码放进来。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-511d4ec3dbfdad11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a4.png" title="">                </div>                <div class="image-caption">a4.png</div>            </figure><p>然后找到ffmpeg文件夹下得configure文件，替换其中的几行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;</span><br><span class="line">LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</span><br><span class="line">SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;</span><br><span class="line">SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;</span><br><span class="line">将其修改成：</span><br><span class="line">SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;</span><br><span class="line">LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</span><br><span class="line">SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;</span><br><span class="line">SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;为什么要这么做呢，这是因为如果直接按照未修改的配置进行编译，结果编译出来的so文件类似libavcodec.so.55.39.101，版本号位于so之后，Android无法加载</p><h2 id="接下来在ffmpeg目录下新建脚本文件buildff-sh，文件内容如下"><a href="#接下来在ffmpeg目录下新建脚本文件buildff-sh，文件内容如下" class="headerlink" title="接下来在ffmpeg目录下新建脚本文件buildff.sh，文件内容如下"></a>接下来在ffmpeg目录下新建脚本文件buildff.sh，文件内容如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#清除上次编译的东西</span><br><span class="line">make clean</span><br><span class="line">#配置NDK路径,注意换成你自己的路径</span><br><span class="line">export NDK=/home/dy/android-ndk-r14b</span><br><span class="line">#配置工具链，注意查看是否有该路径，各个ndk版本不同，路径会有不同</span><br><span class="line">export PREBUILT=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt</span><br><span class="line">#配置平台，同上注意路径</span><br><span class="line">export PLATFORM=$NDK/platforms/android-9/arch-arm</span><br><span class="line">#配置编译好了之后的文件输出目录，$(pwd)当前目录下</span><br><span class="line">export PREFIX=$(pwd)/android/</span><br><span class="line">build_one()&#123;</span><br><span class="line">  ./configure --target-os=linux --prefix=$PREFIX \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--enable-runtime-cpudetect \</span><br><span class="line">--disable-asm \</span><br><span class="line">--arch=arm \</span><br><span class="line">--cc=$PREBUILT/linux-x86_64/bin/arm-linux-androideabi-gcc \</span><br><span class="line">--cross-prefix=$PREBUILT/linux-x86_64/bin/arm-linux-androideabi- \</span><br><span class="line">--disable-stripping \</span><br><span class="line">--nm=$PREBUILT/linux-x86_64/bin/arm-linux-androideabi-nm \</span><br><span class="line">--sysroot=$PLATFORM \</span><br><span class="line">--enable-gpl --enable-shared --disable-static --enable-nonfree --enable-version3 --enable-small \</span><br><span class="line">--enable-zlib --disable-ffprobe --disable-ffplay --disable-ffmpeg --disable-ffserver --disable-debug \</span><br><span class="line">--extra-cflags=&quot;-fPIC -DANDROID -D__thumb__ -mthumb -Wfatal-errors -Wno-deprecated -mfloat-abi=softfp -marm -march=armv7-a&quot; </span><br><span class="line">&#125;</span><br><span class="line">build_one</span><br><span class="line"></span><br><span class="line">#4线程编译</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>然后输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 ./buildff.sh</span><br><span class="line"> ./build_android.sh</span><br></pre></td></tr></table></figure></p><p>就开始编译了</p><p>编译完成后会在ffmpeg下生成android文件夹，里面就是include源文件和编译好的so文件，然后通过共享文件夹把android文件夹传给windows，供我们使用即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-0575ff4443906d56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a5.png" title="">                </div>                <div class="image-caption">a5.png</div>            </figure><p>最后上个妹子图缓解一下视力，接下来就是在AS里面运用了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-eb9dd8820032b5cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6VD[D]L1MLP{EEZX8S498DG.png" title="">                </div>                <div class="image-caption">6VD[D]L1MLP{EEZX8S498DG.png</div>            </figure><p><a href="https://www.dyenter.top/2018/04/15/audio5/">下一篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;前几节我们讲的都是调用android原生API来进行音频的播放，编解码等操作，是在java层面，而且由于&lt;a href=&quot;https://developer.android.google.cn/reference/android/media/Medi
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/categories/Android/NDK/"/>
    
      <category term="ffmpeg" scheme="https://www.dyenter.top/categories/Android/NDK/ffmpeg/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="音视频" scheme="https://www.dyenter.top/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/tags/NDK/"/>
    
      <category term="ffmpeg" scheme="https://www.dyenter.top/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（三）——音频编解码</title>
    <link href="https://www.dyenter.top/2018/04/15/audio3/"/>
    <id>https://www.dyenter.top/2018/04/15/audio3/</id>
    <published>2018-04-15T06:21:30.000Z</published>
    <updated>2018-04-15T06:25:17.222Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一节中我们讲了怎么采集音频并播放，由于AudioRecord采集的是PCM数据，没有经过处理，所有播放的时候会有杂音，啸叫等现象出现。因此处理掉这些不需要的数据就是本节的内容，编码与解码。</p><h2 id="原理知识"><a href="#原理知识" class="headerlink" title="原理知识"></a>原理知识</h2><p>&emsp;&emsp;Android官方提供给我们的用于编解码的类是<a href="https://developer.android.google.cn/reference/android/media/MediaCodec.html" target="_blank" rel="noopener">MediaCodec</a>,它是android 4.1（API 16）才引入的，所以只能工作于andorid4.1以上的手机，如果想兼容4.1以下版本的手机，只能使用第三方库，如大名鼎鼎的<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">ffmpeg</a>,B站的<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">ijkplayer</a>等。</p><h3 id="MediaCodec介绍"><a href="#MediaCodec介绍" class="headerlink" title="MediaCodec介绍"></a>MediaCodec介绍</h3><p>（1）提供了一套访问 Android 底层多媒体模块的接口，主要是音视频的编解码接口</p><p>（2）在Android上，预设的多媒体框架是基于第三方PacketVideo公司的OpenCORE来实现，OpenCORE的优点是兼顾了跨平台的移植性，而且已经过多方验证，所以相对来说较为稳定；缺点是国语庞大复杂，需要耗费相当多的时间去维护。因此从Android 2.0开始，Google引进了较为简洁的StageFright。Android 底层多媒体模块采用的是 StageFright 框架，它是基于OpenMax标准实现的，任何 Android 底层编解码模块的实现，都必须遵循 OpenMax 标准。值得一提的是，OpenMAX是Khronos制定的API，Khronos也是OpenGL的制定者。Google 官方默认提供了一系列的软件编解码器：包括：OMX.google.h264.encoder，OMX.google.h264.encoder， OMX.google.aac.encoder， OMX.google.aac.decoder 等等，而硬件编解码功能，则需要由芯片厂商依照 OpenMax 框架标准来完成，所以，一般采用不同芯片型号的手机，硬件编解码的实现和性能是不同的</p><p>（3）Android 应用层统一由 MediaCodec API 来提供各种音视频编解码功能，由参数配置来决定采用何种编解码算法、是否采用硬件编解码加速等等</p><h3 id="MediaCodec原理"><a href="#MediaCodec原理" class="headerlink" title="MediaCodec原理"></a>MediaCodec原理</h3><p><img src="http://upload-images.jianshu.io/upload_images/3287039-c2a7d9ad88655df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6b5f1f9ee2d1075465f27078176e4e08_b.png"></p><p>根据android官方文档的描述，MediaCodec的核心就是使用缓冲区队列来操作数据，使用流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- createEncoderByType/createDecoderByType</span><br><span class="line">- configure</span><br><span class="line">- start</span><br><span class="line">- while(1) &#123;</span><br><span class="line">    - dequeueInputBuffer</span><br><span class="line">    - queueInputBuffer</span><br><span class="line">    - dequeueOutputBuffer</span><br><span class="line">    - releaseOutputBuffer</span><br><span class="line">&#125;</span><br><span class="line">- stop</span><br><span class="line">- release</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;MediaCodec 架构上采用了2个缓冲区队列，异步处理数据，下面描述的 Client 和 MediaCodec 模块是并行工作的（注：这里的 Client 就是指 “开发者，API 的使用者”）：</p><p>（1）Client 从 input 缓冲区队列申请 empty buffer [dequeueInputBuffer]</p><p>（2）Client 把需要编解码的数据拷贝到 empty buffer，然后放入 input 缓冲区队列 [queueInputBuffer]</p><p>（3）MediaCodec 模块从 input 缓冲区队列取一帧数据进行编解码处理</p><p>（4）编解码处理结束后，MediaCodec 将原始数据 buffer 置为 empty 后放回 input 缓冲区队列，将编解码后的数据放入到 output 缓冲区队列</p><p>（5）Client 从 output 缓冲区队列申请编解码后的 buffer [dequeueOutputBuffer]</p><p>（6）Client 对编解码后的 buffer 进行渲染/播放</p><p>（7）渲染/播放完成后，Client 再将该 buffer 放回 output 缓冲区队列 [releaseOutputBuffer]</p><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>&emsp;&emsp;那么杂实际操作中，我们该怎么使用呢，MediaCodec给我们提供了同步和异步两种使用方式,而在Android 5.0之后又引入了心得Buffer API，所以使用的时候必须兼容考虑这点</p><h3 id="同步使用"><a href="#同步使用" class="headerlink" title="同步使用"></a>同步使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//name既是媒体文件的类型，如audio/3gpp，详情参考MediaFormat的MIMETYPE常量</span><br><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line">codec.configure(format, …);</span><br><span class="line">MediaFormat outputFormat = codec.getOutputFormat(); // option B</span><br><span class="line">codec.start();</span><br><span class="line">for (;;) &#123;</span><br><span class="line">  ////获取可用的inputBuffer -1代表一直等待，0表示不等待 建议-1,避免丢帧</span><br><span class="line">  int inputBufferId = codec.dequeueInputBuffer(-1);</span><br><span class="line">  if (inputBufferId &gt;= 0) &#123;</span><br><span class="line">    ByteBuffer inputBuffer = codec.getInputBuffer(…);</span><br><span class="line">    // fill inputBuffer with valid data</span><br><span class="line">    …</span><br><span class="line">    codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">  &#125;</span><br><span class="line">  //执行上面的操作后就把待编解码的数据存入了输入缓冲区，然后下一步就是操作然后把编解码的数据存入输出缓冲区</span><br><span class="line">  int outputBufferId = codec.dequeueOutputBuffer(…);</span><br><span class="line">  if (outputBufferId &gt;= 0) &#123;</span><br><span class="line">    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</span><br><span class="line">    MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</span><br><span class="line">    // bufferFormat is identical to outputFormat</span><br><span class="line">    // outputBuffer is ready to be processed or rendered.</span><br><span class="line">    …</span><br><span class="line">    codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">  &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">    // Subsequent data will conform to new format.</span><br><span class="line">    // Can ignore if using getOutputFormat(outputBufferId)</span><br><span class="line">    outputFormat = codec.getOutputFormat(); // option B</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">codec.stop();</span><br><span class="line">codec.release();</span><br></pre></td></tr></table></figure><h3 id="异步使用"><a href="#异步使用" class="headerlink" title="异步使用"></a>异步使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line">MediaFormat mOutputFormat; // member variable</span><br><span class="line">codec.setCallback(new MediaCodec.Callback() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  void onInputBufferAvailable(MediaCodec mc, int inputBufferId) &#123;</span><br><span class="line">    ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId);</span><br><span class="line">    // fill inputBuffer with valid data</span><br><span class="line">    …</span><br><span class="line">    codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  void onOutputBufferAvailable(MediaCodec mc, int outputBufferId, …) &#123;</span><br><span class="line">    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</span><br><span class="line">    MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</span><br><span class="line">    // bufferFormat is equivalent to mOutputFormat</span><br><span class="line">    // outputBuffer is ready to be processed or rendered.</span><br><span class="line">    …</span><br><span class="line">    codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  void onOutputFormatChanged(MediaCodec mc, MediaFormat format) &#123;</span><br><span class="line">    // Subsequent data will conform to new format.</span><br><span class="line">    // Can ignore if using getOutputFormat(outputBufferId)</span><br><span class="line">    mOutputFormat = format; // option B</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  void onError(…) &#123;</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">codec.configure(format, …);</span><br><span class="line">mOutputFormat = codec.getOutputFormat(); // option B</span><br><span class="line">codec.start();</span><br><span class="line">// wait for processing to complete</span><br><span class="line">codec.stop();</span><br><span class="line">codec.release();</span><br></pre></td></tr></table></figure><h3 id="android-5-0以下使用"><a href="#android-5-0以下使用" class="headerlink" title="android 5.0以下使用"></a>android 5.0以下使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> MediaCodec codec = MediaCodec.createByCodecName(name);</span><br><span class="line"> codec.configure(format, …);</span><br><span class="line"> codec.start();</span><br><span class="line">//API的区别在这里</span><br><span class="line"> ByteBuffer[] inputBuffers = codec.getInputBuffers();</span><br><span class="line"> ByteBuffer[] outputBuffers = codec.getOutputBuffers();</span><br><span class="line"> for (;;) &#123;</span><br><span class="line">   int inputBufferId = codec.dequeueInputBuffer(…);</span><br><span class="line">   if (inputBufferId &gt;= 0) &#123;</span><br><span class="line">     // fill inputBuffers[inputBufferId] with valid data</span><br><span class="line">     …</span><br><span class="line">     codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">   &#125;</span><br><span class="line">   int outputBufferId = codec.dequeueOutputBuffer(…);</span><br><span class="line">   if (outputBufferId &gt;= 0) &#123;</span><br><span class="line">     // outputBuffers[outputBufferId] is ready to be processed or rendered.</span><br><span class="line">     …</span><br><span class="line">     codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">     outputBuffers = codec.getOutputBuffers();</span><br><span class="line">   &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">     // Subsequent data will conform to new format.</span><br><span class="line">     MediaFormat format = codec.getOutputFormat();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> codec.stop();</span><br><span class="line"> codec.release();</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>&emsp;&emsp;在实际开发中，由于API版本的限制，我们很少使用android原生api进行编解码的操作，一般使用第三方库或者自己写c++写native代码打包成so库然后使用。但是我们必须了解其API原理，更进一步了解Java层的API是调用的C++的api来操作的，对于我们学习ndk开发及了解底层原理很有帮助，实例代码已上传至我的<a href="https://github.com/dengyuaner/AudioDemo" target="_blank" rel="noopener">github</a>，代码内容包括录音，播放，编码，解码等。<br><a href="https://www.dyenter.top/2018/04/15/audio4/">下一篇</a><br>参考：<br><a href="https://developer.android.google.cn/reference/android/media/MediaCodec.html" target="_blank" rel="noopener">android mediacodec</a><br><a href="https://zhuanlan.zhihu.com/p/20706983" target="_blank" rel="noopener">音频数据的编解码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;上一节中我们讲了怎么采集音频并播放，由于AudioRecord采集的是PCM数据，没有经过处理，所有播放的时候会有杂音，啸叫等现象出现。因此处理掉这些不需要的数据就是本节的内容，编码与解码。&lt;/p&gt;
&lt;h2 id=&quot;原理知识&quot;&gt;&lt;a href=&quot;#原
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/categories/Android/NDK/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="音视频" scheme="https://www.dyenter.top/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（二）——音频采集与播放</title>
    <link href="https://www.dyenter.top/2018/04/15/audio2/"/>
    <id>https://www.dyenter.top/2018/04/15/audio2/</id>
    <published>2018-04-15T05:46:24.000Z</published>
    <updated>2018-04-15T05:49:59.370Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一节中我们介绍了音频的一些基本知识，这一节我们来讲述如何采集音频数据，然后将采集到的音频播放出来。</p><p>&emsp;&emsp;Android SDK 提供了两套音频采集的API，分别是：MediaRecorder 和 AudioRecord。根据官方文档的说法，该AudioRecord类管理Java应用程序的音频资源记录来自平台的音频输入硬件音频。<br>这是通过“拉”（读）从AudioRecord对象中的数据来实现的。<br>&emsp;&emsp;该应用程序负责轮询使用以下三种方法之一AudioRecord对象在时间：<br>&emsp;&emsp;read(byte[], int, int)，read(byte[], int, int)，read(short[], int, int)，read(short[], int, int)或read(ByteBuffer, int)，read(java.nio.ByteBuffer, int)。要使用的方法的选择将基于这是最方便的AudioRecord的用户的声音数据的存储格式。</p><p>&emsp;&emsp;可以看见，它是更接近底层的方法，我们可以拿到byte原始的pcm数据。而MediaRecorder是更上层的API，它不仅可以记录音频，还可以录制视频，它的工作流如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-7643ed2a00e3df54.gif?imageMogr2/auto-orient/strip" alt="mediarecorder_state_diagram.gif" title="">                </div>                <div class="image-caption">mediarecorder_state_diagram.gif</div>            </figure></p><p>同理MediaPlayer和AudioTrack。</p><p>本节我们将用AudioRecord来采集音频并用AudioTrack播放出来</p><h2 id="使用AudioRecord之前的准备工作"><a href="#使用AudioRecord之前的准备工作" class="headerlink" title="使用AudioRecord之前的准备工作"></a>使用AudioRecord之前的准备工作</h2><h3 id="首先，我们了解一下-AudioRecord-的工作流程："><a href="#首先，我们了解一下-AudioRecord-的工作流程：" class="headerlink" title="首先，我们了解一下 AudioRecord 的工作流程："></a>首先，我们了解一下 AudioRecord 的工作流程：</h3><p>（1） 配置参数，初始化内部的音频缓冲区<br>（2） 开始采集<br>（3） 新建一个线程，不断地从 AudioRecord 的缓冲区将音频数据“读”出来，注意，这个过程一定要及时，否则就会出现“overrun”的错误，该错误在音频开发中比较常见，意味着应用层没有及时地“取走”音频数据，导致内部的音频缓冲区溢出。<br>（4） 停止采集，释放资源<br>注意：缓冲区即类似生产者-消费者模型，AudioRecord把采集到的音频数据放在缓冲区，我们从缓冲区取出数据。我们不要自己设置缓冲区的大小，因为采集音频实际上是调用底层的c函数，这跟具体的设备相关，我们需要通过下面的方法可以获得最小缓冲区的大小：<br>AudioRecord.getMinBufferSize(sampleRateInHz, channelInConfig, audioFormat);<br>它实际上是调用的native_get_min_buff_size(int sampleRateInHz, int channelCount, int audioFormat);</p><h3 id="然后，肯定要申请权限"><a href="#然后，肯定要申请权限" class="headerlink" title="然后，肯定要申请权限"></a>然后，肯定要申请权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="接下来，设置相关的参数，如采样率，通道数，位宽等。"><a href="#接下来，设置相关的参数，如采样率，通道数，位宽等。" class="headerlink" title="接下来，设置相关的参数，如采样率，通道数，位宽等。"></a>接下来，设置相关的参数，如采样率，通道数，位宽等。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int recBufSize, playBufSize;//采集缓冲区的大小，播放缓冲区的大小</span><br><span class="line">private static final int sampleRateInHz = 44100;//采样率</span><br><span class="line">private static final int channelInConfig = AudioFormat.CHANNEL_IN_MONO;//采集通道数</span><br><span class="line">private static final int channelOutConfig = AudioFormat.CHANNEL_OUT_MONO;//播放通道数</span><br><span class="line">private static final int audioFormat = AudioFormat.ENCODING_PCM_16BIT;//位数</span><br><span class="line"></span><br><span class="line">private AudioRecord mAudioRecord;</span><br><span class="line">private AudioTrack mAudioTrack;</span><br><span class="line"></span><br><span class="line">private boolean isRecording;//采集状态</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">recBufSize = AudioRecord.getMinBufferSize(sampleRateInHz, channelInConfig, audioFormat);</span><br><span class="line">playBufSize = AudioTrack.getMinBufferSize(sampleRateInHz, channelOutConfig, audioFormat);</span><br><span class="line"></span><br><span class="line">mAudioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC,</span><br><span class="line">            sampleRateInHz, channelInConfig, audioFormat, recBufSize);</span><br><span class="line"></span><br><span class="line">mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC,</span><br><span class="line">            sampleRateInHz, channelOutConfig, audioFormat, playBufSize, AudioTrack.MODE_STREAM);</span><br></pre></td></tr></table></figure><h3 id="然后就是用线程去取数据"><a href="#然后就是用线程去取数据" class="headerlink" title="然后就是用线程去取数据"></a>然后就是用线程去取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class RecordThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            //采集的音频缓冲区</span><br><span class="line">            byte[] buffer = new byte[recBufSize];</span><br><span class="line">            //开始采集</span><br><span class="line">            mAudioRecord.startRecording();</span><br><span class="line">            //采集的同时播放</span><br><span class="line">            mAudioTrack.play();</span><br><span class="line"></span><br><span class="line">            while (isRecording) &#123;</span><br><span class="line">                 //从音频缓冲区取出声音数据</span><br><span class="line">                int bufferReadResult = mAudioRecord.read(buffer, 0, recBufSize);</span><br><span class="line">                //播放音频缓冲区</span><br><span class="line">                byte[] tempBuffer = new byte[bufferReadResult];</span><br><span class="line"></span><br><span class="line">                 //把音频数据拷贝到播放缓冲区</span><br><span class="line">                System.arraycopy(buffer, 0, tempBuffer, 0, bufferReadResult);</span><br><span class="line">                //播放声音</span><br><span class="line">                mAudioTrack.write(tempBuffer, 0, tempBuffer.length);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //结束播放和采集</span><br><span class="line">            mAudioTrack.stop();</span><br><span class="line">            mAudioRecord.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以设置按钮停止采集与播放，只需要设置isRecording为false即可。</p><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>当你拿到手机上使用时，会发现声音会有很大回音，但是带上耳机后就没了。</p><p>这是由于采集的原始pcm数据没有降噪处理，这种现象叫啸叫。所以这也是为什么我们要编码去除冗余的信息的原因，下一节我们将讲怎么编码音频数据。</p><h2 id="下一篇"><a href="#下一篇" class="headerlink" title="下一篇"></a><a href="https://www.dyenter.top/2018/04/15/audio3/">下一篇</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;上一节中我们介绍了音频的一些基本知识，这一节我们来讲述如何采集音频数据，然后将采集到的音频播放出来。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Android SDK 提供了两套音频采集的API，分别是：MediaRecorder 和 AudioReco
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/categories/Android/NDK/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="音视频" scheme="https://www.dyenter.top/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android音频开发（一）——基础知识</title>
    <link href="https://www.dyenter.top/2018/04/15/audio1/"/>
    <id>https://www.dyenter.top/2018/04/15/audio1/</id>
    <published>2018-04-15T05:30:33.000Z</published>
    <updated>2018-04-15T05:36:47.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;前几天看到一个新闻说陌陌靠直播盈利了，在以前的印象中，陌陌只是一个那啥的软件，现在居然靠直播营收，说明现在直播的火热，因此我们有必要了解下Android音视频方面的知识。我们先了解一下音频。</p><h2 id="音频的基本概念"><a href="#音频的基本概念" class="headerlink" title="音频的基本概念"></a>音频的基本概念</h2><h3 id="采样率（sampleRateInHz）"><a href="#采样率（sampleRateInHz）" class="headerlink" title="采样率（sampleRateInHz）"></a>采样率（sampleRateInHz）</h3><p>&emsp;&emsp;我们知道，自然界中的声音是连续的模拟信号，而计算机只能识别二进制，因此需要把模拟信号转化为数字信号，这个过程就叫做采样。顾名思义，就是选取一些间断的点来转化。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-ce1ce1c488ff7fcd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="d53f8794a4c27d1e5f214be71bd5ad6eddc43889.jpg" title="">                </div>                <div class="image-caption">d53f8794a4c27d1e5f214be71bd5ad6eddc43889.jpg</div>            </figure><br>&emsp;&emsp;如上图，当采样周期越短，即采样率越高，选取的点越多，则存储到计算机中的声音播放出来的效果更接近原声，根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音，所以采样率越高越好吗？<br>当然不是，通常人耳能听到频率范围大约在20Hz～20kHz之间的声音，为了保证声音不失真，采样频率应在40kHz以上。常用的音频采样频率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz等。</p><h3 id="采样精度（位宽audioFormat）"><a href="#采样精度（位宽audioFormat）" class="headerlink" title="采样精度（位宽audioFormat）"></a>采样精度（位宽audioFormat）</h3><p>&emsp;&emsp;上图中，每一个红色的采样点，都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit等等，位数越多，表示得就越精细，声音质量自然就越好，当然，数据量也会成倍增大。为了保持android各个版本的兼容性，一般选择16bit。</p><h3 id="声道数（channelConfig）"><a href="#声道数（channelConfig）" class="headerlink" title="声道数（channelConfig）"></a>声道数（channelConfig）</h3><p>&emsp;&emsp;声道数是指支持能不同发声的音响的个数，常见的有单通道，双通道，立体声四通道等</p><h3 id="音频帧（bufferSizeInBytes）"><a href="#音频帧（bufferSizeInBytes）" class="headerlink" title="音频帧（bufferSizeInBytes）"></a>音频帧（bufferSizeInBytes）</h3><p>&emsp;&emsp;大家都知道视频帧就是一幅图像，音频的帧的概念没有视频帧那么清晰，几乎所有视频编码格式都可以简单的认为一帧就是编码后的一副图像。但音频帧跟编码格式相关，它是各个编码标准自己实现的。在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的，我们可以计算一下一帧音频帧的大小：<br>假设某音频信号是采样率为44.1kHz、双通道、位宽为16bit，40ms一帧，则一帧音频数据的大小为：<br>                          int size =44100 x 2 x 16bit x 0.04s = 56488 bit = 7056 byte</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>&emsp;&emsp;android中采集音频后得到的是原始的PCM数据，这些数据代表着无损的原始数字音频信号，添加一些文件头信息，就可以存储为WAV文件了，它是一种由微软和IBM联合开发的用于音频数字存储的标准，可以很容易地被解析和播放。而其他格式如mp3等要经过编码后才能播放，编码的目的就是去除冗余信息。所以，一般你会发现你把mp3格式的音频转为wav后体积会变很大。</p><p>&emsp;&emsp;再简单介绍一下音频数据压缩的最基本的原理：因为有冗余信息，所以可以压缩。</p><p>&emsp;&emsp;（1） 频谱掩蔽效应： 人耳所能察觉的声音信号的频率范围为20Hz～20KHz，在这个频率范围以外的音频信号属于冗余信号。<br>&emsp;&emsp;（2） 时域掩蔽效应： 当强音信号和弱音信号同时出现时，弱信号会听不到，因此，弱音信号也属于冗余信号。</p><h2 id="Android应用层提供的API"><a href="#Android应用层提供的API" class="headerlink" title="Android应用层提供的API"></a>Android应用层提供的API</h2><p>&emsp;&emsp;android提供了很多丰富的类供我们处理音频，而这些类实际上是通过jni调用了c/c++的函数。</p><p>&emsp;&emsp;音频采集： MediaRecoder，AudioRecord</p><p>&emsp;&emsp;音频播放： SoundPool，MediaPlayer，AudioTrack </p><p>&emsp;&emsp;音频编解码： MediaCodec</p><p>&emsp;&emsp;NDK API： OpenSL ES</p><h2 id="下一节，我们将讲述怎么录制音频"><a href="#下一节，我们将讲述怎么录制音频" class="headerlink" title="下一节，我们将讲述怎么录制音频"></a><a href="https://www.dyenter.top/2018/04/15/audio2/">下一节</a>，我们将讲述怎么录制音频</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;前几天看到一个新闻说陌陌靠直播盈利了，在以前的印象中，陌陌只是一个那啥的软件，现在居然靠直播营收，说明现在直播的火热
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/categories/Android/NDK/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="音视频" scheme="https://www.dyenter.top/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="NDK" scheme="https://www.dyenter.top/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>listview相关问题——只更新某一个item</title>
    <link href="https://www.dyenter.top/2018/04/15/listview2/"/>
    <id>https://www.dyenter.top/2018/04/15/listview2/</id>
    <published>2018-04-15T05:28:27.000Z</published>
    <updated>2018-04-15T05:29:41.195Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，更新listview通常调用修改adapter的数据源，然后调用adapter的notifyDataSetChanged();</p><p>但是有时候只是需要更新某一个指定的item，比如微信聊天应用中。这个时候，我们不需要去调用Adapter的notifyDataSetChanged（）方法。可以写一个updateItem(int position)的方法去更新指定项,这样代价就会小一些。</p><p>那么我们怎么拿到这个item然后去更新它的数据呢，其实listview提供了getChildAt(int index)方法让我们去获取，这个方法其实是ViewGroup的方法。并且由于一般使用了ViewHolder缓存机制，所以我们获取子item的时候要注意在可见区域的position去获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void updataItem(int position) &#123;</span><br><span class="line">      int firstVisiblePos = listView.getFirstVisiblePosition();</span><br><span class="line">      int lastVisibalePos = listView.getLastVisiblePosition();</span><br><span class="line">      if (position &gt;= firstVisiblePos &amp;&amp; position &lt;= lastVisibalePos) &#123;</span><br><span class="line">          View view = listView.getChildAt(position - firstVisiblePos);</span><br><span class="line">          ViewHolder viewHolder = (ViewHolder) view.getTag();</span><br><span class="line">          //然后使用viewholder去更新需要更新的view。 </span><br><span class="line">          //TextView textView = (TextView) viewHolder.findViewById(R.id.textView);</span><br><span class="line">          //textView.setText(&quot;11111&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们都知道，更新listview通常调用修改adapter的数据源，然后调用adapter的notifyDataSetChanged();&lt;/p&gt;
&lt;p&gt;但是有时候只是需要更新某一个指定的item，比如微信聊天应用中。这个时候，我们不需要去调用Adapter的notifyD
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="ListView" scheme="https://www.dyenter.top/tags/ListView/"/>
    
      <category term="EditText" scheme="https://www.dyenter.top/tags/EditText/"/>
    
  </entry>
  
  <entry>
    <title>Android近场通讯——NFC(二)</title>
    <link href="https://www.dyenter.top/2018/04/15/nfc2/"/>
    <id>https://www.dyenter.top/2018/04/15/nfc2/</id>
    <published>2018-04-15T05:21:18.000Z</published>
    <updated>2018-04-15T05:27:12.475Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.dyenter.top/2018/04/15/nfc1/">上一篇</a>中，简单的介绍了下nfc的相关知识，这一篇将以代码的形式更深入的理解nfc。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="首先肯定要申请相应的权限："><a href="#首先肯定要申请相应的权限：" class="headerlink" title="首先肯定要申请相应的权限："></a>首先肯定要申请相应的权限：</h3><p><code>&lt;uses-permission android:name=&quot;android.permission.NFC&quot; /&gt;</code><br><code>&lt;uses-feature android:name=&quot;android.hardware.nfc&quot; android:required=&quot;true&quot; /&gt;</code><br><code>&lt;uses-sdk android:minSdkVersion=&quot;14&quot;/&gt;</code><br>同时要注意最小api的版本，根据谷歌官方的说话，NFC在Android上，也是从API9才开始支持的，但是到了API14 Google才对NFC大力开发，所以等到了API15的时候，NFC的传输速度就得到了很大的加强，所以最小api最好设置为14.</p><h3 id="然后在相应的要接收nfc信息的activity中注册intent-filter："><a href="#然后在相应的要接收nfc信息的activity中注册intent-filter：" class="headerlink" title="然后在相应的要接收nfc信息的activity中注册intent filter："></a>然后在相应的要接收nfc信息的activity中注册intent filter：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot;/&gt;</span><br><span class="line">    &lt;data android:mimeType=&quot;text/plain&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;</span><br><span class="line">    android:resource=&quot;@xml/nfc_tech_filter&quot;/&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.nfc.action.TAG_DISCOVERED&quot;/&gt;</span><br><span class="line">    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure><p>如果您的活动过滤器是ACTION_TECH_DISCOVERED，你必须创建一个指定的活动支持内技术的XML资源文件，可以通过android.nfc.Tag类的getTechList()获取子集<br>其中名为nfc_tech_filter的xml文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt;</span><br><span class="line">    &lt;tech-list&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcF&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcV&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NdefFormatable&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.MifareClassic&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.MifareUltralight&lt;/tech&gt;</span><br><span class="line">        　　</span><br><span class="line">    &lt;/tech-list&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>当然您也可以指定多个tech-list组。每个的tech-list集独立地考虑，并且您的活动被认为是一个匹配，如果任何一个 tech-list组是由返回的技术的一个子集getTechList()，这提供了AND与OR匹配技术，语义。<br>下面的例子相匹配，可以支持NFCA和NDEF技术或可以支持NfcB和NDEF技术代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt;</span><br><span class="line">    &lt;tech-list&gt;</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt;</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt;</span><br><span class="line">    &lt;/tech-list&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt;</span><br><span class="line">    &lt;tech-list&gt;</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt;</span><br><span class="line">        &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt;</span><br><span class="line">    &lt;/tech-list&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>做了这么多，终于可以在activity里面读取，写入nfc了，首先我们定义了NfcScanActivity来扫描nfc设备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  ......//关键代码，onCreate中</span><br><span class="line">  // 获取默认的NFC控制器</span><br><span class="line">  mAdapter = NfcAdapter.getDefaultAdapter(this);</span><br><span class="line">  if (mAdapter == null) &#123;</span><br><span class="line">      promt.setText(&quot;设备不支持NFC！&quot;);</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!mAdapter.isEnabled()) &#123;</span><br><span class="line">      promt.setText(&quot;请在系统设置中先启用NFC功能！&quot;);</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">  //创建intent检测nfc</span><br><span class="line">  mPendingIntent = PendingIntent</span><br><span class="line">          .getActivity(this, 0, new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);</span><br><span class="line">//onResume</span><br><span class="line">if (this.mAdapter == null)</span><br><span class="line">      return;</span><br><span class="line">  if (!this.mAdapter.isEnabled()) &#123;</span><br><span class="line">      promt.setText(&quot;请在系统设置中先启用NFC功能！&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //监听nfc设备</span><br><span class="line">  this.mAdapter.enableForegroundDispatch(this, this.mPendingIntent, null, null);</span><br></pre></td></tr></table></figure></p><p>因为我们注册了Intent Filter，当扫描到设备后，系统会调用我们的app，进而会进入activity的onNewIntent(Intent paramIntent)方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onNewIntent(Intent intent) &#123;</span><br><span class="line">        setIntent(paramIntent);</span><br><span class="line">        //我们接受到消息啦，可以处理了</span><br><span class="line">// 得到是否检测到TAG触发</span><br><span class="line">        if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(intent.getAction())</span><br><span class="line">                || NfcAdapter.ACTION_TAG_DISCOVERED.equals(intent.getAction())</span><br><span class="line">                || NfcAdapter.ACTION_NDEF_DISCOVERED.equals(intent.getAction())) &#123;</span><br><span class="line">            // 处理该intent</span><br><span class="line">            Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);</span><br><span class="line">            // 获取标签id数组</span><br><span class="line">            byte[] bytesId = tag.getId();</span><br><span class="line">            //获取消息内容</span><br><span class="line">            NfcMessageParser nfcMessageParser = new NfcMessageParser(intent);</span><br><span class="line">            List&lt;String&gt; tagMessage = nfcMessageParser.getTagMessage();</span><br><span class="line"></span><br><span class="line">            if (tagMessage == null || tagMessage.size() == 0) &#123;</span><br><span class="line"></span><br><span class="line">                //Toast.makeText(this, &quot;NFC格式不支持...&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i = 0; i &lt; tagMessage.size(); i++) &#123;</span><br><span class="line">                    Log.e(&quot;tag&quot;, tagMessage.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                datas = tagMessage.get(0);</span><br><span class="line">            &#125;</span><br><span class="line">            String info = &quot;&quot;;</span><br><span class="line">            if (datas != null) &#123;</span><br><span class="line">                info += &quot;内容：&quot; + datas + &quot;\n卡片ID：&quot; + bytesToHexString(bytesId) + &quot;\n&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                info += &quot;内容：空&quot; + &quot;\n卡片ID：&quot; + bytesToHexString(bytesId) + &quot;\n&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            String[] techList = tag.getTechList();</span><br><span class="line"></span><br><span class="line">            //分析NFC卡的类型： Mifare Classic/UltraLight Info</span><br><span class="line">            String cardType = &quot;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            for (String aTechList : techList) &#123;</span><br><span class="line">                if (TextUtils.equals(aTechList, &quot;android.nfc.tech.Ndef&quot;)) &#123;</span><br><span class="line">                    Ndef ndef = Ndef.get(tag);</span><br><span class="line">                    cardType += &quot;最大数据尺寸:&quot; + ndef.getMaxSize() + &quot;字节&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info += cardType;</span><br><span class="line"></span><br><span class="line">            promt.setText(&quot;NFC信息如下：\n&quot; + info);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>传来的intent中包含了：<br><a href="https://developer.android.google.cn/reference/android/nfc/NfcAdapter.html#EXTRA_TAG" target="_blank" rel="noopener">EXTRA_TAG</a>：一个<a href="https://developer.android.google.cn/reference/android/nfc/Tag.html" target="_blank" rel="noopener">Tag</a>对象，表示扫描标签。<br><a href="https://developer.android.google.cn/reference/android/nfc/NfcAdapter.html#EXTRA_NDEF_MESSAGES" target="_blank" rel="noopener">EXTRA_NDEF_MESSAGES</a>（可选）：从标签解析NDEF消息的数组，这个就是我们要的数据，显示到屏幕上。<br><a href="https://developer.android.google.cn/reference/android/nfc/NfcAdapter.html#EXTRA_ID" target="_blank" rel="noopener">EXTRA_ID</a>（可选）：标签的ID。<br>处理消息的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 得到Intent中的NDEF数据</span><br><span class="line">    private NdefMessage[] getTagNdef(Intent intent) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        NdefMessage[] msgs = null;</span><br><span class="line">        Parcelable[] rawMsgs = intent</span><br><span class="line">                .getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);</span><br><span class="line"></span><br><span class="line">        //把序列化数据转成Messaeg对象</span><br><span class="line">        if (rawMsgs != null) &#123;</span><br><span class="line">            msgs = new NdefMessage[rawMsgs.length];</span><br><span class="line">            for (int i = 0; i &lt; rawMsgs.length; i++) &#123;</span><br><span class="line">                msgs[i] = (NdefMessage) rawMsgs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Unknown tag type</span><br><span class="line">            byte[] empty = new byte[]&#123;&#125;;</span><br><span class="line">            NdefRecord record = new NdefRecord(NdefRecord.TNF_UNKNOWN, empty,</span><br><span class="line">                    empty, empty);</span><br><span class="line">            NdefMessage msg = new NdefMessage(new NdefRecord[]&#123;record&#125;);</span><br><span class="line">            msgs = new NdefMessage[]&#123;msg&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return msgs;</span><br><span class="line">    &#125;</span><br><span class="line">     // 把Message转成List</span><br><span class="line">    private List&lt;String&gt; getNdefString(NdefMessage[] msgs) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        if (msgs != null &amp;&amp; msgs.length != 0) &#123;</span><br><span class="line">            List&lt;String&gt; tagMessage = parser(msgs[0]);</span><br><span class="line">            return tagMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后就可以显示到你想要的地方去了</p><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><h3 id="NdefRecord对象"><a href="#NdefRecord对象" class="headerlink" title="NdefRecord对象"></a>NdefRecord对象</h3><p>写入数据最关键的就是创建一个NdefRecord对象，然后通过Ndef对象的writeNdefMessage(NdefMessage message)方法写入,当然前提还是要检测到设备，这里格式是TNF_WELL_KNOWN with RTD_TEXT，即写入文本字符串，如果你想写入其他数据，请参考官方文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 创建record，格式为TNF_WELL_KNOWN with RTD_TEXT</span><br><span class="line">     *</span><br><span class="line">     * @param payload      你要写入的数据</span><br><span class="line">     * @param locale</span><br><span class="line">     * @param encodeInUtf8 编码</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">public NdefRecord createTextRecord(String payload, Locale locale, boolean encodeInUtf8) &#123;</span><br><span class="line">    byte[] langBytes = locale.getLanguage().getBytes(Charset.forName(&quot;US-ASCII&quot;));</span><br><span class="line">    Charset utfEncoding = encodeInUtf8 ? Charset.forName(&quot;UTF-8&quot;) : Charset.forName(&quot;UTF-16&quot;);</span><br><span class="line">    byte[] textBytes = payload.getBytes(utfEncoding);</span><br><span class="line">    int utfBit = encodeInUtf8 ? 0 : (1 &lt;&lt; 7);</span><br><span class="line">    char status = (char) (utfBit + langBytes.length);</span><br><span class="line">    byte[] data = new byte[1 + langBytes.length + textBytes.length];</span><br><span class="line">    data[0] = (byte) status;</span><br><span class="line">    System.arraycopy(langBytes, 0, data, 1, langBytes.length);</span><br><span class="line">    System.arraycopy(textBytes, 0, data, 1 + langBytes.length, textBytes.length);</span><br><span class="line">    NdefRecord record = new NdefRecord(NdefRecord.TNF_WELL_KNOWN,</span><br><span class="line">    NdefRecord.RTD_TEXT, new byte[0], data);</span><br><span class="line">    return record;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="生成需要的NdefMessage对象"><a href="#生成需要的NdefMessage对象" class="headerlink" title="生成需要的NdefMessage对象"></a>生成需要的NdefMessage对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> //textRecord就是上面生成的NdefRecord</span><br><span class="line">NdefMessage message = new NdefMessage(new NdefRecord[]&#123;textRecord&#125;);</span><br></pre></td></tr></table></figure><h3 id="最后写入数据："><a href="#最后写入数据：" class="headerlink" title="最后写入数据："></a>最后写入数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 写入数据</span><br><span class="line">     * @param message</span><br><span class="line">     * @param tag  intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean writeTag(NdefMessage message, Tag tag) &#123;</span><br><span class="line">        int size = message.toByteArray().length;</span><br><span class="line">        try &#123;</span><br><span class="line">            //链接nfc</span><br><span class="line">            Ndef ndef = Ndef.get(tag);</span><br><span class="line">            if (ndef != null) &#123;</span><br><span class="line">                ndef.connect();</span><br><span class="line">                if (!ndef.isWritable()) &#123;</span><br><span class="line">Toast.makeText(this, &quot;tag不允许写入&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                 </span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (ndef.getMaxSize() &lt; size) &#123;</span><br><span class="line">Toast.makeText(this,&quot;文件大小超出容量&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                 </span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ndef.writeNdefMessage(message);</span><br><span class="line">Toast.makeText(this,&quot;写入数据成功.&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">           </span><br><span class="line">                isWrite = false;</span><br><span class="line">                finish();</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NdefFormatable format = NdefFormatable.get(tag);</span><br><span class="line">                if (format != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        format.connect();</span><br><span class="line">                        format.format(message);</span><br><span class="line">                        Toast.makeText(this,&quot;格式化tag并且写入message&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      </span><br><span class="line">                        return true;</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                            Toast.makeText(this, &quot;格式化tag失败.&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                      </span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                        Toast.makeText(this, &quot;Tag不支持NDEF&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">               </span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">                Toast.makeText(this,&quot;写入数据失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码已上传至github，欢迎clone，谢谢star"><a href="#完整代码已上传至github，欢迎clone，谢谢star" class="headerlink" title="完整代码已上传至github，欢迎clone，谢谢star"></a>完整代码已上传至<a href="https://github.com/dengyuaner/AndroidNFCDemo" target="_blank" rel="noopener">github</a>，欢迎clone，谢谢star</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://www.dyenter.top/2018/04/15/nfc1/&quot;&gt;上一篇&lt;/a&gt;中，简单的介绍了下nfc的相关知识，这一篇将以代码的形式更深入的理解nfc。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="NFC" scheme="https://www.dyenter.top/tags/NFC/"/>
    
      <category term="近场通讯" scheme="https://www.dyenter.top/tags/%E8%BF%91%E5%9C%BA%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>Android近场通讯——NFC(一)</title>
    <link href="https://www.dyenter.top/2018/04/15/nfc1/"/>
    <id>https://www.dyenter.top/2018/04/15/nfc1/</id>
    <published>2018-04-15T05:07:18.000Z</published>
    <updated>2018-04-15T05:45:57.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;NFC（Near Field Communication 近场通讯），它是前几年逐渐起来的一种技术，出来之后，感觉一直不温不火的样子。直到最近有个朋友需要手机与nfc标签读写信息，让我帮忙，所以才了解这门技术，下面我们一起来了解并学习一下。<br><a href="https://developer.android.google.cn/guide/topics/connectivity/nfc/nfc.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="近场通讯"><a href="#近场通讯" class="headerlink" title="近场通讯"></a>近场通讯</h2><p>&emsp;&emsp;大家都知道android近场通讯包括我们最熟知的wifi，蓝牙，还有已经慢慢消失的红外，最后就是我们今天的主角nfc了，nfc与其他通信类型不同的是要求距离不能超过4cm（不同的nfc标签略有差别），查看官方文档，我们知道nfc通信的模式有一下三种：</p><h2 id="emsp-emsp-读卡器模式（Reader-Writer-Mode）"><a href="#emsp-emsp-读卡器模式（Reader-Writer-Mode）" class="headerlink" title="&emsp;&emsp;读卡器模式（Reader/Writer Mode）"></a>&emsp;&emsp;读卡器模式（Reader/Writer Mode）</h2><h2 id="emsp-emsp-仿真卡模式（Card-Emulation-Mode）"><a href="#emsp-emsp-仿真卡模式（Card-Emulation-Mode）" class="headerlink" title="&emsp;&emsp;仿真卡模式（Card Emulation Mode）"></a>&emsp;&emsp;仿真卡模式（Card Emulation Mode）</h2><h2 id="emsp-emsp-点对点模式（P2P-Mode）"><a href="#emsp-emsp-点对点模式（P2P-Mode）" class="headerlink" title="&emsp;&emsp;点对点模式（P2P Mode）"></a>&emsp;&emsp;点对点模式（P2P Mode）</h2><h2 id="nfc标签"><a href="#nfc标签" class="headerlink" title="nfc标签"></a>nfc标签</h2><p>&emsp;&emsp;今天主要讲的是读写模式，在开始写代码之前，有必要了解nfc的标签调度系统，标签调度系统如何解析NFC标签和特殊的工作，当它检测到NDEF消息的标记调度系统一样。NFC标签来在广泛的技术和还可以有许多不同的方式写入到其中的数据。机器人具有用于NDEF标准NDEF数据被封装的消息（内部NdefMessage），其中包含一个或多个记录（NdefRecord）。每个NDEF记录必须根据您要创建的记录类型的规格良好的。Android版 ​​还支持其它类型的标签不包含NDEF的数据，您可以通过在使用类的工作android.nfc.tech包。要了解更多有关这些技术，请参阅高级NFC主题。这些其他类型的标签工作包括编写你自己的协议栈与标签进行通信，因此，我们建议使用NDEF在可能的情况，便于开发和最大支持Android的供电设备。</p><p>现在，你有NFC标签的背景，下面的章节详细描述了Android的如何处理NDEF格式化的标签。<br>当一个Android设备扫描包含NDEF格式的数据的NFC标签，它解析该消息并试图找出数据的MIME类型或标识的URI。要做到这一点，系统读取所述第一<a href="https://developer.android.google.cn/reference/android/nfc/NdefRecord.html" target="_blank" rel="noopener">NdefRecord</a><br>内部的<a href="https://developer.android.google.cn/reference/android/nfc/NdefMessage.html" target="_blank" rel="noopener">NdefMessage</a>，以确定如何解释整个NDEF消息（一个NDEF消息可以有多个NDEF记录）。<br>在一个结构良好的NDEF消息，第一个<a href="https://developer.android.google.cn/reference/android/nfc/NdefRecord.html" target="_blank" rel="noopener">NdefRecord</a></p><p>包含以下字段：</p><p>3-bit TNF (Type Name Format) :指示如何解释可变长度类型字段</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-406ac40629b31ff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="0HF]EHB8]IQN5AC1BFIAY3M.png" title="">                </div>                <div class="image-caption">0HF]EHB8]IQN5AC1BFIAY3M.png</div>            </figure><p>Variable length type:描述了记录的类型。如果使用TNF_WELL_KNOWN，使用此字段指定记录类型定义（RTD）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-a799d2711eb454b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ZMUO)G4X)HRB%ZH0)DK_7J1.png" title="">                </div>                <div class="image-caption">ZMUO)G4X)HRB%ZH0)DK_7J1.png</div>            </figure><p>Variable length payload:要读取或写入的实际数据的有效载荷。一个NDEF消息可以包含多个NDEF记录，所以不承担全部有效载荷在NDEF消息的第一NDEF纪录。</p><h2 id="nfc分发"><a href="#nfc分发" class="headerlink" title="nfc分发"></a>nfc分发</h2><p>&emsp;&emsp;说了这么多，Android系统是怎么检测到nfc靠近并通知相应的应用程序呢？其实就是用的Intent Filter,当我们在AndroidManifest.xml的activity中注册了相应的nfc intent后，当有相应的action来临时，系统就会把nfc分发到该App中，如果有多个App符合要求，则系统会弹出对话框让用户选择。标签调度系统定义了三个意图，优先级从高到低如下：</p><h3 id="ACTION-NDEF-DISCOVERED："><a href="#ACTION-NDEF-DISCOVERED：" class="headerlink" title="ACTION_NDEF_DISCOVERED："></a>ACTION_NDEF_DISCOVERED：</h3><p>&emsp;&emsp;本意图是用来启动一个活动时，它包含一个NDEF净荷标签的扫描和是一个公认的类型。<br>&emsp;&emsp;这是最高优先级的意图，并且标签调度系统尝试尽可能任何其他意图，之前启动这一意图的活动。</p><h3 id="ACTION-TECH-DISCOVERED："><a href="#ACTION-TECH-DISCOVERED：" class="headerlink" title="ACTION_TECH_DISCOVERED："></a>ACTION_TECH_DISCOVERED：</h3><p>&emsp;&emsp;如果没有App注册过ACTION_NDEF_DISCOVERED，标签调度系统试图启动与此意向的应用程序。此意向也直接启动（不启动ACTION_NDEF_DISCOVERED在前），如果被扫描的标签包含无法映射到MIME类型或URI，或者如果标签不包含NDEF数据，但是是一个已知的标签技术NDEF数据。</p><h3 id="ACTION-TAG-DISCOVERED："><a href="#ACTION-TAG-DISCOVERED：" class="headerlink" title="ACTION_TAG_DISCOVERED："></a>ACTION_TAG_DISCOVERED：</h3><p>&emsp;&emsp;如果没有活动处理这一意图已启动ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED意图。</p><h2 id="标签调度系统工作的基本方法如下："><a href="#标签调度系统工作的基本方法如下：" class="headerlink" title="标签调度系统工作的基本方法如下："></a>标签调度系统工作的基本方法如下：</h2><p>&emsp;&emsp;1.尝试启动与由标签调度系统解析NFC标签时（无论是创建一个意图活动ACTION_NDEF_DISCOVERED或ACTION_TECH_DISCOVERED）。</p><p>&emsp;&emsp;2.如果这一意图没有活动过滤器，尝试下一个优先级最低的意图（无论是启动一个活动ACTION_TECH_DISCOVERED或ACTION_TAG_DISCOVERED，直到意图或直至标签调度系统中的应用程序过滤器尝试所有可能的目的。</p><p>&emsp;&emsp;3.如果没有应用程序筛选任何意图的，什么也不做。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-639426c951292b51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nfc_tag_dispatch.png" title="">                </div>                <div class="image-caption">nfc_tag_dispatch.png</div>            </figure><p>只要有可能，以NDEF消息和工作ACTION_NDEF_DISCOVERED的意图，因为它是最特定出的三个。<br>此意向，您可以在比其他两个意图更适当的时间启动应用程序，给用户更好的体验。</p><h2 id="下一篇Android-NFC-二"><a href="#下一篇Android-NFC-二" class="headerlink" title="下一篇Android NFC(二)"></a>下一篇<a href="https://www.dyenter.top/2018/04/15/nfc2/">Android NFC(二)</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;NFC（Near Field Communication 近场通讯），它是前几年逐渐起来的一种技术，出来之后，感觉一
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="NFC" scheme="https://www.dyenter.top/tags/NFC/"/>
    
      <category term="近场通讯" scheme="https://www.dyenter.top/tags/%E8%BF%91%E5%9C%BA%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>listview相关问题——item包含EditText</title>
    <link href="https://www.dyenter.top/2018/04/15/listview/"/>
    <id>https://www.dyenter.top/2018/04/15/listview/</id>
    <published>2018-04-15T04:56:01.000Z</published>
    <updated>2018-04-15T05:44:59.222Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在日常开发中，ListView是我们常用的控件，也是遇到坑比较多的一个控件。在之前的项目中，有这样的一个布局需求，在ListView的item中包含有EditText，第一个问题就是焦点问题，会发现edittext获取不到焦点。</p><h2 id="焦点问题"><a href="#焦点问题" class="headerlink" title="焦点问题"></a>焦点问题</h2><p>&emsp;&emsp;比如我们有如下的代码：</p><h3 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </span><br><span class="line">        android:id=&quot;@+id/activity_main&quot;    </span><br><span class="line">        android:layout_width=&quot;match_parent&quot;    </span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;    </span><br><span class="line">        &lt;ListView  android:id=&quot;@+id/listView&quot;       </span><br><span class="line">                   android:layout_width=&quot;match_parent&quot;        </span><br><span class="line">                   android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><h3 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;     </span><br><span class="line">    ListView mListView;    </span><br><span class="line">    MyAdapter mMyAdapter;    </span><br><span class="line">    @Override    </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;        </span><br><span class="line">        super.onCreate(savedInstanceState);        </span><br><span class="line">        setContentView(R.layout.activity_main);        </span><br><span class="line">        mListView = (ListView) findViewById(R.id.listView);        </span><br><span class="line">        mMyAdapter = new MyAdapter(this);        </span><br><span class="line">        mListView.setAdapter(mMyAdapter);   </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="MyAdapter-java"><a href="#MyAdapter-java" class="headerlink" title="MyAdapter.java"></a>MyAdapter.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdapter extends BaseAdapter &#123;    </span><br><span class="line">    private Context mContext;    </span><br><span class="line">    public MyAdapter(Context context) &#123;        </span><br><span class="line">        this.mContext = context;   </span><br><span class="line">    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public int getCount() &#123;        </span><br><span class="line">        return 20;    </span><br><span class="line">    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public Object getItem(int position) &#123;        </span><br><span class="line">        return null;   </span><br><span class="line">    &#125;   </span><br><span class="line">     @Override   </span><br><span class="line">     public long getItemId(int position) &#123;       </span><br><span class="line">         return 0;    </span><br><span class="line">    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;        </span><br><span class="line">        EditText editText;        </span><br><span class="line">        if (convertView == null) &#123;            </span><br><span class="line">            editText = new EditText(mContext);            </span><br><span class="line">            convertView = editText;       </span><br><span class="line">        &#125; else &#123;            </span><br><span class="line">            editText = (EditText) convertView;        </span><br><span class="line">        &#125;        </span><br><span class="line">        System.out.println(&quot;current pos:&quot; + position);        </span><br><span class="line">        return convertView;    </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当你运行上述简单的代码后发现EditText是无法获取焦点的，导致无法输入任何东东，那么原因何在呢？</p><p>&emsp;&emsp;其实，是listview先于子item抢占了焦点，那么我们首先想到的就是让listview失去焦点，让子item获取焦点（当然，listview 的onitem相关监听事件会失效）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mListView.setFocusable(false);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这是再运行发现键盘弹出了，可是editText获取到焦点然后又失去了，需要你手动再次点击才能获取到，然后才能输入。<br>而且当你输入完毕，关闭软键盘，发现输入的东西不见了，自动清空。这又产生了两个问题。</p><p>第一个问题是listview每次调用getview都会使EditText失去焦点，第二个问题归结于下面要讲的listview的item复用产生的问题。</p><p>第一种方式行不通，查询相关资料发现，可以通过给listview的item的根布局设置descendantFocusability属性。</p><h4 id="android-descendantFocusability属性有三个值："><a href="#android-descendantFocusability属性有三个值：" class="headerlink" title="android:descendantFocusability属性有三个值："></a>android:descendantFocusability属性有三个值：</h4><pre><code>beforeDescendants：viewgroup会优先其子类控件而获取到焦点afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点</code></pre><h3 id="那么我们修改adapter中的getView方法"><a href="#那么我们修改adapter中的getView方法" class="headerlink" title="那么我们修改adapter中的getView方法"></a>那么我们修改adapter中的getView方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;    </span><br><span class="line">    EditText editText;   </span><br><span class="line">    if (convertView == null) &#123;        </span><br><span class="line">        convertView = LayoutInflater.from(mContext).inflate(R.layout.list_edittext, parent, false);        </span><br><span class="line">        editText = (EditText) convertView.findViewById(R.id.editText);       </span><br><span class="line">        convertView.setTag(editText);    </span><br><span class="line">     &#125; else &#123;        </span><br><span class="line">        editText = (EditText) convertView.getTag();   </span><br><span class="line">     &#125;    </span><br><span class="line">     System.out.println(&quot;current pos:&quot; + position);    </span><br><span class="line">     return convertView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list-edittext-xml"><a href="#list-edittext-xml" class="headerlink" title="list_edittext.xml"></a>list_edittext.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;       </span><br><span class="line">    android:layout_width=&quot;match_parent&quot;              </span><br><span class="line">    android:layout_height=&quot;match_parent&quot;   </span><br><span class="line">   android:descendantFocusability=&quot;beforeDescendants&quot;         </span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;    </span><br><span class="line">    &lt;EditText  android:id=&quot;@+id/editText&quot;        </span><br><span class="line">        android:layout_width=&quot;match_parent&quot;        </span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>发现还是无效果，其实我们少了一句关键的代码，就是给相应的 activity 设置 windowSoftInputMode= adjustPan 即可。。</p><p>终上所述，我认为的解决方案就是给ListView或者ListView的item的根布局添加android:descendantFocusability=”beforeDescendants”，然后设置相应的activity 的windowSoftInputMode属性为adjustPan 。</p><h2 id="数据问题"><a href="#数据问题" class="headerlink" title="数据问题"></a>数据问题</h2><p>&emsp;&emsp;解决完焦点问题后，另一个问题就是edittext的数据问题了。当我们在当前屏幕的edittext中输入东东后，往下滑，发现下面的edittext自动输入了我们输入过得东东，这明显是我们不愿意看到的。</p><p>其实这是由于getView方法的复用view导致的，加入你在position=0的edittext中输入了内容，当你往下滑时，当position为0的view完全消失时，该view会被加入到 mActiveViews[]中，当下方的item检测到由可用的view，则从该数组中取出，所以下方的edittext的内容会跟上面你输入的一样，其实就是同一个edittext。关于listview源码级解析详见<a href="http://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">链接</a></p><h3 id="解决方案——保存edittext的内容"><a href="#解决方案——保存edittext的内容" class="headerlink" title="解决方案——保存edittext的内容"></a>解决方案——保存edittext的内容</h3><p>修改adapter代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//新增一个数组用于保存edittext的内容</span><br><span class="line">private SparseArray&lt;String&gt; mStringSparseArray;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(final int position, View convertView, ViewGroup parent) &#123;    </span><br><span class="line">    EditTextHolder editTextHolder;    </span><br><span class="line">    if (convertView == null) &#123;        </span><br><span class="line">        convertView = LayoutInflater.from(mContext).inflate(R.layout.list_edittext, parent, false);                    </span><br><span class="line"></span><br><span class="line">        editTextHolder = new EditTextHolder();       </span><br><span class="line">        editTextHolder.mEditText = (EditText) convertView.findViewById(R.id.editText);                      </span><br><span class="line"></span><br><span class="line">        editTextHolder.mMyTextWatcher = new MyTextWatcher(position, mStringSparseArray);                        </span><br><span class="line">        //给edittext设置watcher</span><br><span class="line">        editTextHolder.mEditText.addTextChangedListener(editTextHolder.mMyTextWatcher);                        </span><br><span class="line"></span><br><span class="line">        convertView.setTag(editTextHolder);    </span><br><span class="line">    &#125; else &#123;        </span><br><span class="line">         editTextHolder = (EditTextHolder) convertView.getTag();        </span><br><span class="line">         //由于复用了edittext，导致他的watcher里的position还是之前的positiono，所以需要通知</span><br><span class="line">         //watcher更新positon，才能保存正确的positon的值</span><br><span class="line">         editTextHolder.updatePosition(position);   </span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(position);    </span><br><span class="line">    editTextHolder.mEditText.setText(mStringSparseArray.get(position));   </span><br><span class="line">    return convertView;</span><br><span class="line">&#125;</span><br><span class="line">static class EditTextHolder &#123;    </span><br><span class="line">    EditText mEditText;    </span><br><span class="line">    MyTextWatcher mMyTextWatcher;    </span><br><span class="line">    public void updatePosition(int position) &#123;        </span><br><span class="line">        mMyTextWatcher.updatePosition(position);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class MyTextWatcher implements TextWatcher &#123;    </span><br><span class="line">    private int position;    </span><br><span class="line">    private SparseArray&lt;String&gt; sparseArray;    </span><br><span class="line">    //更新postion</span><br><span class="line">    public void updatePosition(int position) &#123;        </span><br><span class="line">        this.position = position;    </span><br><span class="line">    &#125;   </span><br><span class="line">    public MyTextWatcher(int position, SparseArray&lt;String&gt; sparseArray) &#123;       </span><br><span class="line">         this.position = position;        </span><br><span class="line">         this.sparseArray = sparseArray;    </span><br><span class="line">    &#125;   </span><br><span class="line">    @Override   </span><br><span class="line">    public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public void onTextChanged(CharSequence s, int start, int before, int count) &#123;    &#125;    </span><br><span class="line">    @Override    </span><br><span class="line">    public void afterTextChanged(Editable s) &#123;        </span><br><span class="line">        //保存edittext的值</span><br><span class="line">        sparseArray.put(position, s.toString());    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，发现edittext数据错乱问题解决，此方法同样适用于checkbox错乱等问题。</p><h2 id="demo工程已上传至github，有需要的可去download"><a href="#demo工程已上传至github，有需要的可去download" class="headerlink" title="demo工程已上传至github，有需要的可去download"></a>demo工程已上传至github，有需要的可去<a href="https://github.com/dengyuaner/ListViewDemo" target="_blank" rel="noopener">download</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在日常开发中，ListView是我们常用的控件，也是遇到坑比较多的一个控件。在之前的项目中，有这样的一个布局需求，在ListView的item中包含有EditText，第一个问题就是焦点问题，会发现edittext获取不到焦点。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="ListView" scheme="https://www.dyenter.top/tags/ListView/"/>
    
      <category term="EditText" scheme="https://www.dyenter.top/tags/EditText/"/>
    
  </entry>
  
  <entry>
    <title>表格筛选控件</title>
    <link href="https://www.dyenter.top/2018/04/15/grid/"/>
    <id>https://www.dyenter.top/2018/04/15/grid/</id>
    <published>2018-04-15T04:03:32.000Z</published>
    <updated>2018-04-15T05:44:24.966Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近在做一个ERP的项目，产品要求做一个类似京东，淘宝，伙伴云表格的筛选控件，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-3e460456985cbeac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="S70301-160019.jpg" title="">                </div>                <div class="image-caption">S70301-160019.jpg</div>            </figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;这个页面其实一个主页面的Activity，右滑弹出一个抽屉DrawerLayout，抽屉其实是一个fragment，我们主要的布局就在fragment里面。而这个筛选控件其中的一个其实是下拉菜单。当然原生的spinner太丑而且不符合要求，所以我用一个LinearLayout包含一个TextView（drawableRight下拉图标），加一个listview来构造。</p><h2 id="行动代码"><a href="#行动代码" class="headerlink" title="行动代码"></a>行动代码</h2><p>&emsp;&emsp;思路有了，接下来就是代码行动了，首先我们封装这个控件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br></pre></td><td class="code"><pre><span class="line">public class MySpinnerView extends LinearLayout implements MySpinnerAdapter.RadioButtonClick &#123;</span><br><span class="line">    //用于下拉图标的动画</span><br><span class="line">    private static final int MAX_LEVEL = 10000;</span><br><span class="line"></span><br><span class="line">    //用于状态保存</span><br><span class="line">    private static final String INSTANCE_STATE = &quot;instance_state&quot;;</span><br><span class="line">    private static final String SELECTED_INDEX = &quot;selected_index&quot;;</span><br><span class="line">    private static final String IS_POPUP_SHOWING = &quot;is_popup_showing&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int selectedIndex;//选中的位置</span><br><span class="line">    private Drawable drawable;//下拉图标</span><br><span class="line">    private ListView listView;</span><br><span class="line">    private MySpinnerAdapter adapter;//用于listview的adapter</span><br><span class="line">    private AdapterView.OnItemClickListener onItemClickListener;</span><br><span class="line">    private AdapterView.OnItemSelectedListener onItemSelectedListener;</span><br><span class="line">    private boolean isArrowHide, isShowing;//是否显示</span><br><span class="line">    private int textColor;</span><br><span class="line">    private int backgroundSelector;//选中颜色</span><br><span class="line">    private int datasId;</span><br><span class="line">    private TextView titleView;//title</span><br><span class="line"></span><br><span class="line">    private String titleText;</span><br><span class="line">    private int defaultPadding;//默认padding</span><br><span class="line">    private List&lt;FilterDataItem&gt; mFilterDataItems;//筛选的数据源</span><br><span class="line">    private String startDate, endDate;</span><br><span class="line">    private int lastPos = -1;//保存最近一次选中的位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public MySpinnerView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        getAttrs(context, null);</span><br><span class="line">        init(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MySpinnerView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        getAttrs(context, attrs);</span><br><span class="line">        init(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MySpinnerView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        getAttrs(context, attrs);</span><br><span class="line">        init(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Parcelable onSaveInstanceState() &#123;</span><br><span class="line">        Bundle bundle = new Bundle();</span><br><span class="line">        bundle.putParcelable(INSTANCE_STATE, super.onSaveInstanceState());</span><br><span class="line">        bundle.putInt(SELECTED_INDEX, selectedIndex);</span><br><span class="line">        bundle.putBoolean(IS_POPUP_SHOWING, isShowing);</span><br><span class="line">        dismissDropDown();</span><br><span class="line"></span><br><span class="line">        return bundle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onRestoreInstanceState(Parcelable savedState) &#123;</span><br><span class="line">        if (savedState instanceof Bundle) &#123;</span><br><span class="line">            Bundle bundle = (Bundle) savedState;</span><br><span class="line">            selectedIndex = bundle.getInt(SELECTED_INDEX);</span><br><span class="line"></span><br><span class="line">            if (adapter != null) &#123;</span><br><span class="line">                setTitle(selectedIndex);</span><br><span class="line"></span><br><span class="line">                // adapter.notifyItemSelected(selectedIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bundle.getBoolean(IS_POPUP_SHOWING)) &#123;</span><br><span class="line">                if (isShowing) &#123;</span><br><span class="line">                    post(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            showDropDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            savedState = bundle.getParcelable(INSTANCE_STATE);</span><br><span class="line">        &#125;</span><br><span class="line">        super.onRestoreInstanceState(savedState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取相关属性attr</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param attrs</span><br><span class="line">     */</span><br><span class="line">    private void getAttrs(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">        // 通过这个方法，将你在attrs.xml中定义的declare=styleable</span><br><span class="line">        // 的所有属性的值存储到TypedArray中</span><br><span class="line">        TypedArray ta = context.obtainStyledAttributes(attrs,</span><br><span class="line">                R.styleable.MySpinnerView);</span><br><span class="line">        // 从TypedArray中取出对应的值来为要设置的属性赋值</span><br><span class="line">        titleText = ta.getString(R.styleable.MySpinnerView_msv_title);</span><br><span class="line">        datasId = ta.getResourceId(R.styleable.MySpinnerView_msv_array, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        defaultPadding = getResources().getDimensionPixelSize(R.dimen.one_and_a_half_grid_unit);</span><br><span class="line"></span><br><span class="line">        setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);</span><br><span class="line">//        setPadding(getResources().getDimensionPixelSize(R.dimen.three_grid_unit), defaultPadding, defaultPadding,</span><br><span class="line">//                defaultPadding);</span><br><span class="line">        setClickable(true);</span><br><span class="line"></span><br><span class="line">        backgroundSelector = ta.getResourceId(R.styleable.MySpinnerView_msv_backgroundSelector,</span><br><span class="line">                R.drawable.spinner_selector);</span><br><span class="line"></span><br><span class="line">        textColor = ta.getColor(R.styleable.MySpinnerView_msv_textTint, -1);</span><br><span class="line">        isShowing = ta.getBoolean(R.styleable.MySpinnerView_msv_isShow, false);</span><br><span class="line"></span><br><span class="line">        isArrowHide = ta.getBoolean(R.styleable.MySpinnerView_msv_hideArrow, false);</span><br><span class="line">        if (!isArrowHide) &#123;</span><br><span class="line">            //不隐藏则显示图标</span><br><span class="line">            Drawable basicDrawable = ContextCompat.getDrawable(context, R.drawable.spinner_arrow);</span><br><span class="line">            int resId = ta.getColor(R.styleable.MySpinnerView_msv_arrowTint, -1);</span><br><span class="line">            if (basicDrawable != null) &#123;</span><br><span class="line">                drawable = DrawableCompat.wrap(basicDrawable);</span><br><span class="line">                if (resId != -1) &#123;</span><br><span class="line">                    DrawableCompat.setTint(drawable, resId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init(final Context context, AttributeSet attrs) &#123;</span><br><span class="line">        setOrientation(VERTICAL);</span><br><span class="line"></span><br><span class="line">        titleView = new TextView(context);</span><br><span class="line">        titleView.setText(titleText);</span><br><span class="line">        titleView.setPadding(defaultPadding, defaultPadding, defaultPadding, defaultPadding);</span><br><span class="line">        if (!isArrowHide) &#123;</span><br><span class="line">            titleView.setCompoundDrawablesWithIntrinsicBounds(null, null, drawable, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        listView = new ListViewInSrcollView(context);</span><br><span class="line"></span><br><span class="line">        listView.setId(getId());</span><br><span class="line">        listView.setDivider(null);</span><br><span class="line">        listView.setItemsCanFocus(true);</span><br><span class="line">        //隐藏scrollbars</span><br><span class="line">        listView.setVerticalScrollBarEnabled(false);</span><br><span class="line">        listView.setHorizontalScrollBarEnabled(false);</span><br><span class="line">        listView.setBackgroundResource(backgroundSelector);</span><br><span class="line">        //数据源，这里测试用的是assets中的json，开发者可自行构造bean和数据源</span><br><span class="line">        if (datasId != 0) &#123;</span><br><span class="line">            final String[] temp = getResources().getStringArray(datasId);</span><br><span class="line"></span><br><span class="line">            mFilterDataItems = new ArrayList&lt;&gt;();</span><br><span class="line">            for (String aTemp : temp) &#123;</span><br><span class="line">                mFilterDataItems.add(new FilterDataItem(0, aTemp, false));</span><br><span class="line">            &#125;</span><br><span class="line">            adapter = new MySpinnerAdapter(mFilterDataItems, this);</span><br><span class="line">            setAdapterInternal(adapter);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;</span><br><span class="line"></span><br><span class="line">                spinnerClick(position);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        addView(titleView);</span><br><span class="line">        addView(listView);</span><br><span class="line">        if (isShowing) &#123;</span><br><span class="line">            listView.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            listView.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前选中的位置</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int getSelectedIndex() &#123;</span><br><span class="line">        return selectedIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置当前选中位置</span><br><span class="line">     *</span><br><span class="line">     * @param position 位置</span><br><span class="line">     */</span><br><span class="line">    public void setSelectedIndex(int position) &#123;</span><br><span class="line">        if (adapter != null) &#123;</span><br><span class="line">            if (position &gt;= 0 &amp;&amp; position &lt;= adapter.getCount()) &#123;</span><br><span class="line"></span><br><span class="line">                //adapter.notifyItemSelected(position);</span><br><span class="line">                selectedIndex = position;</span><br><span class="line">                setTitle(position);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Position must be lower than adapter count!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addOnItemClickListener(@NonNull AdapterView.OnItemClickListener onItemClickListener) &#123;</span><br><span class="line">        this.onItemClickListener = onItemClickListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOnItemSelectedListener(@NonNull AdapterView.OnItemSelectedListener onItemSelectedListener) &#123;</span><br><span class="line">        this.onItemSelectedListener = onItemSelectedListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置adapter</span><br><span class="line">     *</span><br><span class="line">     * @param adapter</span><br><span class="line">     */</span><br><span class="line">    private void setAdapterInternal(MySpinnerAdapter adapter) &#123;</span><br><span class="line">        // If the adapter needs to be settled again, ensure to reset the selected index as well</span><br><span class="line">        //selectedIndex = 0;</span><br><span class="line">        listView.setAdapter(adapter);</span><br><span class="line">        //setTitle(selectedIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置adapter</span><br><span class="line">     *</span><br><span class="line">     * @param filterDataItems 数据源</span><br><span class="line">     */</span><br><span class="line">    public void setAdapter(List&lt;FilterDataItem&gt; filterDataItems) &#123;</span><br><span class="line">        this.mFilterDataItems = filterDataItems;</span><br><span class="line">        this.adapter = new MySpinnerAdapter(filterDataItems, this);</span><br><span class="line">        setAdapterInternal(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(@NonNull MotionEvent event) &#123;</span><br><span class="line">        if (event.getAction() == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            if (!isShowing) &#123;</span><br><span class="line">                showDropDown();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dismissDropDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 点击动画效果</span><br><span class="line">     *</span><br><span class="line">     * @param shouldRotateUp</span><br><span class="line">     */</span><br><span class="line">    private void animateArrow(boolean shouldRotateUp) &#123;</span><br><span class="line">        int start = shouldRotateUp ? 0 : MAX_LEVEL;</span><br><span class="line">        int end = shouldRotateUp ? MAX_LEVEL : 0;</span><br><span class="line">        ObjectAnimator animator = ObjectAnimator.ofInt(drawable, &quot;level&quot;, start, end);</span><br><span class="line">        animator.setInterpolator(new LinearOutSlowInInterpolator());</span><br><span class="line">        animator.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 隐藏</span><br><span class="line">     */</span><br><span class="line">    public void dismissDropDown() &#123;</span><br><span class="line">        if (!isArrowHide) &#123;</span><br><span class="line">            animateArrow(false);</span><br><span class="line">        &#125;</span><br><span class="line">        listView.setVisibility(View.GONE);</span><br><span class="line">        isShowing = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 展开</span><br><span class="line">     */</span><br><span class="line">    public void showDropDown() &#123;</span><br><span class="line">        if (!isArrowHide) &#123;</span><br><span class="line">            animateArrow(true);</span><br><span class="line">        &#125;</span><br><span class="line">        listView.setVisibility(View.VISIBLE);</span><br><span class="line">        isShowing = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTintColor(@ColorRes int resId) &#123;</span><br><span class="line">        if (drawable != null &amp;&amp; !isArrowHide) &#123;</span><br><span class="line">            DrawableCompat.setTint(drawable, ContextCompat.getColor(getContext(), resId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(int position) &#123;</span><br><span class="line">        String text = null;</span><br><span class="line">        lastPos = position;</span><br><span class="line">        if (adapter.getItem(position) instanceof String) &#123;</span><br><span class="line">            text = titleText + &quot;&lt;font color=\&quot;red\&quot;&gt; &quot; +</span><br><span class="line">                    &quot;(&quot; + adapter.getItem(position).toString() + &quot;)&quot; + &quot;&lt;/font&gt;&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (adapter.getItem(position) instanceof FilterDataItem) &#123;</span><br><span class="line">            FilterDataItem bean = (FilterDataItem) adapter.getItem(position);</span><br><span class="line">            text = titleText + &quot;&lt;font color=\&quot;#3b597b\&quot;&gt; &quot; +</span><br><span class="line">                    &quot;(&quot; + bean.getName() + &quot;)&quot; + &quot;&lt;/font&gt;&quot;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        titleView.setText(Html.fromHtml(text));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取选中的数据源</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public FilterDataItem getSelectedData() &#123;</span><br><span class="line">        if (selectedIndex &gt;= 8) &#123;</span><br><span class="line">            FilterDataItem item = new FilterDataItem();</span><br><span class="line">            item.setName(startDate + &quot;|&quot; + endDate);</span><br><span class="line">            item.setId(-5);</span><br><span class="line">            if (TextUtils.isEmpty(startDate)</span><br><span class="line">                    || TextUtils.isEmpty(endDate)) &#123;</span><br><span class="line">                item.setChecked(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                item.setChecked(true);</span><br><span class="line">            &#125;</span><br><span class="line">            return item;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mFilterDataItems.get(selectedIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void click(int position) &#123;</span><br><span class="line">        spinnerClick(position);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 点击方法</span><br><span class="line">     *</span><br><span class="line">     * @param position</span><br><span class="line">     */</span><br><span class="line">    private void spinnerClick(int position) &#123;</span><br><span class="line">        final FilterDataItem bean = mFilterDataItems.get(position);</span><br><span class="line">        System.out.println(&quot;点击的位置&quot; + position);</span><br><span class="line">        if (!bean.isChecked()) &#123;</span><br><span class="line">            //更改点击状态</span><br><span class="line">            bean.setChecked(true);</span><br><span class="line"></span><br><span class="line">            //把最近的已经设为true的变为false</span><br><span class="line">            if (lastPos != -1) &#123;</span><br><span class="line">                FilterDataItem item = mFilterDataItems.get(lastPos);</span><br><span class="line">                item.setChecked(false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        selectedIndex = position;</span><br><span class="line"></span><br><span class="line">        final int tempPos = position;</span><br><span class="line">        if (bean.getName().contains(&quot;时间&quot;)) &#123;</span><br><span class="line">            Calendar c = Calendar.getInstance();</span><br><span class="line">            // 直接创建一个DatePickerDialog对话框实例，并将它显示出来</span><br><span class="line">            new DatePickerDialog(getContext(),</span><br><span class="line">                    // 绑定监听器</span><br><span class="line">                    new DatePickerDialog.OnDateSetListener() &#123;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void onDateSet(DatePicker view, int year,</span><br><span class="line">                                              int monthOfYear, int dayOfMonth) &#123;</span><br><span class="line">                            if (bean.getName().contains(&quot;开始时间&quot;)) &#123;</span><br><span class="line">                                startDate = year + &quot;.&quot; + (monthOfYear + 1)</span><br><span class="line">                                        + &quot;.&quot; + dayOfMonth;</span><br><span class="line">                                bean.setName(&quot;开始时间  &quot; + startDate);</span><br><span class="line"></span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                endDate = year + &quot;.&quot; + (monthOfYear + 1)</span><br><span class="line">                                        + &quot;.&quot; + dayOfMonth;</span><br><span class="line">                                bean.setName(&quot;结束时间  &quot; + endDate);</span><br><span class="line">                            &#125;</span><br><span class="line">                            adapter.notifyDataSetChanged();</span><br><span class="line">                            setTitle(tempPos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 设置初始日期</span><br><span class="line">                    , c.get(Calendar.YEAR), c.get(Calendar.MONTH), c</span><br><span class="line">                    .get(Calendar.DAY_OF_MONTH)).show();</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            postDelayed(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    dismissDropDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 500);</span><br><span class="line">            adapter.notifyDataSetChanged();</span><br><span class="line">            setTitle(position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="然后就是在fragment的布局文件中引入它fragment-filter-xml"><a href="#然后就是在fragment的布局文件中引入它fragment-filter-xml" class="headerlink" title="然后就是在fragment的布局文件中引入它fragment_filter.xml"></a>然后就是在fragment的布局文件中引入它fragment_filter.xml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">              xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">              android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;match_parent&quot;</span><br><span class="line">              android:background=&quot;@color/white&quot;</span><br><span class="line">              android:orientation=&quot;vertical&quot;</span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot;&gt;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">            android:text=&quot;@string/filter&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tvEnsure&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_alignParentRight=&quot;true&quot;</span><br><span class="line">            android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">            android:layout_marginRight=&quot;10dp&quot;</span><br><span class="line">            android:background=&quot;@drawable/corner_btn&quot;</span><br><span class="line">            android:padding=&quot;5dp&quot;</span><br><span class="line">            android:text=&quot;@string/ensure&quot;</span><br><span class="line">            android:textColor=&quot;@color/white&quot;/&gt;</span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ScrollView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;com.dy.filter.MySpinnerView</span><br><span class="line">                android:id=&quot;@+id/groupView&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                app:msv_backgroundSelector=&quot;@color/radio_bg&quot;</span><br><span class="line">                app:msv_isShow=&quot;false&quot;</span><br><span class="line">                app:msv_title=&quot;对象&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;com.dy.filter.MySpinnerView</span><br><span class="line">                android:id=&quot;@+id/exponentView&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                app:msv_backgroundSelector=&quot;@color/radio_bg&quot;</span><br><span class="line">                app:msv_isShow=&quot;false&quot;</span><br><span class="line">                app:msv_title=&quot;指数&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;com.dy.filter.MySpinnerView</span><br><span class="line">                android:id=&quot;@+id/timeView&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                app:msv_backgroundSelector=&quot;@color/radio_bg&quot;</span><br><span class="line">                app:msv_isShow=&quot;false&quot;</span><br><span class="line">                app:msv_title=&quot;查询时间&quot;/&gt;</span><br><span class="line">        &lt;/LinearLayout&gt;</span><br><span class="line">    &lt;/ScrollView&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="最后上activity的布局文件，就是一个drawerlayout"><a href="#最后上activity的布局文件，就是一个drawerlayout" class="headerlink" title="最后上activity的布局文件，就是一个drawerlayout"></a>最后上activity的布局文件，就是一个drawerlayout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:id=&quot;@+id/drawer_layout&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RelativeLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:background=&quot;@color/blue&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id=&quot;@+id/tvBack&quot;</span><br><span class="line">                android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">                android:layout_marginLeft=&quot;10dp&quot;</span><br><span class="line">                android:text=&quot;返回&quot;</span><br><span class="line">                android:textColor=&quot;@color/white&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id=&quot;@+id/tvFilterExponent&quot;</span><br><span class="line">                android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">                android:textColor=&quot;@color/white&quot;</span><br><span class="line">                tools:text=&quot;订单金额&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id=&quot;@+id/tvFilter&quot;</span><br><span class="line">                android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_alignParentRight=&quot;true&quot;</span><br><span class="line">                android:layout_margin=&quot;10dp&quot;</span><br><span class="line">                android:drawableLeft=&quot;@drawable/ic_action_select&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:text=&quot;筛选&quot;</span><br><span class="line">                android:textColor=&quot;@color/white&quot;/&gt;</span><br><span class="line">        &lt;/RelativeLayout&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">    &lt;!-- 抽屉内容 --&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=&quot;@+id/drawer_content&quot;</span><br><span class="line">        android:layout_width=&quot;280dp&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_gravity=&quot;end&quot;</span><br><span class="line">        android:clickable=&quot;true&quot;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="上效果图"><a href="#上效果图" class="headerlink" title="上效果图"></a>上效果图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3287039-13e943e00acdc5f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="123.jpg" title="">                </div>                <div class="image-caption">123.jpg</div>            </figure><h2 id="最后上demo地址，点击github"><a href="#最后上demo地址，点击github" class="headerlink" title="最后上demo地址，点击github"></a>最后上demo地址，<a href="https://github.com/dengyuaner/FilterDemo" target="_blank" rel="noopener">点击github</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近在做一个ERP的项目，产品要求做一个类似京东，淘宝，伙伴云表格的筛选控件，如下图所示：&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
  
      
    
    </summary>
    
      <category term="Android" scheme="https://www.dyenter.top/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.dyenter.top/tags/Android/"/>
    
      <category term="自定义View" scheme="https://www.dyenter.top/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.dyenter.top/2018/04/14/hello-world/"/>
    <id>https://www.dyenter.top/2018/04/14/hello-world/</id>
    <published>2018-04-14T13:23:41.917Z</published>
    <updated>2018-04-14T15:58:58.848Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
